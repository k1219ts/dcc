import datetime, time, os, json, getpass, re

from pymongo import MongoClient
import pymongo
from dxname import tag_parser

try:
    from dxConfig import dxConfig
except:
    import dxConfig

DBIP = dxConfig.getConf('DB_IP')
DBNAME = 'PIPE_PUB'

# DEPRECATED!!!!
def getPubVersion(show, shot, data_type):
    client = MongoClient(DBIP)
    db = client['PIPE_PUB']
    coll = db[show]
    recentDoc = coll.find_one({'show': show,
                               'shot': shot,
                               'data_type': data_type},
                              sort=[('version', pymongo.DESCENDING)])
    if recentDoc:
        return recentDoc['version']
    else:
        return 0

def getLatestPubVersion(show, seq, shot, data_type,plateType=None):
    client = MongoClient(DBIP)
    db = client[DBNAME]
    coll = db[show]
    if plateType:
        recentDoc = coll.find_one({'show': show,
                                   'shot': shot,
                                   'data_type': data_type,
                                   'task_publish.plateType':plateType},
                                  sort=[('version', pymongo.DESCENDING)])
    else:
        recentDoc = coll.find_one({'show': show,
                                   'shot': shot,
                                   'data_type': data_type},
                                  sort=[('version', pymongo.DESCENDING)])

    if recentDoc:
        return recentDoc['version']
    else:
        return 0

def matchmove_insert(jsonFile):
    pass
    # client = MongoClient(DBIP)
    # fileKey = os.path.splitext(os.path.basename(jsonFile))[0]
    # sampleDict = json.loads(open(jsonFile, 'r').read())
    # show = sampleDict['show']
    #
    # db = client.SHOT
    # coll = db[show]
    #
    # result = coll.update({"show":show,"shot":sampleDict['shot']},
    #                     {'$set':{'matchmove.matchmove.%s' % fileKey:sampleDict}},
    #                     upsert=True
    #                     )
    #
    # return result

def camera_insert(jsonFile):
    pass
    # client = MongoClient(DBIP)
    # fileKey = os.path.splitext(os.path.basename(jsonFile))[0]
    # sampleDict = json.loads(open(jsonFile, 'r').read())
    # show = sampleDict['show']
    #
    # db = client.SHOT
    # coll = db[show]
    # result = coll.update({"show":show,"shot":sampleDict['shot']},
    #                     {'$set':{'matchmove.camera.%s' % fileKey:sampleDict}},
    #                     upsert=True
    #                     )
    # return result

def distortion_insert(jsonFile):
    #DEPRECATE

    # # DISTORTION INFO PIPELINE V1
    # client = MongoClient(DBIP)
    # fileKey = os.path.splitext(os.path.basename(jsonFile))[0]
    # sampleDict = json.loads(open(jsonFile, 'r').read())
    # show = sampleDict['show']
    #
    # db = client.SHOT
    # coll = db[show]
    #
    # result = coll.update({"show":show,"shot":sampleDict['shot']},
    #                     {'$set':{'matchmove.distortion.%s' % fileKey:sampleDict}},
    #                     upsert=True
    #                     )

    try:
        # DISTORTION INFO PIPELINE V2
        sampleDict = json.loads(open(jsonFile, 'r').read())

        client = MongoClient(DBIP)

        show = sampleDict['show']
        shot = sampleDict['shot']
        seq =  sampleDict['seq']
        data_type = 'distortion'

#        recVer = getPubVersion(show, shot, data_type)
        recVer = getLatestPubVersion(show, seq, shot, data_type, plateType=sampleDict['plateType'])
        ver = recVer + 1

        db = client['PIPE_PUB']
        coll = db[show]

        pubDic = {}
        pubDic['show'] = show
        pubDic['shot'] = shot
        pubDic['sequence'] = seq
        pubDic['version'] = ver
        pubDic['data_type'] = 'distortion'
        pubDic['task'] = 'matchmove'
        pubDic['artist'] = sampleDict['user']
        pubDic['enabled'] = True
        pubDic['time'] = datetime.datetime.now().isoformat()
        pubDic['task_publish'] = sampleDict
        pubDic['tags'] = tag_parser.run(sampleDict['distortionNukeScript'])
        pubDic['files'] = {'path': [sampleDict['distortionNukeScript']]}
        if 'distortionNuke11Script' in sampleDict:
            pubDic['files'].update( { 'nuke11_path': [sampleDict['distortionNuke11Script']] } )

        result = coll.insert_one(pubDic)

    except:
        print("PIPELINE V2 ERROR")
        print(pubDic)

    return result


def makeWorkRecord(platform, action, filepath, etc={}):
    if filepath.startswith('/netapp/dexter/show'):
        filepath = filepath.replace('/netapp/dexter/show', '/show')
    seps = filepath.split('/')
    show = 'unknown'

    dbDoc = {}
    dbDoc['action'] = action
    dbDoc['pubdev'] = 'dev'
    dbDoc['type'] = 'unknown'
    dbDoc['name'] = 'unknown'
    dbDoc['version'] = 'unknown'
    dbDoc['workversion'] = 'unknown'
    dbDoc['filepath'] = filepath
    dbDoc['user'] = getpass.getuser()
    dbDoc['time'] = datetime.datetime.now().isoformat()
    dbDoc['task'] = 'unknown'
    dbDoc['platform'] = platform.lower()
    dbDoc['team'] = 'unknown'
    dbDoc['etc'] = etc

    try:
        # TODO: UGLY WAY TO CHECK PUB OR DEV
        if 'pub' in seps:
            dbDoc['pubdev'] = 'pub'

        if len(seps) > 8:
            if (seps[1] == 'show'):
                show = seps[2]

            if (seps[3] == 'shot') or (seps[3] == 'asset'):
                dbDoc['type'] = seps[3]
                dbDoc['name'] = seps[5]

                if seps[3] == 'asset':
                    dbDoc['team'] = seps[3]
                else:
                    dbDoc['team'] = seps[6]

                if seps[6] == 'comp':
                    dbDoc['task'] = seps[7]
                else:
                    dbDoc['task'] = seps[6]

        if re.search('v[0-9]+', os.path.basename(filepath)):
            dbDoc['version'] = int(re.search('v[0-9]+', os.path.basename(filepath)).group(0)[1:])
            print("get version!!")

        if re.search('w[0-9]+', os.path.basename(filepath)):
            dbDoc['workversion'] = int(re.search('w[0-9]+', os.path.basename(filepath)).group(0)[1:])

    except Exception as e:
        print("generate doc error")
        print(e)

    return show, dbDoc


def insertWorkRecord(show, doc):
    client = MongoClient(DBIP)
    db = client['WORK']
    coll = db[show]
    return coll.find_one_and_update({'filepath' : doc['filepath'],
                                     'user' : doc['user'],
                                     'action' : doc['action']},
                                    {'$set' : doc,
                                     '$inc': {'count': 1}},
                                    upsert=True
                                    )


def recordWork(platform, action, filepath, etc={}):
    show, doc = makeWorkRecord(platform, action, filepath, etc)
    result = insertWorkRecord(show, doc)
    return result
