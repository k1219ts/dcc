'''
    Copyright & Author: 2016, Sehwi Park <sehwida@gmail.com>

    Description:
        Names and Paths generator class
'''

import os
import re
import yaml
from copy import deepcopy
from collections import defaultdict
from dxname.utilities import libpath
from dxname.parser import substitute_keys


class Coder(object):
    '''
    Long Name Generator
    '''

    def __init__(self, family='Global', env=os.environ, parent=None):
        '''
        Args:
            family (str): family name of this Coder instance
            env (dict): dictionary of environment variables
            parent (Coder): parent instance to inherit attributes
        '''
        if parent and not isinstance(parent, Coder):
            msg = 'Parent instance should be the same type: %s' % str(parent)
            raise TypeError(msg)

        self._family = family
        self._env = env
        self._flag = defaultdict(Coder.Flag)  # flag instances
        self._flag_raw_data = {}  # configuration data for flags
        self._product = {}  # product rules
        self._myProduct = {}  # don't have parent product rules
        self._child = {}  # child instances
        self._rule_raw_data = {}  # raw data of naming rules

        self._parent = parent
        if parent:
            self._inherit(parent)

        self._default_keys = self.__dict__.keys() + Coder.__dict__.keys()
        return

    def _inherit(self, parent):
        '''
        Inherit naming rules from parent
        Args:
            parent (Coder): parent instance to inherit naming rules
        '''
        for key, flag in parent._flag.iteritems():
            self._flag[key] = flag
            flag._users.append(self)

        self._product = deepcopy(parent._product)

        return

    @property
    def name(self):
        return self._family

    @property
    def parent(self):
        return self._parent

    @property
    def children(self):
        '''
        Returns:
            (list) children names
        '''
        return self._child.keys()

    @property
    def child(self):
        '''
        Returns:
            (dict) dictionary of child instances
        '''
        return dict(**self._child)

    def add_child(self, name, rule={}):
        '''
        Add Coder instance as achild

        Args:
            name (str): new family member's name
            rule (dict): new naming rule
        Returns:
            (Coder) a new coder instance
        '''
        if name in self._default_keys:
            msg = 'Reserved keyword [%s]' % ', '.join(self._default_keys)
            raise NameError(msg)

        child = self.__class__(name, parent=self)
        child.update_rule(rule, recursive=True)
        self._child[name] = child

        # register as class attribute (direct access)
        self.__dict__[name] = child

        return child

    @property
    def flags(self):
        '''
        Returns:
            (list) flag names
        '''
        return self._flag.keys()

    @property
    def flag(self):
        '''
        Returns:
            (FlagDict) flag setter dictionary
        '''
        return Coder.FlagDict(self._flag)

    @property
    def products(self):
        '''
        Returns:
            (list) product names
        '''
        return self._product.keys()

    @property
    def myProducts(self):
        '''
        :return:
         (list) product names but don't return parent products
        '''
        # parentProducts = []
        # parent = self.parent
        # while (parent != None):
        #     for product in parent.products:
        #         if not product in parentProducts:
        #             parentProducts.append(product)
        #     parent = parent.parent
        #
        # products = []
        # for product in self.products:
        #     if not product in parentProducts:
        #         products.append(product)
        #
        # print "myProduct :", products

        return self._myProduct

    @property
    def product(self):
        '''
        Returns:
            (ProductDict) product value generator dictionary
        '''
        return Coder.ProductDict(self._product, self)

    def _get_product_value(self, product_name='path'):
        '''
        Args:
            product_name (str): product name to generate (default: 'path')
        Returns:
            (str) generate name by flag and product expressions
        '''
        prod_expression = self._product.get(product_name, '')

        if not prod_expression:
            msg = 'Undefined product "%s" ' % product_name
            raise KeyError(msg)

        return self.encode(prod_expression)

    @property
    def environ(self):
        '''
        Returns:
            (dict) current Coder's environment variables
        '''
        return deepcopy(self._env)

    @environ.setter
    def environ(self, environ_dict):
        if not isinstance(environ_dict, dict):
            raise TypeError('Environment variable accepts only a dictionary')
        self._env = environ_dict

    def encode(self, expression):
        '''
        Directly encode an expression

        Args:
            expression (str): dxname name expression
        Returns:
            (str) generated name via flags and environment variables

        '''
        prod_extended = self._substitute_product(expression)
        flag_expression = self._substitute_flag(prod_extended)
        result = self._substitute_environment(flag_expression)

        return result

    def decode(self, product, product_name='path'):
        '''
        Extract flag values from product
        Args:
            product (str): string in format of the product rule
            product_name (str): product name for naming rule
        Returs:
            (dict) flag names and values
        '''
        decode_exp, flag_exp = self._decode_expression(product_name)

        regex = re.match(decode_exp, product)

        if not regex:
            msg = 'Value does not match with the product expression: \n'
            msg += '    (%s) ' % product_name + decode_exp
            raise ValueError(msg)

        result = regex.groupdict()

        ret_val = dict()

        for key, val in result.iteritems():

            pattern = Coder.DecoderPatternDict.suffix + '[0-9]+'
            key_clean = re.sub(pattern, '', key)

            if not key == key_clean:
                if not result.get(key_clean) == val:
                    msg = 'Unmatching values for one flag. \n'
                    msg += '    product (%s): ' % product_name
                    msg += flag_exp + '\n'
                    msg += '    flag (%s): ' % (key_clean)
                    msg += '%s <-> %s' % (val, result.get(key_clean))

                    raise ValueError(msg)
            else:
                ret_val[key] = val

        return ret_val

    def _decode_expression(self, product_name):
        '''
        Args:
            product_name (str): product key to make decode pattern
        Returns:
            (str, str) decode expression, and original flag expression
        '''
        prod_expression = self._product.get(product_name, '')
        prod_extended = self._substitute_product(prod_expression)
        flag_expression = self._substitute_environment(prod_extended)

        for char in ('\.',):
            # escape wild characters
            flag_expression = re.sub(char, char, flag_expression)

        flags_decoder = Coder.DecoderPatternDict()
        for key, flag in self._flag.iteritems():
            flags_decoder[key] = flag.decode_pattern

        decode_exp = substitute_keys('\(([a-zA-Z0-9-_]+)\)',
                                     flags_decoder,
                                     flag_expression)

        return ('^' + decode_exp + '$', flag_expression)

    class DecoderPatternDict(dict):
        '''
        Special key iterator to avoid duplication of flag keyword for decoding
        '''

        suffix = '_' * 10

        def __init__(self):
            self._key_count = defaultdict(int)

            dict.__init__(self)

        def __getitem__(self, key):
            '''
            Returns:
                (str) added suffix at multiple calls for each keyword
            '''
            val = dict.__getitem__(self, key)

            count = self._key_count[key]
            count += 1
            if count > 1:
                val = re.sub(key, key + self.suffix + '%d' % count, val)

            self._key_count[key] = count

            return val

    class ProductDict(dict):
        '''
        Convenience class to get product output easier
            * use get() method to get the raw expression of a product
        '''

        def __init__(self, source_dict, parent):
            self.update(source_dict)
            self._parent = parent

        def __getitem__(self, key):
            return self._parent._get_product_value(key)

        def __setitem__(self, key, value):
            self._parent._product.__setitem__(key, value)
            dict.__setitem__(key, value)

    class FlagDict(dict):
        '''
        Convenience class to set flag values easier
        '''

        def __init__(self, source_dict):
            self.update(source_dict)

        def __setitem__(self, key, value):
            self.__getitem__(key).value = value

    class Flag(object):
        '''
        Data class for flags
        Properties:
            default (str): default value or expression
            pattern (str): regular expression for validity
            value (str): current flag value
            name (str): flag name (accepts only [A-Z_]+)
        '''

        name_pattern = re.compile('[A-Z_]+$')

        def __init__(self):

            self._container = None
            self._users = list()
            self._name = None
            self._default = None
            self._pattern_rex = None
            self._default_val = None
            self._val = None

            return

        def __deepcopy__(self, memo={}):
            '''
            deepcopy constructor
            '''
            inst = self.__class__()
            inst.initialize(self._container, self._name,
                            self._default, self.pattern)

            return inst

        def __str__(self):
            '''
            print or str casting
            '''
            return self.value

        def initialize(self, container, name, default, pattern='.+'):
            '''
            Initialize or Update flag instance
            Args:
                container (Coder): class instance holding this flag
                name (str): flag name
                default (str): default value expression
                pattern (str): flag validity pattern
            '''

            if not self.name_pattern.match(name):
                msg = 'Invalid Flag name: ' + str(name)
                msg += '    Flag name should match to '
                msg += str(self.name_pattern.pattern[:-1])

                raise ValueError(msg)

            self._container = container
            self._name = name

            self.default = default
            self.pattern = pattern

            return

        @property
        def name(self):
            return self._name

        @property
        def default(self):
            '''
            Returns:
                (str) default value or expression
            '''
            return self._default

        @default.setter
        def default(self, default_value):
            '''
            Args:
                default_value (str): value or simple expression
                    e.g. test -> test, {USER} -> os.environ['USER']
            '''

            if self.has_default_value():
                self._default = default_value
                self._val = self._get_default_value()
            else:
                self._default = default_value

            return

        @property
        def pattern(self):
            '''
            Returns:
                (str) pattern expression
            '''
            return self._pattern_rex.pattern

        @pattern.setter
        def pattern(self, new_pattern):
            '''
            Args:
                new_pattern (str): regular expression for validity of value
            '''
            try:
                self._pattern_rex = re.compile(new_pattern)
            except: #Exception, _:
                raise ValueError('Invalid pattern for a flag: %s (flag: %s)'
                                 '' % (new_pattern, self._name))

            return

        @property
        def decode_pattern(self):
            '''
            Returns:
                (str) decode pattern expression
            '''
            return '(?P<%s>%s)' % (self.name, self.pattern)

        @property
        def value(self):
            '''
            Returns:
                (str) current flag value
            '''
            return self._val

        @value.setter
        def value(self, new_value, ignore_pattern=False):
            '''
            Args:
                new_value (str): new flag value
                ignore_pattern (bool): bypass pattern check (default: False)
            '''
            if not ignore_pattern and not self.is_valid_value(new_value):
                raise ValueError('Invalid value for a pattern:'
                                 ' "%s" -> "%s" (flag: %s)'
                                 % (new_value, self.pattern, self._name))

            self._val = new_value

            return

        def is_valid_value(self, value):
            '''
            Returns:
                (None or SRE_Match) validity of input value
            Args:
                value (str): string to check validity to this flag value
            '''
            return self._pattern_rex.match(value)

        def has_valid_value(self):
            '''
            Returns:
                (None or SRE_Match) validity of current value
            '''
            return self.is_valid_value(self._val)

        def has_default_value(self):
            '''
            Returns:
                (bool) True if current value is the same as default value
            '''
            return self._default_val == self.value

        env_extractor = re.compile('{([a-zA-Z0-9-_]+)}')

        def _get_default_value(self):
            '''
            replace default value pattern to actual value
            '''
            default = self._default

            rex = self.env_extractor.match(default)
            if not rex:
                return default

            key = rex.groups()[0]

            env = self._container._env
            if key not in env:
                raise KeyError('Cannot find an environment variable:'
                               ' %s (expression: %s)' % (self._name, default))
            self._default_val = env.get(key, default)

            return self._default_val

        pass  # end of class Flag

    def _substitute_product(self, expression):
        '''
        Substitute product variables to values in expression
            e.g. <path> -> (USERNAME)_(VER)
        Args:
            expression (str): target expression to try match
        '''
        prod_dict = self._product

        return substitute_keys('<([a-zA-Z0-9-_]+)>', prod_dict, expression, True)

    def _substitute_flag(self, expression):
        '''
        Substitute flag variables to values in expression
            e.g. (USERNAME) -> {USER}
        Args:
            expression (str): target expression to try match
        '''
        flags = self._flag

        return substitute_keys('\(([a-zA-Z0-9-_]+)\)', flags, expression)

    def _substitute_environment(self, expression):
        '''
        Substitute environment variables to values in expression
            e.g. {USER} -> guest
        Args:
            expression (str): target expression to try match
        '''
        env_dict = self._env

        return substitute_keys('{([a-zA-Z0-9-_]+)}', env_dict, expression)

    def update_rule(self, rule_data, recursive=False):
        '''
        Update current naming rules
        Args:
            rule_data (dict): naming rule data
            recursive (bool): create and update children if True

        '''
        self._rule_raw_data = rule_data

        for key, attr in rule_data.get('__flag__', {}).iteritems():
            if key not in self._flag_raw_data:
                self._flag_raw_data[key] = {}
            self._flag_raw_data[key].update(attr)

            pass

        self._initialize_flags()

        self._myProduct = rule_data.get('__product__', {})
        self._product.update(rule_data.get('__product__', {}))

        if recursive:
            children_data = rule_data.get('__child__', {})
            self._child = dict()

            for key, val in children_data.iteritems():
                self.add_child(key, val)
            pass

        return

    def _initialize_flags(self):
        '''
        Initialize or Update flag instances
        '''

        for key, attr in self._flag_raw_data.iteritems():
            flag = Coder.Flag()
            flag.initialize(self, key,
                            attr.get('__default__', 'default'),
                            attr.get('__pattern__', '.+'))

            if self._flag[key]._container == self:
                # update children instances
                for child in self._flag[key]._users:
                    child._flag[key] = flag
                    flag._users.append(child)

            self._flag[key] = flag

        return

    def load_rulebook(self, file_name='dxname.yaml'):
        '''
        Search a configuration from paths in an environment variable,
            DX_NAME_PATH, and then build naming rule encoder/decoder.
        Args:
            file_name (str): naming file name in search directories
        '''
        config_paths = os.environ.get('DX_NAME_PATH', '').split(':')
        # config_paths.sort(reverse=True) # lower hierarchy first

        # package sample as default
        yml_path = libpath('preset', 'dxname.yaml')

        for directory in reversed(config_paths):
            file_path = os.path.join(directory, file_name)
            if os.access(file_path, os.R_OK):
                yml_path = file_path

                break
            pass

        data = self.load_yaml(yml_path)

        return self.update_rule(data, recursive=True)

    @staticmethod
    def load_yaml(yml_path):
        '''
        Returns:
            (dict) naming rule data dictionary
        Args:
            file_name (str): file name to read (default='dexter.yaml')
        '''

        with open(yml_path, 'r') as yml_file:
            data = yaml.load(yml_file.read())

        return data
