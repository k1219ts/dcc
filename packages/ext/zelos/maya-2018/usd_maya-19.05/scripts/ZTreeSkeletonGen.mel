//----------------------//
// ZTreeSkeletonGen.mel //
//-------------------------------------------------------//
// author: Wanho Choi @ Dexter Studios                   //
//         Nayoung Kim @ Dexter Studios                  //
// last update: 2017.03.07                               //
//-------------------------------------------------------//

global proc CreateZTreeSkeletonGen()
{
	if( !`pluginInfo -q -loaded "ZeomForMaya"` )
	{
		error( "ZeomForMaya is not loaded." );
		return;
	}

	string $selected[] = `ls -sl -type transform`;
	if( size( $selected ) != 1 )
	{
		error( "ZTreeSkeletonGen supports only single mesh at a time." );
		return;
	}

	string $treeMesh = $selected[0];
	string $treeShapes[] = `listRelatives -shapes $treeMesh`;
	string $treeShape = $treeShapes[0];

	if( `nodeType $treeShape` != "mesh" )
	{
		error( $treeShape + " is not a mesh." );
		return;
	}

	// Separate.
	// * WILL BE TERMINATED IF USER SELECTED A SINGLE MESH. (NOT COMBINED)
	string $xforms[] = `polySeparate -ch 0 $treeShape`;	// result: mesh xforms

	string $ZTreeSkeletonGen = `createNode ZTreeSkeletonGen`;

	int $i=0;
	for( $xform in $xforms )
	{
		string $shapes[] = `listRelatives -shapes $xform`;
		string $shape = $shapes[0];

		connectAttr ($shape+".worldMesh") ($ZTreeSkeletonGen+".inMeshes["+$i+"]");

		$i++;
	}
}

global proc CreateZTreeSkeletonJoints( string $ZTreeSkeletonGen, string $curveNamesStr )
{
	string $curveNames[];
	tokenize $curveNamesStr " " $curveNames;

	int $numCurves = size( $curveNames );

	int $parentId[] = `getAttr ($ZTreeSkeletonGen+".parentCurves")`;
	int $parentCV[] = `getAttr ($ZTreeSkeletonGen+".parentCVs")`;
	int $numCVs[] = `getAttr ($ZTreeSkeletonGen+".curveNumCVs")`;

	// Create all the joints.
	int $i=0;
	for( ; $i<$numCurves; $i++ )
	{
		string $crvName = $curveNames[$i];
		int $numCV = $numCVs[$i];

//print( $i + " " + $crvName + " " + $numCV + "\n" );

		string $j0 = "";

		int $j=0;
		for( ; $j<$numCV; $j++ )
		{
			vector $p = `pointPosition ($crvName+".cv["+$j+"]")`;

//print( $j + ": " + $p + "\n" );

			if( $j == 0 ) {

				// Skip.
				select -d;
				$j0 = `joint -p ($p.x) ($p.y) ($p.z)`;

			} else {

				string $j1 = `joint -p ($p.x) ($p.y) ($p.z)`;
				joint -e -zso -oj xyz -sao yup $j0;
				$j0 = $j1;

			}
		}
	}

	// Get all joint's name.
	string $joints[] = `ls -type "joint"`;

	// Parent.
	$i=0;
	for( ; $i<$numCurves; $i++ )
	{
		int $numCV = $numCVs[$i];

		int $head=0;

		int $j=0;
		for( ; $j<$i; $j++ )
		{
			$head = $head + $numCVs[$j];
		}

		int $id = $parentId[$i];

		if( $id == -1 ) {

			// Skip.
			// Main branch's joints are not need to be parented.

		} else {

			int $cv = $parentCV[$i];

			int $parentJointHead=0;
			int $k=0;
			for( ; $k<$id; $k++ )
			{
				$parentJointHead = $parentJointHead + $numCVs[$k];
			}

			int $idx = $parentJointHead + $cv;

			parent $joints[$head] $joints[$idx];

		}
	}

	string $solver = `ikSolver -st "ikSplineSolver"`;

	// Select all the curves and make them dynamic.
	$i=0;
	for( ; $i<$numCurves; $i++ )
	{
		string $crvName = $curveNames[$i];
		select -add $crvName;
	}
	makeCurvesDynamic 2 { "1", "0", "1", "1", "0"};

	// Find the output curve names and set the ikSplineHandle.
	$i=0;
	for( ; $i<$numCurves; $i++ )
	{
		string $crvName = $curveNames[$i];

		int $numCV = $numCVs[$i];

		int $head=0;
		int $j=0;
		for( ; $j<$i; $j++ )
		{
			$head = $head + $numCVs[$j];
		}

		int $tail = $head + $numCVs[$i] - 1;

		string $tokens[];
		tokenize $crvName "|" $tokens;	// |curve1|curveShape1
		string $xform = $tokens[0];

		string $dests[] = `connectionInfo -dfs ($xform+".worldMatrix")`;
		string $dest = $dests[0];

		tokenize $dest "." $tokens;
		string $follicleShape = $tokens[0];

		string $res[] = `connectionInfo -dfs ($follicleShape+".outCurve")`;
		string $destCurve = $res[0];

		tokenize $destCurve "." $tokens;
		string $outputCurveShape = $tokens[0];

		select -r $joints[$head];
		select -add $joints[$tail];
		ikHandle -sol $solver -ccv false -scv false -c $outputCurveShape;

//print( $i + " " + $outputCurveShape + " " + $joints[$head] + " " + $joints[$tail] + "\n" );

	}
}

