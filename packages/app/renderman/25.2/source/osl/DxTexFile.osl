/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 1986-2021 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

#include "Manifold.h"
#include "PxrOSLTexture.h"
#include "PxrOSLColor.h"
#include "Bump.h"

struct ColorOpacity
{
    color c;
    float a;
};



shader DxTexture
[[
    int rfm_nodeid = 3000050,
    string rfm_classification = "rendernode/RenderMan/pattern/texture",
    string rfh_classification = "Pattern/Texture",
    string help = "Read a texture file."
]]
(
    // input values
    int computeMode = 1
    [[
        string widget = "mapper",
        string options = "File:0|TxPrimVars:1",
        string label = "Process Mode",
        string help="TxPrimvars : txBasePath, txAssetName(old-stype), txLayerName, txVersion",
        int connectable = 0
    ]],

    string txChannel = ""
    [[
        string label = "Tx Channel",
        int connectable = 0,
        string conditionalVisOp="equalTo",
        string conditionalVisPath="../computeMode",
        string conditionalVisValue="1",
        string help = "1. ${txBasePath}/tex/${txVersion}/${txLayerName}<br>2. asset/${txAssetName}/texture/tex/${txVersion}/${txLayerName}"
    ]],

    int txVarNum = 1
    [[
        string label = "Enable Tx Variation",
        string widget = "checkBox",
        int connectable = 0,
        string conditionalVisOp="equalTo",
        string conditionalVisPath="../computeMode",
        string conditionalVisValue="1",
        string help = "Enable Texture Variation by txVarNum primvar"
    ]],

    string filename = ""
    [[
        string widget = "assetIdInput",
        string label = "Filename",
        string options = "texture",
        int connectable = 0,
        string conditionalVisOp="equalTo",
        string conditionalVisPath="../computeMode",
        string conditionalVisValue="0",
        string help = "To variate texture in file mode<br>please change the variation number to # on file path.<br>(eg. name_diffC_4.tex > name_diffC_#.tex)"
    ]],

    int firstChannel = 0
    [[
        string label = "First Channel Offset",
        int connectable = 0,
        string help = "Offsets the first channel to be looked up. Usually, you want to start with "
                      "channel 0 (RGB of RGBA texture), but if you are using a multi-channel "
                      "openexr texture, you may need to point to the correct channel. Let's say we "
                      "have a texture containing 9 channels organized in 3 RGB groups (diff.r, "
                      "diff,g, diff.b, spec.r, spec.g, spec.b, ior.r, ior.g, ior.b). If you want to "
                      "read the spec RGB channels, you will have to set firstChannel to 3. "
    ]],
    int atlasStyle = 0
    [[
        string label = "Atlas Style",
        string widget = "mapper",
        string options = "None:0|UDIM (Mari):1|UV Tile Base-1 (Mudbox):2|UV Tile Base-0 (Zbrush):3",
        int connectable = 0,
        string help = "[DEPRECATED]: If you have created a series of tiled texturs using Mari, Mudbox, or ZBrush, "
                      "select the type of atlas that should be used to determine the proper "
                      "filename based on the UVs of your geometry.  See the help text for the "
                      "Filename parameter for more details on how you must specify your filename in "
                      "these cases. "
    ]],
    int invertT = 1
    [[
        string label = "Invert T",
        string widget = "checkBox",
        int connectable = 0
    ]],
    int filter = 1
    [[
        string label = "Filter",
        string widget = "mapper",
        string options = "Closest:0|Smart cubic:1|Linear:2",
        int connectable = 0,
        string help = "Choose the filter to apply to the texture as it is applied to the object."
    ]],
    float blur = 0
    [[
        string label = "Blur",
        string help = "Choose the width of the filter kernel as it is applied to the texture during "
                      "lookup. Selecting 0.0 disables the filtering.  Disabling the filter will "
                      "speed up lookup and then cause your render to rely on the mip levels and the "
                      "path tracing algorithm for averaging. "
    ]],
    color missingColor = color(1, 0, 1)
    [[
        string label = "Missing Color",
        string widget = "color",
        string help = "If you have wired resultRGB to another node in your network, and if there is "
                      "an error in loading the file, the resultRGB value will be populated with the "
                      "value that you specify here. RenderMan can fail to load a file for several "
                      "reasons, including if the filename is incorrect, or if an atlas texture is "
                      "specified, but no _MAPID_ was found in the filename. "
    ]],
    float missingAlpha = 1
    [[
        string label = "Missing Alpha",
        string widget = "default",
        string help = "If you have wired resultA to another node in your network, and if there is "
                      "an error in loading the file, the resultA value will be populated with the "
                      "value that you specify here. See the help for missingColor for the different "
                      "cases for which RenderMan may have issues loading a file. "
    ]],
    int linearize = 1
    [[
        string label = "Linearize",
        string widget = "checkBox",
        int connectable = 0,
        string help = "Apply the reverse sRGB transform your texture. If you are painting textures "
                      "in sRGB space (default for most paint packages) but viewing your data in "
                      "data linear space, your textures will look washed out. Linearize will apply the "
                      "reverse sRGB transform to your texture, which should make it appear visually linear "
                      "again. "
    ]],

    STRUCT("", Manifold, manifold, MANIFOLD_ZERO, string readOnly="True"),

    color colorScale = color(1, 1, 1)
    [[
        string page = "Adjust Output",
        int page_open = 1,
        string label = "Color Scale"
    ]],
    color colorOffset = color(0, 0, 0)
    [[
        string page = "Adjust Output",
        string label = "Color Offset"
    ]],
    float saturation = 1.0
    [[
        string page = "Adjust Output",
        string label = "Saturation",
        float min = 0,
        string widget = "number",
        float slidermax = 2
    ]],
    float alphaScale = 1
    [[
        string page = "Adjust Output",
        string label = "Alpha Scale"
    ]],
    float alphaOffset = 0
    [[
        string page = "Adjust Output",
        string label = "Alpha Offset"
    ]],
    int mipBias = 0
    [[
        string page = "Advanced Texture Settings",
        int open = 1,
        string label = "MIP bias",
        string widget = "number",
        float slider = 1,
        float slidermin = -10,
        float slidermax = 10,
        int connectable = 0,
        string help = "Offset the selected MIP level picked by the renderer. Positive values will "
                      "bias toward lower resolution MIPs. Negative values will bias toward higher "
                      "resolution MIPs. "
    ]],
    float maxResolution = 0
    [[
        string page = "Advanced Texture Settings",
        int open = 1,
        string label = "Max Resolution",
        string widget = "mapper",
        string options = "Unlimited:0|32:32|64:64|128:128|256:256|512:512|1024:1024|2048:2048|4096:4096|8192:8192",
        string help = "Clamp the resolution to a maximum value."
    ]],


    output color resultRGB = color(0),
    output float resultR = 0,
    output float resultG = 0,
    output float resultB = 0,
    output float resultA = 0,
    output vector resultNG = vector(0.0, 0.0, 0.0)
    [[
        string help = "Surface gradient from bump map.<br>resultNG (vector)"
    ]],
)
{
    ColorOpacity resultRGBA;

    int hasManifold = isconnected(manifold);
    int inInvertT = invertT;
    int acescg = 0;
    int atlas_pvr = 0;
    int errStatus = getattribute("user:ACEScg", acescg);

    string finalFilename = filename;
    if (computeMode == 1)
    {
        string txBasePath = "";
        string txLayerName = "";
        string txVersion = "";
        // getattribute("primvar", "txBasePath", txBasePath);
        // getattribute("primvar", "txLayerName", txLayerName);
        // if (!getattribute("primvar", "txVersion", txVersion))
        // {
        //     getattribute("user:txVersion", txVersion);
        // }

        // if (txBasePath)
        // {
        float txmultiUV = 0.0;
        if (getattribute("primvar", "txmultiUV", txmultiUV))
            atlas_pvr = int(round(txmultiUV));

        finalFilename = format("<primstr:txBasePath>/tex/<primstr:txVersion>/<primstr:txLayerName>_%s", txChannel);
            // if (txLayerName)
            // {
            //     // finalFilename = format("%s/tex", txBasePath);
            //     if (txVersion)
            //     {
            //         finalFilename = format("%s/<primstr:txVersion>/", finalFilename);
            //         // finalFilename = format("%s/%s", finalFilename, txVersion);
            //     }
            //     finalFilename = format("%s/<primstr:txLayerName>", finalFilename);
            //     // finalFilename = format("%s/%s", finalFilename, txLayerName);
            // }
            // else
            // {
            //     finalFilename = txBasePath;
            // }
            // if (txChannel)
            // {
            //     finalFilename = format("%s_%s", finalFilename, txChannel);
            // }

        if (txVarNum)
        {
            string txVarNumValue = "0";
            if(getattribute("primvar", "txVarNum", txVarNumValue))
            {
                if (stoi(txVarNumValue) > 0)
                {
                    // finalFilename = format("%s_%s", finalFilename, txVarNumValue);
                    finalFilename = format("%s_<primstr:txVarNum>", finalFilename);
                }
            }
        }

        if (atlas_pvr == 1){
            finalFilename = format("%s._MAPID_", finalFilename);
        }
        finalFilename = format("%s.tex", finalFilename);
        // }
        // else
        // {
        //     printf("Not found texture primvar : txBasePath");
        // }
        // printf("%s\n", finalFilename);
    }

    int atlas;
    if (atlas_pvr == 1)
        atlas = atlas_pvr;
    else
        atlas = atlasStyle;
    if (atlas > 0)
    {
        finalFilename = PxrAtlasRename(finalFilename, atlas);
    }


    float s, t;
    if (hasManifold)
    {
        // manifold input
        Manifold inputManifoldRw;
        Manifold_Copy(manifold,inputManifoldRw);

        s = inputManifoldRw.Q[0];
        t = inputManifoldRw.Q[1];
        inInvertT = 0;
    }
    else
    {
        float inManifold[2];
        if (getattribute("primvar", "st", inManifold))
        {
            s = inManifold[0];
            t = inManifold[1];
        }
        else if (getattribute("primvar", "_polygonUV", inManifold))
        {
            s = inManifold[0];
            t = inManifold[1];
        }
        else
        {
            s = u;
            t = v;
        }
    }

    TxParams txparams = initTxParams(firstChannel, blur,
                                     missingColor, missingAlpha, filter);
    TxCoords txcoords = initTxCoords(s, t, inInvertT);
    if (mipBias != 0 || maxResolution != 0)
        PxrTxMipControls(mipBias, maxResolution, txcoords, txparams);
    resultRGBA.c = PxrTextureLookup(finalFilename, txcoords, txparams);

    if (linearize)
    {
        PxrLinearizeSRGB(resultRGBA.c);

        if (acescg == 1)
        {
            matrix rec709ToACEScg = matrix(0.610277,  0.0688436, 0.0241673, 0.0,
                                            0.345424,  0.934974, 0.121814, 0.0,
                                            0.0443001, -0.00381805, 0.854019, 0.0,
                                            0.0,        0.0,        0.0,       1.0);
            resultRGBA.c = transform(rec709ToACEScg, vector(resultRGBA.c));
        }
    }


    if (isconnected(resultA))
    {
        int result = 0;
        int nchannels = 0;

        // Determine if we are 1, 2, or 3 color channel texture
        result = gettextureinfo(finalFilename, "channels", nchannels);
        if (result)
        {
            // this is based on what the studio does.
            int ofs = (nchannels == 1) ? 0 :    //   r : first chan
                      (nchannels == 2) ? 1 :    //  ra : first chan + 1
                      3;                        // rgba: first chan + 3

            txparams.firstchannel += ofs;
            resultRGBA.a = PxrTextureLookup(finalFilename, txcoords, txparams);
        }
    }

    // compute gradient from un-modified result
    if (isconnected(resultNG))
    {
        normal bumpN = normalize(
            calculatenormal(P + N * (luminance(resultRGBA.c) - 0.5)));
        resultNG = surfgradFromPerturbedNormal(bumpN, N);
    }

    resultRGBA.c = Color_Saturate(resultRGBA.c, saturation);
    resultRGB = resultRGBA.c * colorScale + colorOffset;
    resultA = resultRGBA.a * alphaScale + alphaOffset;

    // output components
    resultR = resultRGB[0];
    resultG = resultRGB[1];
    resultB = resultRGB[2];
}
