/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 1986-2021 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

color m_gain(color in, color gn)
{
    return in * gn;
}

color m_multiply(color in, color mul)
{
    return in * mul;
}

color m_gamma(color in, color gam)
{
    return gam != 1.0 ? pow(in, 1.0/gam) : in;
}

color m_saturation(color in, color sat)
{
    return sat != 1.0 ? mix(luminance(in), in, sat) : in;
}

color m_offset(color in, color ofst)
{
    return in + ofst;
}



shader DxGrade
[[
    int rfm_nodeid = 1233474,
    string rfm_classification = "rendernode/RenderMan/pattern/color",
    string rfh_classification="Pattern/Color",
    string help = "A classic color grading node."
]]
(
    color inputRGB = 0
    [[
        string label = "input Color"
    ]],

    color gainColor = color(1.0, 1.0, 1.0)
    [[
        string label = "Gain",
    ]],
    
    float multiply = 1
    [[
        string label = "Multiply",
        int slider = 1,
        float slidermax = 5.0,
        float slidermin = 0.0,
        int color_enableFilmlookVis = 0
    ]],
    
    float gamma = 1
    [[
        string label = "Gamma",
        int slider = 1,
        float slidermax = 4.0,
        float slidermin = 0.0,
        int color_enableFilmlookVis = 0
    ]],
    
    float saturation = 1
    [[
        string label = "Saturation",
        int slider = 1,
        float slidermax = 1.0,
        float slidermin = 0.0,
        int color_enableFilmlookVis = 0
    ]],
    
    float offset = 0
    [[
        string label = "Offset",
        int slider = 1,
        float slidermax = 1.0,
        float slidermin = -1.0,
        int color_enableFilmlookVis = 0
    ]],

    int clampBlack = 1
    [[
        string widget = "checkBox",
        string label = "Clamp Black",
        string page = "Clamp",
        int connectable = 0
    ]],
    int clampWhite = 0
    [[
        string widget = "checkBox",
        string label = "Clamp White",
        string page = "Clamp",
        int connectable = 0
    ]],

    output color resultRGB = 0,
    output float resultR = 0,
    output float resultG = 0,
    output float resultB = 0
)
{
    float lum = luminance(inputRGB);

    resultRGB = inputRGB;

    resultRGB = m_gain(resultRGB, gainColor);
    resultRGB = m_multiply(resultRGB, multiply);
    resultRGB = m_gamma(resultRGB, gamma);
    resultRGB = m_saturation(resultRGB, saturation);
    resultRGB = m_offset(resultRGB, offset);

    if (clampBlack) resultRGB = max(color(0), resultRGB);
    if (clampWhite) resultRGB = min(color(1), resultRGB);
    
    // output components
    resultR = resultRGB[0];
    resultG = resultRGB[1];
    resultB = resultRGB[2];    
}
