#include "stdosl.h"
#include "Manifold.h"
#include "PxrOSLTexture.h"
#include "PxrOSLColor.h"
#include "Bump.h"

struct ColorOpacity
{
    color c;
    float a;
};

shader DxTexFile
[[
    int rfm_nodeid = 3000050,
    string rfm_classification = "rendernode/RenderMan/pattern/texture",
    string rfh_classification = "Pattern/Texture",
    string help = "Read a texture file."
]]
(
    // input values
    int computeMode = 1
    [[
        string widget = "mapper",
        string options = "File:0|TxPrimVars:1",
        string label = "Process Mode",
        string help="TxPrimvars : txBasePath, txAssetName(old-stype), txLayerName, txVersion",
        int connectable = 0
    ]],

    string txChannel = ""
    [[
        string label = "Tx Channel",
        int connectable = 0,
        string conditionalVisOp="equalTo",
        string conditionalVisPath="../computeMode",
        string conditionalVisValue="1",
        string help = "1. ${txBasePath}/tex/${txVersion}/${txLayerName}<br>2. asset/${txAssetName}/texture/tex/${txVersion}/${txLayerName}"
    ]],

    int txVarNum = 1
    [[
        string label = "Enable Tx Variation",
        string widget = "checkBox",
        int connectable = 0,
        string conditionalVisOp="equalTo",
        string conditionalVisPath="../computeMode",
        string conditionalVisValue="1",
        string help = "Enable Texture Variation by txVarNum primvar"
    ]],

    string filename = ""
    [[
        string widget = "assetIdInput",
        string label = "Filename",
        string options = "texture",
        int connectable = 0,
        string conditionalVisOp="equalTo",
        string conditionalVisPath="../computeMode",
        string conditionalVisValue="0",
        string help = "To variate texture in file mode<br>please change the variation number to # on file path.<br>(eg. name_diffC_4.tex > name_diffC_#.tex)"
    ]],

    int firstChannel = 0
    [[
        string page = "Texture Parameters",
        int open = 0,
        string label = "First Channel Offset",
        int connectable = 0,
        string help = "First channel offset to be looked up for Filename."
    ]],

    int atlasStyle = 0
    [[
        string page = "Texture Parameters",
        int open = 0,
        string label = "Atlas Style",
        int connectable = 0,
        string widget = "mapper",
        string options = "None:0|UDIM (Mari):1|UV Tile Base-1 (Mudbox):2|UV Tile Base-0 (Zbrush):3",
        string help = "[DEPRECATED]: If you have created a series of tiled texturs using Mari, Mudbox, or ZBrush, select the type of atlas that should be used to determine the proper filename based on the UVs of your geometry.  See the help text for the Filename parameter for more details on how you must specify your filename in these cases. "
    ]],

    int invertT = 1
    [[
        string page = "Texture Parameters",
        int open = 0,
        string label = "Invert T",
        int connectable = 0,
        string widget = "checkBox"
    ]],

    int filter = 1
    [[
        string page = "Texture Parameters",
        int open = 0,
        string label = "Filter",
        int connectable = 0,
        string widget = "mapper",
        string options = "Closest:0|Smart cubic:1|Linear:2",
        string help = "Choose the filter to apply to the texture as it is applied to the object."
    ]],

    float blur = 0.0
    [[
        string page = "Texture Parameters",
        int open = 0,
        string label = "Blur",
    ]],

    // int lerp = 1
    // [[
    //     string page = "Texture Parameters",
    //     int open = 0,
    //     string label = "Mip Interpolate",
    //     int connectable = 0,
    //     string widget = "checkBox"
    // ]],

    color missingColor = color(1.0, 0.0, 1.0)
    [[
        string page = "Texture Parameters",
        int open = 0,
        string label = "Missing Color",
        string widget = "color",
        int connectable = 0
    ]],

    float missingAlpha = 1.0
    [[
        string page = "Texture Parameters",
        int open = 0,
        string label = "Missing Alpha",
        int connectable = 0
    ]],

    int linearize = 1
    [[
        string page = "Texture Parameters",
        int open = 0,
        string label = "Linearize",
        int connectable = 0,
        string widget = "checkBox"
    ]],

    STRUCT("Texture Parameters", Manifold, manifold, MANIFOLD_ZERO, string widget="default", string readOnly="True"),
    // struct Manifold manifold
    // [[
    //     string page = "Texture Parameters",
    //     int open = 0,
    //     string label = "Mip Interpolate",
    //     int connectable = 0,
    //     string readOnly = "True"
    // ]],

    color colorScale = color(1, 1, 1)
    [[
        string page = "Adjust Output",
        int open = 0,
        string label = "Color Scale"
    ]],

    color colorOffset = color(0.0, 0.0, 0.0)
    [[
        string page = "Adjust Output",
        int open = 0,
        string label = "Color Offset"
    ]],

    float saturation = 1.0
    [[
        string page = "Adjust Output",
        int open = 0,
        string label = "Saturation",
        string widget = "number",
        float min = 0,
        float slidermax = 2,
    ]],

    float alphaScale = 1
    [[
        string page = "Adjust Output",
        int open = 0,
        string label = "Alpha Scale"
    ]],

    float alphaOffset = 0
    [[
        string page = "Adjust Output",
        int open = 0,
        string label = "Alpha Offset",
    ]],

    int mipBias = 0
    [[
        string page = "Advanced Texture Settings",
        int open = 0,
        string label = "MIP bias",
        float slider = 1,
        float slidermin = -10,
        float slidermax = 10,
        string help = "Offset the selected MIP level picked by the renderer.<br>Positive values will bias toward lower resolution MIPs.<br>Negative values will bias toward higher resolution MIPs."
    ]],

    float maxResolution = 0
    [[
        string page = "Advanced Texture Settings",
        int open = 0,
        string label = "Max Resolution",
        string widget = "mapper",
        string options = "Unlimited:0|32:32|64:64|128:128|256:256|512:512|1024:1024|2048:2048|4096:4096|8192:8192",
        string help = "Clamp the resolution to a maximum value."
    ]],

    int optimizeIndirect = 1
    [[
        string page = "Advanced Texture Settings",
        int open = 0,
        int connectable = 0,
        string widget = "checkBox",
        string help = "Make indirect hits use a box filter rather than the selected one."
    ]],

    output color resultRGB = color(0, 0, 0),
    output float resultR = 0,
    output float resultG = 0,
    output float resultB = 0,
    output float resultA = 0,
    output vector resultNG = vector(0.0, 0.0, 0.0)
    [[
        string help = "Sutface gradient from bumb map.<br>resultNG (vector)"
    ]]
)
{
    ColorOpacity resultRGBA;

    int hasManifold = isconnected(manifold);
    int inInvertT = invertT;
    int acescg = 0;
    int atlas_pvr = 0;
    int errStatus = getattribute("user:ACEScg", acescg);

    string finalFilename = filename;
    if (computeMode == 1)
    {
        string txBasePath = "";
        string txLayerName = "";
        string txVersion = "";
        // getattribute("primvar", "txBasePath", txBasePath);
        // getattribute("primvar", "txLayerName", txLayerName);
        // if (!getattribute("primvar", "txVersion", txVersion))
        // {
        //     getattribute("user:txVersion", txVersion);
        // }

        // if (txBasePath)
        // {
        float txmultiUV = 0.0;
        if (getattribute("primvar", "txmultiUV", txmultiUV))
            atlas_pvr = int(round(txmultiUV));

        finalFilename = format("<primstr:txBasePath>/tex/<primstr:txVersion>/<primstr:txLayerName>_%s", txChannel);
            // if (txLayerName)
            // {
            //     // finalFilename = format("%s/tex", txBasePath);
            //     if (txVersion)
            //     {
            //         finalFilename = format("%s/<primstr:txVersion>/", finalFilename);
            //         // finalFilename = format("%s/%s", finalFilename, txVersion);
            //     }
            //     finalFilename = format("%s/<primstr:txLayerName>", finalFilename);
            //     // finalFilename = format("%s/%s", finalFilename, txLayerName);
            // }
            // else
            // {
            //     finalFilename = txBasePath;
            // }
            // if (txChannel)
            // {
            //     finalFilename = format("%s_%s", finalFilename, txChannel);
            // }

        if (txVarNum)
        {
            string txVarNumValue = "0";
            if(getattribute("primvar", "txVarNum", txVarNumValue))
            {
                if (stoi(txVarNumValue) > 0)
                {
                    // finalFilename = format("%s_%s", finalFilename, txVarNumValue);
                    finalFilename = format("%s_<primstr:txVarNum>", finalFilename);
                }
            }
        }

        if (atlas_pvr == 1){
            finalFilename = format("%s._MAPID_", finalFilename);
        }
        finalFilename = format("%s.tex", finalFilename);
        // }
        // else
        // {
        //     printf("Not found texture primvar : txBasePath");
        // }
        // printf("%s\n", finalFilename);
    }

    int atlas;
    if (atlas_pvr == 1)
        atlas = atlas_pvr;
    else
        atlas = atlasStyle;
    if (atlas > 0)
    {
        finalFilename = PxrAtlasRename(finalFilename, atlas);
    }

    float s, t;
    if (hasManifold)
    {
        // maniold input
        Manifold inputManifoldRw;
        Manifold_Copy(manifold, inputManifoldRw);

        s = inputManifoldRw.Q[0];
        t = inputManifoldRw.Q[1];
        inInvertT = 0;
    }
    else
    {
        float inManifold[2];
        if (getattribute("primvar", "st", inManifold))
        {
            s = inManifold[0];
            t = inManifold[1];
        }
        else if (getattribute("primvar", "_polygonUV", inManifold))
        {
            s = inManifold[0];
            t = inManifold[1];
        }
        else
        {
            s = u;
            t = v;
        }
    }

    TxParams txparams = initTxParams(firstChannel, blur,
                                         missingColor, missingAlpha, filter);
    TxCoords txcoords = initTxCoords(s, t, inInvertT);
    if (mipBias != 0 || maxResolution != 0)
        PxrTxMipControls(mipBias, maxResolution, txcoords);
    resultRGBA.c = PxrTextureLookup(finalFilename, txcoords, txparams);

    if (linearize)
    {
        PxrLinearizeSRGB(resultRGBA.c);

        if (acescg == 1)
        {
            matrix rec709ToACEScg = matrix(0.610277,  0.0688436, 0.0241673, 0.0,
                                            0.345424,  0.934974, 0.121814, 0.0,
                                            0.0443001, -0.00381805, 0.854019, 0.0,
                                            0.0,        0.0,        0.0,       1.0);
            resultRGBA.c = transform(rec709ToACEScg, vector(resultRGBA.c));
        }
    }

    if (isconnected(resultA))
    {
        int result = 0;
        int nchannels = 0;

        // Determine if we are 1, 2, or 3 color channel texture
        result = gettextureinfo(finalFilename, "channels", nchannels);
        if (result)
        {
            // this is based on what the studio does.
            int ofs = (nchannels == 1) ? 0 :    //   r : first chan
                      (nchannels == 2) ? 1 :    //  ra : first chan + 1
                      3;                        // rgba: first chan + 3

            txparams.firstchannel += ofs;
            resultRGBA.a = PxrTextureLookup(finalFilename, txcoords, txparams);
        }
    }

    // compute gradient from un-modified result
    if (isconnected(resultNG))
    {
        normal bumpN = normalize(
            calculatenormal(P + N * (luminance(resultRGBA.c) - 0.5)));
        resultNG = surfgradFromPerturbedNormal(bumpN, N);
    }

    resultRGBA.c = Color_Saturate(resultRGBA.c, saturation);
    resultRGB = resultRGBA.c * colorScale + colorOffset;
    resultA = resultRGBA.a * alphaScale + alphaOffset;

    // output components
    resultR = resultRGB[0];
    resultG = resultRGB[1];
    resultB = resultRGB[2];
}
