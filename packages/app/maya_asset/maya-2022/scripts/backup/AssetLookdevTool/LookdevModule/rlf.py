# ------------------------------------------------------------------------------
#
# Copyright (c) 2012 Pixar Animation Studios. All rights reserved.
#
# The information in this file (the "Software") is provided for the
# exclusive use of the software licensees of Pixar.  Licensees have
# the right to incorporate the Software into other products for use
# by other authorized software licensees of Pixar, without fee.
# Except as expressly permitted herein, the Software may not be
# disclosed to third parties, copied or duplicated in any form, in
# whole or in part, without the prior written permission of
# Pixar Animation Studios.
#
# The copyright notices in the Software and this entire statement,
# including the above license grant, this restriction and the
# following disclaimer, must be included in all copies of the
# Software, in whole or in part, and all permitted derivative works of
# the Software, unless such copies or derivative works are solely
# in the form of machine-executable object code generated by a
# source language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------


import json
import xml.dom.minidom


RLFMatchType = {0:0, "glob":0, "re":1 , 1:1, "exact":2, 2:2, "xpath":3, 3:3} 
RLFMatchPhase =    {0:0,"inject":0, 1:1,"edit":1} 
RLFPayloadType = {0:0, "inject":0, 1:1, "edit":1}
RLFFlowType = {0:0, "break":0, 1:1, "continue":1}

class RLFScope:
    '''
        This file is provided to provide easy access to the RenderMan
        Look Files. This could either be run from inside Maya to 
        manipulate the scene's rlf data or loading and storing rlf's
        to disk for rendering in a standalone .
        
        These classes make it possible to query and update the Look File
        but don't provide access to the execution of rules (xpath) or
        interaction with RenderMan for Maya.
        
        Usage:
        
        import rlf

        scope = rlf.RLFScope()
        scope.LoadRlf("perspShape_Final.0001.orig.rlf")
        dynRules = scope.GetRules()

        for rule in dynRules[0]:
            print "processing rule " + rule.GetRuleString()

            if "nurbsSpere2" in rule.GetRuleString():
                static.AddRule(rule)

        serial = static.Serialize()
        f = open("perspShape_Final.0001.rlf", "w")
        f.write(serial)
        f.close()
    '''


    def __init__(self):
        self.m_header = { "Format"           : "RenderMan Look Data",
                          "Version"          : 1,
                          "AssemblyName"    : "",
                          "UserDescription" : "",
                          "ReferenceURL"    : ""} 
                          
        #has a list of RLFRule (for injections & edits) 
        self.m_dynamicRules = []

        #has a dictionary of RLFPayload (for static injections)
        self.m_staticBindings = {}

        #has a dictionary of RLFPayload (for static edits)
        self.m_staticEdits = {}

        #has a map of payload references m_payloadMap
        self.m_editPayloadMap = {}
        self.m_injectPayloadMap = {}

    def GetHeader(self):
        """return the header dictionary"""
        return self.m_header
    def GetHeaderValue(self,key):
        """return a specified entry from the m_header dictionary"""
        if(self.m_header.has_key(key)):
            return self.m_header[key]
        else:
            return None
    def SetHeader(self,headerDict):
        """Override the header dictionary"""
        self.m_header = headerDict

    def SetHeaderValue(self,key,value):
        """Set a specific header value"""
        if(self.m_header.has_key(key)):
            self.m_header[key] = value
        else:
            raise Exeception("Invalid rlf header key: " + key)
 
    def CreatePayload(self, Id, Type, Value):
        """Create a new payload"""
        newPayload = RLFPayload(Id,Type,Value)
        if(Type == RLFPayloadType["edit"] or Type == "edit"):
            self.m_editPayloadMap[Id] = Value
        elif(Type == RLFPayloadType["inject"] or Type == "inject"):
            self.m_injectPayloadMap[Id] = Value
        return newPayload

    def RemovePayload(self, payloadId):
        """delete a payload associate with the specified payloadID"""
        if self.m_editPayloadMap.has_key(payloadId):
            del(self.m_editPayloadMap[payloadId])
        if self.m_injectPayloadMap.has_key(payloadId):
            del(self.m_injectPayloadMap[payloadId])

    def GetEditPayloads(self):
        """returns the dictionary of id's to edit payloads"""
        return self.m_editPayloadMap;

    def GetInjectionPayloads(self):
        """returns the dictionary of id's to injection payloads"""
        return self.m_injectPayloadMap;

    def SetEditPayloads(self, payloads):
        self.m_editPayloadMap = payloads;

    def SetInjectionPayloads(self, payloads):
        """sets the dictionary of id's to injection payloads"""
        self.m_injectPayloadMap = payloads;

    def AddRule(self,rlfRule):
        """Add the RLFRule to the end of the internal dynamic rules list"""
        self.m_dynamicRules.append(rlfRule)

    def GetRule(self,index):
        """Return the RLFRule object from the specified index in the dynamic
        rules list"""
        try:
            return self.m_dynamicRules[index]
        except:
            return None

    def GetRules(self):
        """Return the list of rules"""
        return self.m_dynamicRules 

    def InsertRule(self,index,rlfRule):
        """Insert the passed rule into the index position of internal dynamic
        rules list"""
        self.m_dynamicRules.insert(index,rlfRule)

    def DeleteRuleAtIndex(self,index):
        """delete the specified rule from the dynamic rules list"""
        if(index <= len(self.m_dynamicRules)):
            del(self.m_dynamicRules[index])
        else:
            raise Exception("index out of bounds of rulelist" +str(index)) 

    def DeleteRule(self,rlfRule):
        """delete the specified rule from the dynamic rules list"""
        try:
            self.m_dynamicRules.remove(rlfRule)
        except ValueError:
            raise Exception("rlf rule not found in list " +str(rlfRule))

    def ReplaceRule(self,index,rlfrule):
        """replace the specified rule in the dynamic rules list"""
        if(index <= len(self.m_dynamicRules)):
            self.m_dynamicRules[index] = rlfrule
        else:
            raise Exception("index out of bounds of rule list")
    
    def AddStaticEdit(self, attrIdPath, payloadId):
        self.m_staticEdits[attrIdPath] = payloadId
        
    def DeleteStaticEdit(self, attrIdPath):
        if self.m_staticEdits.has_key(attrIdPath):
            del(self.m_staticEdits[attrIdPath])
        
    def FindStaticEditPayload(self, attrIdPath):
        """if there is a static edit for the aip then return the
           the RLFPayload for it, otherwise return None"""
        if not self.m_staticEdits.has_key(attrIdPath):
            return None

        id = self.m_staticEdits[attrIdPath]
        if not self.m_editPayloadMap.has_key(id):
            return None

        return self.m_editPayloadMap[id]

    def GetStaticBindings(self):
        """Return the static binding dictionary"""
        return self.m_staticBindings

    def AddStaticBinding(self, attrIdPath, payloadId):
        self.m_staticBindings[attrIdPath] = payloadId
        
    def DeleteStaticBinding(self, attrIdPath):
        if self.m_staticBindings.has_key(attrIdPath):
            del(self.m_staticBindings[attrIdPath])
        
    def FindStaticBindingPayload(self, attrIdPath):
        """if there is a static binding for the aip then return the
           the RLFPayload for it, otherwise return None"""
        if not self.m_staticBindings.has_key(attrIdPath):
            return None

        id = self.m_staticBindings[attrIdPath]
        if not self.m_injectPayloadMap.has_key(id):
            return None

        return self.m_injectPayloadMap[id]

    def Serialize(self, format='XML'):
        """
        Return a string or dictionary representation of the scope.
        format can be 'XML' (the default) or 'JSON'
            scopedict = scope.Serialize(asString=False)
            scopestring = scope.Serialize()
            
        See ExternalRepr()
        """
        if format == 'XML':
            doc = self.ExternalRepr(format);
            return doc.toxml('utf-8')
        else:
            rlfdict = self.ExternalRepr('JSON')
            return json.dumps(rlfdict, ensure_ascii=True, indent=None)
            
    def ExternalRepr(self, format='XML'):
        """
        Return an external representation of the scope either as an XML
        DOM (from xml.dom.minidom) or a python dictionary suitable to hand
        to json.dumps()
        """
        if format == 'XML':
            return self.toDOM()
        else:
            return self.toDict()
            
    def toDOM(self):
        impl = xml.dom.minidom.getDOMImplementation()
        doc = impl.createDocument(None, "RenderManLookFile", None)
        
        self.addHeader(doc)
        self.addRuleSet(doc)
        self.addInjectablePayloads(doc)
        self.addEditPayloads(doc)
        self.addTightBindings(doc)
        self.addStaticEdit(doc)
        return doc
        
    def addHeader(self, doc):
        top = doc.documentElement
        for nm in [ "Format", "Version", "AssemblyName", 
                            "UserDescription", "ReferenceURL" ]:
            top.setAttribute(nm, str(self.m_header[nm]))

    def addRuleSet(self, doc):
        if len(self.m_dynamicRules) == 0:
            return

        top = doc.documentElement
        ruleSet = doc.createElement('RuleSet')
        top.appendChild(ruleSet)

        for rule in self.m_dynamicRules:
            r = doc.createElement('Rule')
            ruleSet.appendChild(r)
            for key in ["MatchPhase", "MatchMethod", "FlowControl"]:
                r.setAttribute(key, str(rule.GetDict()[key]))
            id = rule.GetPayloadId()
            if id != None:
                r.setAttribute('Id', id)
            cd = doc.createCDATASection(rule.GetDict()['Rule'])
            r.appendChild(cd)
            self.addUserData(doc, rule, r)

    def addUserData(self, doc, rule, node):
        user = rule.GetUserDataDict()
        if user == None or len(user) == 0:
            return
        
        ud = doc.createElement('UserData')
        node.appendChild(ud)
        for k,v in user.iteritems():
            datum = doc.createElement('UserDatum')
            ud.appendChild(datum)
            datum.setAttribute('Key', k)
            cd = doc.createCDATASection(str(v))
            datum.appendChild(cd)
          
    def addInjectablePayloads(self, doc):
        top = doc.documentElement
        inode = doc.createElement('InjectablePayloads')
        top.appendChild(inode)
        
        for id,val in self.m_injectPayloadMap.iteritems():
            pnode = doc.createElement('Payload')
            pnode.setAttribute('Id', str(id))
            inode.appendChild(pnode)
            for n in ['Source', 'Content', 'Label']:
                pnode.setAttribute(n, str(val[n]))
            cd = doc.createCDATASection(val['Payload'])
            pnode.appendChild(cd)

    def addEditPayloads(self, doc):
        top = doc.documentElement
        enode = doc.createElement('EditPayloads')
        top.appendChild(enode)
        
        for id,val in self.m_editPayloadMap.iteritems():
            if type(val) is dict:
                self.addParameterList(doc, enode, id, val)
            else:
                self.addParameterValue(doc, enode, id, val)

    def addParameterList(self, doc, epayloads, id, plist):
        pnode = doc.createElement('ParameterList')
        epayloads.appendChild(pnode)
        pnode.setAttribute('Id', id)
        for k,v in plist.iteritems():
            self.addParameterValue(doc, pnode, k, v)

    def addParameterValue(self, doc, parent, id, value):
        vnode = doc.createElement('ParameterValue')
        parent.appendChild(vnode)
        vnode.setAttribute('Id', id)
        cd = doc.createCDATASection(value)
        vnode.appendChild(cd)

    def addTightBindings(self, doc):
        if len(self.m_staticBindings) == 0:
            return
        top = doc.documentElement
        tb = doc.createElement('TightBindings')
        top.appendChild(tb)
        
        for k,v in self.m_staticBindings.iteritems():
            b = doc.createElement('Binding')
            tb.appendChild(b)
            b.setAttribute('Key', k)
            b.setAttribute('PayloadId',v)
            
    
    def addStaticEdit(self, doc):
        if len(self.m_staticEdits) == 0:
            return
        top = doc.documentElement
        se = doc.createElement('StaticEdits')
        top.appendChild(se)
        
        for k,v in self.m_staticEdits.iteritems():
            e = doc.createElement('Edit')
            se.appendChild(e)
            e.setAttribute('Key', k)
            e.setAttribute('PayloadId',v)

    def toDict(self):
        """
        Return a dictionary representation of the scope.
        """
        #Create a new dictionary with all of the data for the json file
        rlf = {}

        #add the header
        rlf.update(self.m_header)

        #add the rules
        tmpRuleList = []
        for it in self.m_dynamicRules:
            tmpRuleList.append(it.GetDict())
            #Update the payloads in the local payload dict
            try:
                if(it.GetMatchPhase() == RLFMatchPhase["inject"]):
                    self.m_injectPayloadMap[it.GetPayloadId()] = \
                            it.GetPayload().GetData()
                else:
                    self.m_editPayloadMap[it.GetPayloadId()] = \
                            it.GetPayload().GetData()
            except AttributeError:
                #The rule has no payload
                pass

        if len(tmpRuleList) > 0:
            rlf["RuleSet"] = tmpRuleList

        #add the payloads
        if len(self.m_injectPayloadMap) > 0:
            rlf["InjectablePayloads"] = self.m_injectPayloadMap

        if len(self.m_editPayloadMap) > 0:
            rlf["EditPayloads"] = self.m_editPayloadMap

        #add the static bindings
        if len(self.m_staticBindings) > 0:
            rlf["TightBinding"] = self.m_staticBindings

        #add the static edits
        if len(self.m_staticEdits) > 0:
            rlf["StaticEdits"] = self.m_staticEdits

        return rlf

    def LoadRlf(self, filename):
        """reconstitute a rlfScope object from a rlf json representation
           on disk"""
    
        #open the file an load the data using the json module
        fh = open(filename)
        serializedRlf = fh.read()
        fh.close()
        self.Deserialize(serializedRlf)
        return

    def Deserialize(self, serializedRlf):
        '''initialized from a serialized json or xml string'''
        if serializedRlf[0:5] == '<?xml':
            self.deserializeXML(serializedRlf)
        else:
            self.deserializeJSON(serializedRlf)

    def deserializeXML(self, serializedRlf):
        doc = xml.dom.minidom.parseString(serializedRlf)
        top = doc.childNodes[0]
        if top.nodeName != 'RenderManLookFile':
            raise Exception("Passed an xml file that wasn't an RLF")
            
        self.deserializeHeader(top)
        
        for node in top.getElementsByTagName('Payload'):
            self.deserializeInjectable(node)

        for node in top.getElementsByTagName('EditPayloads'):
            self.deserializeEditPayloads(node)

        # after we've loaded the payloads since we need the actual payloads
        for node in top.getElementsByTagName('RuleSet'):
            self.deserializeRuleSet(node)

        for node in top.getElementsByTagName('Binding'):
            self.deserializeBinding(node)

        for node in top.getElementsByTagName('Edit'):
            self.deserializeEditMappings(node)

    def deserializeHeader(self, top):
        for key in self.m_header.keys():
            if top.attributes.has_key(key):
                self.m_header[key] = top.attributes[key].nodeValue

    def deserializeBinding(self, node):
        a = node.attributes
        self.m_staticBindings[a["Key"].nodeValue] = a["PayloadId"].nodeValue

    def deserializeEditMappings(self, node):
        a = node.attributes
        self.m_staticEdits[a["Key"].nodeValue] = a["PayloadId"].nodeValue

    def deserializeInjectable(self, node):
        payload = dict()
        id = node.attributes["Id"].nodeValue
        for key in node.attributes.keys():
            attr = node.attributes[key]
            if key != "Id":
                payload[key] = attr.nodeValue
        payload['Payload'] = self.cdata(node)
        self.m_injectPayloadMap[id] = payload

    def deserializeEditPayloads(self, editPayloads):
        for node in editPayloads.childNodes:
            if node.nodeName == 'ParameterValue':
                id = node.attributes["Id"].nodeValue
                payload = self.cdata(node)
            elif node.nodeName == 'ParameterList':
                id = node.attributes["Id"].nodeValue
                payload = dict()
                for pv in node.getElementsByTagName('ParameterValue'):
                    pName = pv.attributes["Id"].nodeValue
                    value = self.cdata(pv)
                    payload[pName] = value
            else:
                continue # text nodes...
            self.m_editPayloadMap[id] = payload
            
    def deserializeRuleSet(self, ruleSet):
        # rulesets are ordered.
        for node in ruleSet.childNodes:
            if node.nodeName != 'Rule':
                continue # text node?
            id = node.attributes["Id"].nodeValue
            phase = int(node.attributes["MatchPhase"].nodeValue)
            method = int(node.attributes["MatchMethod"].nodeValue)
            flow = int(node.attributes["FlowControl"].nodeValue)
            userdata = dict()
            for ud in node.getElementsByTagName('UserDatum'):
                userdata[ud.attributes["Key"].nodeValue] = self.cdata(ud)
            rulestring = self.cdata(node)
            
            try:
                if phase == RLFMatchPhase["edit"]:
                    payload = self.m_editPayloadMap[id]
                    pObj = RLFPayload(payloadid=id, payloadtype="edit", 
                                    payload=payload)
                else:
                    payload = self.m_injectPayloadMap[id]
                    pObj = RLFPayload(payloadid=id, payloadtype="inject", 
                                    payload=payload)
            except KeyError:
                    pObj = None 
            rule = NewRlfRule(phase, method, rulestring, flow, payload=pObj)
            rule.SetUserDataDict(userdata)
            self.m_dynamicRules.append(rule)

    def cdata(self, node):
        return ''.join([d.nodeValue for d in node.childNodes \
                                        if d.nodeType == d.CDATA_SECTION_NODE])

    def deserializeJSON(self, serializedRlf):
        '''initialized from a serialized json string'''
        
        rlfData = json.loads(serializedRlf)
        #Read populate the header dict
        for it in self.m_header.keys():
            try:
                self.m_header[it] = rlfData[it]
            except KeyError:
                pass

        if rlfData.has_key("TightBinding"):
            # populate the staticBindings
            self.m_staticBindings = rlfData["TightBinding"]

        if rlfData.has_key("InjectablePayloads"):
            #populate the payload map
            self.m_injectPayloadMap = rlfData["InjectablePayloads"]

        if rlfData.has_key("EditPayloads"):
            self.m_editPayloadMap = rlfData["EditPayloads"]

        if rlfData.has_key("StaticEdits"):
            self.m_staticEdits = rlfData["StaticEdits"]

        if not rlfData.has_key('RuleSet'):
            return
        #populate the dynamic rules
        for rule in rlfData["RuleSet"]:
            # accept rules that don't have a payload
            id = rule["Id"]
            phase = rule["MatchPhase"]
            try:
                if phase == RLFMatchPhase["inject"]:
                    p = RLFPayload(id, phase, self.m_injectPayloadMap[id])
                else:
                    p = RLFPayload(id, phase, self.m_editPayloadMap[id])
            except KeyError:
                p = None
            self.m_dynamicRules.append(RLFRule(rule, p))



class RLFPayload:
    def __init__(self,payloadid="", payloadtype = "edit", payload=""):
        """initializer for the payload data structure
            id          - a unique string
            payloadtype - 'inject' or 'edit'
            payload     - RIB (inject) or RIB parameter dict (edit)
        """
        self.m_payloadID = payloadid 
        self.m_payloadData = payload
        try:
            self.m_payloadType = RLFPayloadType[payloadtype]
        except KeyError:
            raise Exception("invalid payload type: " + str(payloadtype))

    def GetID(self):
        """Return the payload ID"""
        return self.m_payloadID

    def SetID(self,value):
        """Set the payload ID"""
        self.m_payloadID = value

    def GetData(self):
        """return the payload data"""
        return self.m_payloadData

    def SetData(self,value):
        """set the payload data"""
        self.m_payloadData = value

    def GetType(self):
        """return the type of the payload, it can be either and edit or inject
        payload"""
        return self.m_payloadType

    def SetType(self,value):
        """Sets the type of the payload it can be either edit or inject"""
        if RLFPayloadType.has_key(value):
            self.m_payloadType = RLFPayloadType[value] 
        else:
            raise Exception("Invalid payload type: ", str(value))
            
    def GetDict(self):
        """returns a dictionary entry for the payload map"""
        return {self.m_payloadID:self.m_payloadData}

class PhaseMismatch(Exception):
    def __init__(self,value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class RLFRule:
    def __init__(self,valueDict=None,payload=None):
        self.m_dict = {}
        if(valueDict):
            self.m_dict = valueDict

        self.SetPayload(payload)

    def GetMatchPhase(self):
        """get the type of the rule, edit or inject"""
        try:
            return self.m_dict["MatchPhase"]
        except KeyError:
            raise Exception("(RLFRule GetMactchPhase) no match phase")

    def __setMatchPhase(self,Type):
        """set the type of the rule, edit or inject"""
        if(RLFMatchPhase.has_key(Type)):
            self.m_dict["MatchPhase"] = RLFMatchPhase[Type]
        else:
            raise Exception("(RLFRule:__setMatchPhase) Invalid MatchPhase")

    def GetMatchType(self):
        """get the match type of the rule, glob xpath re etc..."""
        return self.m_dict["MatchMethod"]

    def SetMatchType(self,matchtype):
        """set the match type of the rule, glob xpath re etc..."""
        if(RLFMatchType.has_key(matchtype)):
            self.m_dict["MatchMethod"]= RLFMatchType[matchtype]
        else:
            raise Exception("(RLFRule:SetMatchType) Invalid MatchPhase")

    def GetRuleString(self):
        """get the rule string"""
        return self.m_dict["Rule"]
   
    def SetRuleString(self,value):
        """set the rule string"""
        self.m_dict["Rule"] = value

    def SetFlowControl(self,value):
        """set the continuation behavior of the rule""" 
        try:
            self.m_dict["FlowControl"] = RLFFlowType[value] 
        except KeyError:
            raise Exception("(RLFScope->SetFlowControl) Invalid key")

    def GetUserData(self,key):
        """Get the user data for the given key"""
        return self.m_dict["UserData"][key]
   
    def SetUserData(self,key,value):
        """add/set the user data for the given key"""
        if (not self.m_dict.has_key("UserData")):
            self.m_dict["UserData"] = {}
        self.m_dict["UserData"][key] = value
   
    def SetUserDataDict(self, d):
        self.m_dict["UserData"] = d
        
    def GetUserDataDict(self):
        try:
            return self.m_dict["UserData"]
        except KeyError:
            return None
        
    def GetPayload(self):
        """Get the RLF payload object for the rule"""
        return self.m_payload
            
    def SetUserDataDict(self, d):
        self.m_dict["UserData"] = d
                    
    def SetPayload(self,rlfPayload):
        """set the RLF payload object for the rule"""
        if not rlfPayload:
            self.m_payload = None
            return
            
        if(rlfPayload.GetType() == self.GetMatchPhase()):
            self.m_payload = rlfPayload
            self.m_dict["Id"] = self.GetPayloadId()
        else:
            pid = rlfPayload.GetID()
            raise PhaseMismatch(
            "Payload type doesn'tmatch the RLFRule's match-phase" +
            "rule = " + str(self.m_dict) + 
            "\n payload match-phase=" + str(rlfPayload.GetType()) +
            " payload id= " + str(pid))


    def GetPayloadId(self):
        """returns the payload id"""
        if self.m_payload:
            return self.m_payload.GetID()
        else:
            return None 

    def GetDict(self):
        """Returns the dictionary of rule data"""
        return self.m_dict

    def Initialize(self, matchphase, matchtype, rulestring,
             flowcontrol, payload=None):
        self.__setMatchPhase(matchphase)
        self.SetMatchType(matchtype)
        self.SetRuleString(rulestring)
        self.SetFlowControl(flowcontrol)
        self.SetPayload(payload);

def NewRlfRule(matchphase, matchtype, rulestring,
         flowcontrol, payload=None):
    """Return a new RLFRule object given the inputs
        matchphase - any of RLFMatchPhase.keys()"""
    newRlf = RLFRule()
    newRlf.Initialize( matchphase, matchtype, rulestring,
         flowcontrol, payload)

    return newRlf


# Test out the RLF manipulating ability of the module
if __name__ == '__main__':

    for filename in ['unit_json.rlf', 'unit_xml.rlf']:
        rlfScope = RLFScope()
        # load up a test rlf file 
        rlfScope.LoadRlf(filename)
        
        # add a index to the user data of all rules in the 
        # dynamic rules list
        count = 0
        for x in rlfScope.GetRules():
            x.SetUserData("index",count)
            count +=1
            print "rule " + x.GetRuleString()
            if x.GetPayloadId():
                print "id: " + x.GetPayloadId()
                print "payload: " + str(x.GetPayload().GetData())
            else:
                print "no payload"
    
        n = len(rlfScope.GetRules())
        print "There are:", n, " rules in the list"
        # Test the delete mechanism
        rlfScope.DeleteRuleAtIndex(-1)
        n = len(rlfScope.GetRules())
        print "There are now :", n," rules in the list"

        path = '/blinn/foo'
        k_PayloadID = '3242323'
        rlfScope.AddStaticEdit(path + "/RiSurface", k_PayloadID)
        
        encodedString = rlfScope.Serialize()
        
        f = open('new_' + filename, 'w')
        f.write(encodedString)
        f.close()
        print 'done with ' + filename