
proc float UIToCm( float $value )
{
  float $scale = 1.0;
  string $UIUnits = `currentUnit -q -l`;

  switch ( $UIUnits )
  {
      case "mi":
          $scale = 160934.40;
          break;
      case "mm":
          $scale = 0.10;
          break;
      case "km":
          $scale = 100000.0;
          break;
      case "m":
          $scale = 100.0;
          break;
      case "yd":
          $scale = 91.440;
          break;
      case "in":
          $scale = 2.540;
          break;
      case "ft":
          $scale = 30.480;
          break;
	  default:
		$scale = 1.0;
  }

  $value *= $scale;

  return $value;
}

global proc setPdiDynamicType()
{
	global string $pdiRBDactivationCollection;
   	global string $pdiRBDA[3];
    global string $comboDynamicType;   
    global int $pdiUpdate;
         
	int $value = `optionMenu -query -select $comboDynamicType`;

	$pdiUpdate = 1;//enable update			
    
	if( $value == 3)
	{
		//kinematic
		createPDIAutoBody();		
	}    
	else
	if( $value == 2)
	{
		//static
		createPDIAutoBody();		
	}
	else
	{
		//dynamic
		string  $PDIObjects[];
		$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;
		for ( $obj in $PDIObjects )
		{
	        $connections = `listConnections -d off -s on ($obj +".fracture")`;
	        if( size($connections)==0 )
		    {
			   // is a single rigid body

			setAttr ($obj + ".firstHitActive" ) 0;
			setAttr ($obj + ".usercommand" ) true;

			//force update
			getAttr ($obj + ".ca_activeState" );        
		}
		}

		createPDIAutoBody();		
		//disable first hit
		radioCollection -edit -select $pdiRBDA[0] $pdiRBDactivationCollection;	    		
	}	
}
global proc pdiUI_createRigidBody(int $dynamic_type, int $boundingVolumeType)
{
	$selection = `ls -selection -type transform`;

    if( size($selection) == 0)
    {
	    //in case selection are directly pdi rigid bodies
		string $PDIbodies[] = `ls -selection -dag -leaf -type pdiRigidBody`;
	    if( size( $PDIbodies) > 0)
		{
		    for($obj in $PDIbodies)
			{
				string $transformNode[]=`listRelatives -p $obj`;
				string $shapes[]=`listRelatives -path -ni -typ "mesh" $transformNode[0]`;
                if( size($shapes) > 0)			    
				$selection[size($selection)]=$shapes[0];
			}		    
		}
		else
		{
		    //in case selection are shapes
			string $shapes[] = `ls -selection -dag -leaf -ni -type "mesh"`;
			if( size( $shapes) > 0)
			{
				$selection=$shapes;
			}
		}
	}
	else
	{
		//select visible shapes nodes
			string  $selection2[];        
		    for($obj in $selection)
			{
			    string $shapes[]=`listRelatives -path -ni -typ "mesh" $obj`;
                if( size($shapes) > 0)		
				{
					int $shapeIsVisible = `getAttr ( $shapes[0] + ".visibility" )`;
					if( $shapeIsVisible)
					{			    
						$selection2[size($selection2)]=$shapes[0];
					}
				}
            }        
            $selection = $selection2;   
			if(size($selection) == 0)
			{
			   //select childs shapes in case it is a shatter group
				string $transformNode[] = `ls -selection -type transform`;
				if( size( $transformNode) == 1)//only one transform node selected
				{
					string $voronoiNodes[] = `ls -selection -dag -type "pdiVoronoiNode"`;
					if( size( $voronoiNodes) > 0)
					{
						for($obj in $voronoiNodes)
						{
    						$transformVoroNode=`listRelatives -p $obj`;
	    					$ShatterVoroGroup=`listRelatives -p $transformVoroNode`;
							if( size(  $ShatterVoroGroup) > 0 &&  $ShatterVoroGroup[0]==$transformNode[0])
							{ 
								string $childmeshes[] =`ls -selection -dag -ni -type "mesh"`;	
								//select visible shapes only
								for($shape in $childmeshes)
								{
									int $shapeIsVisible = `getAttr ( $shape + ".visibility" )`;
									if( $shapeIsVisible)
									{
										$selection[size($selection)]=$shape;
									}
								}
								break;
							}
						}
					}
				}
			}								 
	}

    if( size($selection) > 0)
    {    
	    string $result[];

		int $nselected = size($selection);
		//print ("\n" + $nselected + " shapes: " + $selection[0]);

	    //create pdiSolver node if necessary
		pdiSolver;
    
        waitCursor -state on;

//		print( " execute new_PDIBody\n");

        $result=`new_PDIBody -a ($dynamic_type-1) -st $boundingVolumeType $selection`;

	    if( size( $result) > 0)
		{
			//select the rigid body just created
			select  $result;
		}

        waitCursor -state off;

		updatePdiPropertiesPanel();
    }
    else
	{
	    warning -noContext "Pdi Info: select a a polygonal object first";			
	}	 
}
global proc createPDICapsuleBody()
{
    global string $ChkPdiPassive;
    global string $comboDynamicType;        
    global int $pdiUpdate;

	if( $pdiUpdate==0)
	{
		return;	
	}	
	
//    $state = `checkBox -query -value $ChkPdiPassive`;
	int $dynamic_type = `optionMenu -query -select $comboDynamicType`;
    if( $dynamic_type==4)$dynamic_type=1;
    
	pdiUI_createRigidBody( $dynamic_type, 1);

	updatePdiBodyPanel();

}
global proc createPDIVoidBody()
{
    global string $ChkPdiPassive;
    global string $comboDynamicType;            
    global int $pdiUpdate;

	if( $pdiUpdate==0)
	{
		return;	
	}	
	
//    $state = `checkBox -query -value $ChkPdiPassive`;   
    int $dynamic_type = `optionMenu -query -select $comboDynamicType`;
    if( $dynamic_type==4)$dynamic_type=1;
    
    pdiUI_createRigidBody( $dynamic_type, 0);

	updatePdiBodyPanel();

}

global proc createPDIHullBody()
{
    global string $ChkPdiPassive;
    global string $comboDynamicType;            
    global int $pdiUpdate;

	if( $pdiUpdate==0)
	{
		return;	
	}	
	
//    $state = `checkBox -query -value $ChkPdiPassive`;
    int $dynamic_type = `optionMenu -query -select $comboDynamicType`;
    if( $dynamic_type==4)$dynamic_type=1;
    
	pdiUI_createRigidBody( $dynamic_type, 2);

	updatePdiBodyPanel();

}
global proc createPDIMeshBody()
{
    global string $ChkPdiPassive;
    global string $comboDynamicType;            
    global int $pdiUpdate;
	if( $pdiUpdate==0)
	{
		return;	
	}	

//    $state = `checkBox -query -value $ChkPdiPassive`;
    int $dynamic_type = `optionMenu -query -select $comboDynamicType`;
    if( $dynamic_type==4)$dynamic_type=1;
    
	pdiUI_createRigidBody( $dynamic_type, 3);

	updatePdiBodyPanel();

}
global proc createPDIAutoBody()
{
    global string $ChkPdiPassive;
    global string $comboDynamicType;            
    global int $pdiUpdate;

	if( $pdiUpdate==0)
	{
//		print( "$pdiUpdate==0\n");
		return;	
	}	
	
    int $dynamic_type = `optionMenu -query -select $comboDynamicType`;
    
    if( $dynamic_type==4)$dynamic_type=1;
    
	pdiUI_createRigidBody( $dynamic_type, 4);
	updatePdiBodyPanel();
}

global proc setPptyAnimated()
{
    global string $chkPdiAnimated;
    global string $ChkPdiPassive;
    
    global int $pdiUpdate;
	if( $pdiUpdate==0)
	{
		return;	
	}
		
    $state = `checkBox -query -value $chkPdiAnimated`;
				
	string  $PDIObjects[];
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;
	for ( $obj in $PDIObjects )
	{
	    $connections = `listConnections -d off -s on ($obj +".fracture")`;
	    if( size($connections)!=0 )
		{
			// it is a fragment
			continue;
		}

		string  $PDIShapes[];
		$PDIShapes = `listConnections -type pdiCollisionShape $obj`;
		if( size($PDIShapes) > 0)
		{		
			setAttr ($PDIShapes[0] + ".animated(Mesh)" ) $state;

			if( $state==true)
			{		
				//animated meshes are always kinematic
				setAttr ($obj + ".passive" ) 2;
			}

            //force update 
			getAttr ($PDIShapes[0] + ".collisionShapeParam" );            
			getAttr ($PDIShapes[0] + ".outCollisionType" );            
			getAttr ($PDIShapes[0] + ".ca_collisionShape" );    
			getAttr ($obj + ".ca_rigidBody" );    
	        getAttr ($obj + ".ca_activeState" );
		}			
	}

}
global proc setPptyFlipSide()
{
    global string $chkPdiFlipNormals;
    
    global int $pdiUpdate;
	if( $pdiUpdate==0)
	{
		return;	
	}
		
    $state = `checkBox -query -value $chkPdiFlipNormals`;
	
	string  $PDIObjects[];
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;
	for ( $obj in $PDIObjects )
	{
	    $connections = `listConnections -d off -s on ($obj +".fracture")`;
	    if( size($connections)!=0 )
		{
			// it is a fragment
			continue;
		}

		string  $PDIShapes[];
		$PDIShapes = `listConnections -type pdiCollisionShape $obj`;
		if( size($PDIShapes) > 0)
		{		           
            setAttr ($PDIShapes[0] + ".flipCollisionSide(Mesh)" ) $state;
            //force update 
			getAttr ($PDIShapes[0] + ".collisionShapeParam" );            
			getAttr ($PDIShapes[0] + ".outCollisionType" );            
			getAttr ($PDIShapes[0] + ".ca_collisionShape" );    
			getAttr ($obj + ".ca_rigidBody" );    
		}			
	}
}

global proc setPptyRBDFrameToActivate()
{
    global string $comboDynamicType;
	global string $fieldPdiRBDAFrame;
   	global string $pdiRBDA[3];

    global int $pdiUpdate;
	if( $pdiUpdate == false)
	{
		return;	
	}	

	if( !(`radioButton -query -select $pdiRBDA[2]`))
	{
		//body must be activation at frame
		radioButton -edit -select $pdiRBDA[2];
	}

	$frame = `intField -q -value $fieldPdiRBDAFrame`;

	string  $PDIObjects[];
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;

    if( size( $PDIObjects) == 0)
    {
       warning -noContext "Pdi Info: Not Pdi bodies selected";

	   return;
    }

	for ( $obj in $PDIObjects )
	{
	    $connections = `listConnections -d off -s on ($obj +".fracture")`;
	    if( size($connections)!=0 )
		{
			// it is a fragment
			continue;
		}

		setAttr ($obj + ".actFrame" )  $frame;

		//first hit objects  cannot be dynamic
		int $dynamic_type = getAttr ($obj + ".passive" );
		if( $dynamic_type==0)
		{
			setAttr ($obj + ".passive" ) 1;
			setAttr ($obj + ".usercommand" ) true;        
			 //force update
			getAttr ($obj + ".ca_activeState" );        
		}
		else
		{
			//little trick to force deactivate cache mode 			
			string $PDISolver[]=`ls -type pdiSolverNode`;						
			if( size( $PDISolver) > 0)
			{	
				int $gravityEnabled = getAttr ($PDISolver[0] + ".gravityEnabled" );
				if( $gravityEnabled )
			{
					setAttr ($PDISolver[0] + ".gravityEnabled" ) false;
					getAttr ($PDISolver[0] + ".ca_solverParams" );
					setAttr ($PDISolver[0] + ".gravityEnabled" ) true;
				//recover value
					getAttr ($PDISolver[0] + ".ca_solverParams" );
			}
			else
			{
					setAttr ($PDISolver[0] + ".gravityEnabled" ) true;
					getAttr ($PDISolver[0] + ".ca_solverParams" );
					setAttr ($PDISolver[0] + ".gravityEnabled" ) false;
				//recover value
					getAttr ($PDISolver[0] + ".ca_solverParams" );
				}
			}
		}
	}

}
global proc setPptyFirstHitActive()
{
	global string $pdiRBDactivationCollection;
   	global string $pdiRBDA[3];
    global string $ChkPdiPassive;
    global string $comboDynamicType;
	global string $transformNodesToUndo[];
	global int $pdisavedState;
	global int $pdisavedTime;

    global int $pdiUpdate;
	if( $pdiUpdate == false)
	{
		return;	
	}	

	string  $PDIObjects[];
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;
	
    if( size( $PDIObjects) == 0)
    {
       warning -noContext "Pdi Info: Not Pdi bodies selected";

	   return;
    }

    for($obj in $PDIObjects)
    {
        string $transformNode[] =`listRelatives -p $obj`;

		if(`keyframe -query -keyframeCount $transformNode[0]` != 0)
		{
		    string $message = $transformNode[0] + " has animation keys and cannot be dynamic, do you want to create a duplicated child node of it?"  ;
			string $result = `confirmDialog -title "Confirm" -message $message
			-button "Yes" -button "No" -defaultButton "Yes"
			-cancelButton "No" -dismissString "No"`;

			if( $result == "No")
			{
				updatePdiBodyPanel();
				return;
			}		

			break;	    		
		}
	}

	int $mustResetTime=0;
	int $startTime = `playbackOptions -query -minTime`;
	$pdisavedTime =`currentTime -query`;
	if(  $startTime < $pdisavedTime)
	{
		$mustResetTime=1;
		
		refresh -suspend true;
		currentTime -edit $startTime;
	}


	int $state=0;

	if( `radioButton -query -select $pdiRBDA[1]`)
	{
		$state = 1;
	}
	else
	if( `radioButton -query -select $pdiRBDA[2]`)
	{
		$state = 2;
	}

	for ( $obj in $PDIObjects )
	{
	    $connections = `listConnections -d off -s on ($obj +".fracture")`;
	    if( size($connections)!=0 )
		{
			// it is a fragment
			continue;
		}

		setAttr ($obj + ".firstHitActive" )  $state;
		$pdisavedState = $state;

		//first hit objects  cannot be dynamic
		int $dynamic_type = getAttr ($obj + ".passive" );
		if( $dynamic_type==0)
		{
			setAttr ($obj + ".passive" ) 1;
		}
        setAttr ($obj + ".usercommand" ) true;

        //force update
        getAttr ($obj + ".ca_activeState" );        
	}

	if( $mustResetTime)
	{
		clear($transformNodesToUndo);

		for($obj in $PDIObjects)
		{
			string $transformNode[] =`listRelatives -p $obj`;
			$transformNodesToUndo[ size($transformNodesToUndo)] = $transformNode[0];
		}

		
		evalDeferred -lp "select $transformNodesToUndo;currentTime -edit $pdisavedTime;refresh -suspend false;";
		
	}

//update prop windows
	updatePdiBodyPanel();
    updatePdiPropertiesPanel();

}

global proc updateTransformBody()
{
    global string $ChkPdiPassive;
    global string $comboDynamicType;        

	string  $PDIObjects[];
	string  $newPDIObjects[];
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;

    if( size($PDIObjects) > 0)
    {    
	    if( size($PDIObjects) > 1)	    
		{
			string $result = `confirmDialog -title "Confirm" -message "There are multiple objects selected, proceed?"
			-button "Yes" -button "No" -defaultButton "Yes"
			-cancelButton "No" -dismissString "No"`;

			if( $result == "No")
			{
				return;
			}			    		
		}
		
//			$state = `checkBox -query -value $ChkPdiPassive`;
//		int $dynamic_type = `optionMenu -query -select $comboDynamicType`;
		
		waitCursor -state on;

	    for ( $obj in $PDIObjects )
		{			
			string  $PDIShapes[];
			$PDIShapes = `listConnections -type pdiCollisionShape $obj`;
			if( size($PDIShapes) > 0)
			{	
				int $BVolume = getAttr ($PDIShapes[0] + ".type" );
				int $dynamic_type = getAttr ($obj + ".passive" );

				string $transformNode[]=`listRelatives -p $obj`;
				string $shapes[]=`listRelatives -path -ni -typ "mesh" $transformNode[0]`;

				$result=`new_PDIBody -a $dynamic_type -st $BVolume $shapes[0]`;		
				$newPDIObjects[size($newPDIObjects)]=$result[0];
	        
//					print ($selection[0] + " has updated its transform");		
			}
		}			
		select  $newPDIObjects;

	    waitCursor -state off;

		updatePdiPropertiesPanel();
	}
	else
	{
       warning -noContext "PDi Info: no Pdi rigid bodies selected";		
	}			
}
global proc updatePdiBodyPanel()
{
    global string $pdiCreateBodyWindow;
    global int $pdiUpdate;
    global string $BVcollection;
   	global string $rb[6];
    global string $chkPdiFlipNormals;
    global string $chkPdiAnimated;
    global string $comboDynamicType;      
	global string $framePdiRBDactivation;  
	global string $pdiRBDactivationCollection;
   	global string $pdiRBDA[3];
	global string $fieldPdiRBDAFrame;
    
    int $bWExist = `window -ex winCreatePdiBodies`;
    //int $bIconify = `window -query -iconify $pdiCreateBodyWindow`;
    if( $bWExist == false)
    {
//		print("pidBodyPanel iconified, abort\n");			
        return;
    }

	int $isGroupSelected=0;
	string  $TRSnodes[];
	$TRSnodes = `ls -selection -type transform`;
	if( size($TRSnodes) > 0)
	{
		string $shapeNodes[]=`listRelatives -c -type mesh $TRSnodes[0]`;
		if( size($shapeNodes) == 0)$isGroupSelected=1;
	}

	string  $PDIObjects[];
	for ( $obj in $TRSnodes )
	{
		string $PDInode[] =`listRelatives -type pdiRigidBody $obj`;
		if( size($PDInode) > 0)
			$PDIObjects[size($PDIObjects)]=$PDInode[0];
	}

	int $numRbdSelected = size($PDIObjects);
	if($numRbdSelected==0)	
	{
		//maybe PDI rigid bodies are selected
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;
		$numRbdSelected = size($PDIObjects);
	}

	int $showSelectedBVolume=0;
	if( $isGroupSelected)
	{
		//groups with nodes without rbd assigned are excluded
		if($numRbdSelected > 0)
		{
			//if( size($TRSnodes) <= ( $numRbdSelected +2))
			//{
				//$showSelectedBVolume=1;
			//}
			//else
			if( size($TRSnodes) == 1)
			{
				//update panel if it is a PDi shatter group
				string $voronoiNodes[] = `ls -selection -dag -type "pdiVoronoiNode"`;
				if( size( $voronoiNodes) > 0)
				{
					$showSelectedBVolume=1;
				}
			}
		}
	}
	else
	{	
		//is single node or parent node
		if($numRbdSelected!=0)$showSelectedBVolume=1;
	}

	if( $showSelectedBVolume)
    {
		//print(" showSelectedBVolume\n");	
		$pdiUpdate = 0;//disable update					

		//when parent is selected it is the last one 
		$pdiObject0= $PDIObjects[size($PDIObjects)-1];
		int $dynamic_type = getAttr ($pdiObject0 + ".passive" );
		//print( "\ndynamic type = " + $dynamic_type);
				
	    if( $dynamic_type == 1)
	    {
		   //static
			optionMenu -edit -select 2 $comboDynamicType;		    
			frameLayout -edit -enable true $framePdiRBDactivation;
	    }
	    else
	    if( $dynamic_type == 2)
	    {	
		    //kinematic
			optionMenu -edit -select 3 $comboDynamicType;
			frameLayout -edit -enable true $framePdiRBDactivation;
	    }
	    else
	    {	
		   //dynamic
			optionMenu -edit -select 1 $comboDynamicType;		    
			frameLayout -edit -enable false $framePdiRBDactivation;
	    }

		int $frstHitActive = getAttr ($pdiObject0 + ".firstHitActive" );
	    if( $frstHitActive == 1)
	    {
			print " set activate at first hit\n";
			radioCollection -edit -select $pdiRBDA[1] $pdiRBDactivationCollection;	    		
			intField -edit -enable false $fieldPdiRBDAFrame;
	    }
		else
	    if( $frstHitActive == 2)
	    {
			radioCollection -edit -select $pdiRBDA[2] $pdiRBDactivationCollection;	    		
			intField -edit -enable true $fieldPdiRBDAFrame;
	    }
	    else
	    {	
			radioCollection -edit -select $pdiRBDA[0] $pdiRBDactivationCollection;	    		
			intField -edit -enable false $fieldPdiRBDAFrame;
	    }
		int $activationFrame = getAttr ($pdiObject0 + ".actFrame" );
		intField -edit -value $activationFrame $fieldPdiRBDAFrame;

		string  $PDIShapes[];
		$PDIShapes = `listConnections -type pdiCollisionShape $pdiObject0`;
		if( size($PDIShapes) > 0)
		{	
			int $BVolume = getAttr ($PDIShapes[0] + ".type" );
			if( `radioCollection -ex $BVcollection`	&& $BVolume >= 0 && $BVolume < 5)
			{
				radioCollection -edit -select $rb[$BVolume] $BVcollection;	
				if( $BVolume == 3)
				{
					int $flipSide = getAttr ($PDIShapes[0] + ".flipCollisionSide(Mesh)" );
					int $animatedMesh = getAttr ($PDIShapes[0] + ".animated(Mesh)" );
				
					checkBox -edit -enable 1 -value $flipSide $chkPdiFlipNormals;						
					checkBox -edit -enable 1 -value $animatedMesh $chkPdiAnimated;						
				}
				else					
				{
					checkBox -edit -enable 0 $chkPdiFlipNormals;						
					checkBox -edit -enable 0 $chkPdiAnimated;						
				}
			}
		}			
		$pdiUpdate = 1;//enable update			
	}
	else
	{
		frameLayout -edit -enable false $framePdiRBDactivation;
		optionMenu -edit -select 4 $comboDynamicType;		    
//		radioCollection -edit -select $rb[5] $BVcollection;		
//		radioCollection -edit -select $pdiRBDA[0] $pdiRBDactivationCollection;	    		
	}		

	updatePdiPropertiesPanel();

//    showWindow $pdiCreateBodyWindow;
    
//  otherwise fails in Linux  
//	evalDeferred -lp "setFocus MayaWindow";
}

global proc pdiChangeContext()
{
    setToolTo `selectContext`; 

//    print ("Window gets deleted!\n");
}
global proc pdiSetPdiContext()
{
    setToolTo `selectPdiContext`;  

//    print ("Window gets deleted!\n");
}

global proc disableStressesViewVp20()
{
    global string $selectedPdiFbody;

	if( `objExists $selectedPdiFbody`)
	{
		//switch off stresses view when closing fractures window
		//turn off display stresses for previous selected fboby
	    int $PdiDisplayStresses = getAttr ($selectedPdiFbody + ".displayStressses" );
		if( $PdiDisplayStresses==1)
		{
			setAttr( $selectedPdiFbody  + ".displayStressses" ) 0;

			//force update
			getAttr ($selectedPdiFbody  + ".cdst" );
			update_Fbody -dst false $selectedPdiFbody;
		}
	}

}

global proc killPdiFractureWindowJobId()
{
	global string $shiPreviewObject;	  
	global int $shiPreviewModeOn;	  	 
	global string $shiRefObject;

    global string $selectedPdiFbody;
	global string $pdiClustersList;
	global string $pdiFragmentsList;

    global int $UpdateSelectedPdiFractureWinJobId;
	//global int $disableStressesViewJobId;

	deletePdiLocators();
	disableShatteritPreviewMode();
	
	if( $shiRefObject !="")
	{
		$shiRefObject ="";
	}

	string $selectVoronode[] = `ls -selection -dag -type "pdiVoronoiNode"`;
	if(size($selectVoronode)>0)
	{
		//select shatter group when closing shatter window
		select -clear;
		$transformNode=`listRelatives -p  $selectVoronode[0]`;
		$ShatterGroup=`listRelatives -p $transformNode[0]`;
		select $ShatterGroup[0];
	}

	string $voronoiNodes[]= `ls -dag -type "pdiVoronoiNode"`;

	//disable any previous Shatter it drawing
	for($obj in $voronoiNodes)
	{
		setAttr ($obj + ".draw" ) 0;
		//force update
		getAttr -sl ($obj + ".cadraw" );                               

		string $transformNode[]=`listRelatives -p $obj`;
		hide $transformNode[0];
	}
	

	if( `objExists $selectedPdiFbody`)
	{
		//switch off stresses view when closing fractures window
		//turn off display stresses for previous selected fboby
	    int $PdiDisplayStresses = getAttr ($selectedPdiFbody + ".displayStressses" );
		if( $PdiDisplayStresses==1)
		{
			setAttr( $selectedPdiFbody  + ".displayStressses" ) 0;

			//force update
			getAttr ($selectedPdiFbody  + ".cdst" );
			update_Fbody -dst false $selectedPdiFbody;
		}
		//deselect all clusters
		string $clusters[] = `listConnections -d true -type "ClusterPdiNode" $selectedPdiFbody`;
		if( size( $clusters) > 0)
		{
			for ( $obj in  $clusters )
			{
				setAttr(  $obj + ".selected" ) false;
				//force update
				getAttr ( $obj + ".ca_selected" );
			}
		}
		clear($clusters);

		//deselect all fragments
		string $fragments[] = `listConnections -d true -type "pdiRigidBody" $selectedPdiFbody`;
		for ( $obj in  $fragments )
		{
		    setAttr ($obj + ".selected" ) 0;
		    //force update 
	        getAttr ($obj + ".ca_selected" );            
		}
		clear($fragments);

		$selectedPdiFbody="";
	}

	//set all fbodies as unselected when closing fractures window
	string $allFbodies[] = `ls -exactType pdiFbodyNode`;

	for( $obj in $allFbodies)
	{
		setAttr( $obj + ".selected" ) false;
	}

    scriptJob -kill $UpdateSelectedPdiFractureWinJobId;
//    scriptJob -kill  $disableStressesViewJobId;
}

global proc killUpdateManagePanelJob()
{
    global int $UpdatePdiManagePanelJobId;

    scriptJob -kill $UpdatePdiManagePanelJobId;
}

global proc killUpdatePdiAddParticlesPanelJob()
{
    global int $UpdatePdiAddParticlesPanelJobId;

    scriptJob -kill $UpdatePdiAddParticlesPanelJobId;
}


global proc killUpdateBodyPanelJob()
{
    global int $UpdatePdiBodyPanelJobId;

	string  $PDISelected[];
    $PDISelected = `ls -selection -dag -leaf -type pdiRigidBody`;
    for ( $obj in $PDISelected )
    {
//    	int $enabled = getAttr ($obj + ".enabled" );
        $connections = `listConnections -d off -s on ($obj +".fracture")`;

//        if( $enabled > 0 && size($connections)==0 )
        if( size($connections)==0 )
        {
		    setAttr ($obj + ".selected" ) 0;
		    //force update 
			getAttr ($obj + ".ca_selected" );            
        }
    }

    scriptJob -kill $UpdatePdiBodyPanelJobId;
}
global proc killUpdateCrackersPanelJob()
{
    global int $UpdatePdiCrackersPanelJobId;

    scriptJob -kill $UpdatePdiCrackersPanelJobId;
}

global proc showPdiRBDPropertiesTab()
{
	global string $pdiRbdWindowTabs;
	global string $pdiCreateBodyWindow;

    if ( !(`window -ex winCreatePdiBodies`) )
    {                
		createPdiBodyPanel();
	}

	tabLayout -e -st pdiRBDPropertiesTab $pdiRbdWindowTabs;

	showWindow $pdiCreateBodyWindow;
	evalDeferred -lp "setFocus MayaWindow";

}
global proc showPDiNewRBDTab()
{
	global string $pdiRbdWindowTabs;
	global string $pdiCreateBodyWindow;

    if ( !(`window -ex winCreatePdiBodies`) )
    {                
		createPdiBodyPanel();
	}

	tabLayout -e -st pdiNewRigidBodyTab $pdiRbdWindowTabs;

	showWindow $pdiCreateBodyWindow;
	evalDeferred -lp "setFocus MayaWindow";
}
global proc showPDiManageRBDTab()
{
	global string $pdiRbdWindowTabs;
	global string $pdiCreateBodyWindow;

    if ( !(`window -ex winCreatePdiBodies`) )
    {                
		createPdiBodyPanel();
	}

	tabLayout -e -st pdiManageRBDTab $pdiRbdWindowTabs;

	showWindow $pdiCreateBodyWindow;
	evalDeferred -lp "setFocus MayaWindow";
}

global proc updateSelectionPdiBodyWindow()
{
	global string $pdiRbdWindowTabs;

	updatePdiBodyPanel();
	updateSelectedPdiManagePanel();

//	$selectedTab = `tabLayout -q -st $pdiRbdWindowTabs`;
//	if( $selectedTab == "pdiNewRigidBodyTab")
//	{
//		updatePdiBodyPanel();
//	}
//	else
//	if( $selectedTab == "pdiRBDPropertiesTab")
//	{
//	   updatePdiPropertiesPanel();
//	}
}

global proc createPdiBodyPanel()
{
    global string $pdiCreateBodyWindow;
	global string $pdiRbdWindowTabs;
    global int $pdiUpdate;
    global string $BVcollection;
   	global string $rb[6];
    global string $chkPdiFlipNormals;
    global string $chkPdiAnimated;
    global string $ChkPdiPassive;
    global string $comboDynamicType;        
	global string $framePdiRBDactivation;
	global string $pdiRBDactivationCollection;
   	global string $pdiRBDA[3];
	global string $fieldPdiRBDAFrame;

    global string $chkPdiMayaFields;
    global string $fieldPdiFriction;
    global string $fieldPdiBounciness;
    global string $fieldPdiLdamping;
    global string $fieldPdiAdamping;
    global string $fieldPdiGapFactor;
    global string $fieldPdiMass;
    global string $fieldPdiCenterMass;
    global string $fieldPdiVelocity;
    global string $fieldPdiRandomV;
    global string $fieldPdiWelocity;
    global string $fieldPdiRandomW;
    global string $butPdiForceFieldList;

	global string $pdiBodiesList;
	global string $butDeleteSelRbd;
	global string $pdiLblNumActiveSingleBodies;
	global string $pdiLblNumDisabledSingleBodies;
	global string $pdiLblNumFragments;
	global string $pdiLblPdiGridAsGround;
	global string $butDeleteAllNodes;
	global string $butDeletePdiHelpers;
	global int $VerbosePDIOutput;

    global int $UpdatePdiBodyPanelJobId;
                 

//    setToolTo `selectPdiContext`; 
//    headsUpMessage "Pdi Interactive selection Tool has been activated";

    //check if the window exists
    if ( `window -ex winCreatePdiBodies` )
    {                
        updatePdiBodyPanel();
        
        return;
    }

    $pdiUpdate = 1;

	$pdiCreateBodyWindow = `window -rtf true -t "PDI rigid bodies Window" -width 350 -height 400 winCreatePdiBodies`;
    $pdiRbdWindowTabs = `tabLayout -innerMarginWidth 5 -innerMarginHeight 5`;

//CREATE RBD TAB
		string $child1 = `columnLayout -adjustableColumn true pdiNewRigidBodyTab`;   
			frameLayout -width 30 -height 50 -label "Rigid Body";
			columnLayout -columnAttach "left" 25;
				$comboDynamicType = `optionMenu -label "Type" 
				-ann " set dynamic behaviour of the object" -cc "setPdiDynamicType"`;
				menuItem -label "Dynamic";
				menuItem -label "Static";
				menuItem -label "Kinematic";
				menuItem -label " ";        
				setParent ..;                   
			setParent ..;                   
			frameLayout -width 30 -height 170 -label "Bounding Volume";
				columnLayout -columnAttach "left" 50;
				$BVcollection = `radioCollection`;
				$rb[0] = `radioButton -label "None" -ann "object will move but not collide" -onCommand "createPDIVoidBody"`;
				$rb[1] = `radioButton -label "Capsule" -ann "object will roll on collision" -onCommand "createPDICapsuleBody"`;
				$rb[2] = `radioButton -label "Convex Hull" -ann "recommended for faster computation" -onCommand "createPDIHullBody"`;
				$rb[3] = `radioButton -label "Mesh" -ann "use it in objects with holes or mesh-animated" -onCommand "createPDIMeshBody"`;
					columnLayout -columnAttach "left" 25;
					$chkPdiFlipNormals = `checkBox -label "Flip collision side" -align "left" -enable 0 -changeCommand "setPptyFlipSide"`;
					$chkPdiAnimated = `checkBox -label "Animated" -align "left" -enable 0 -changeCommand "setPptyAnimated"`;
					setParent ..;			
				$rb[4] = `radioButton -label "Auto" -ann "set the best BVolume automatically" -onCommand "createPDIAutoBody" `;
				//create a last one only for select it for unassigned shapes
				$rb[5] = `radioButton -label "Unassigned" -ed 0 -vis 0`;
				setParent ..;
			setParent ..;
			$framePdiRBDactivation = `frameLayout -width 50 -height 50 -label "Activation"`;
				rowLayout -columnWidth4 90 90 90 90 -numberOfColumns 4;
				$pdiRBDactivationCollection=`radioCollection`;
				$pdiRBDA[0]=`radioButton -label "Never" -select -ann " the rigid body remains static/kinematic during simulation" -onc "setPptyFirstHitActive"`;
				$pdiRBDA[1]=`radioButton -label "At first hit" -select -ann " becomes dynamics at first collision with other object" -onc "setPptyFirstHitActive"`;
				$pdiRBDA[2]=`radioButton -label "At frame" -ann " becomes dynamics at specified frame" -onc "setPptyFirstHitActive"`;
				$fieldPdiRBDAFrame = `intField -w 50 -value 1 -ann " set activation frame" -changeCommand "setPptyRBDFrameToActivate"`;  
				setParent ..;                   							 
			setParent ..;                   							 

		$bttPdiUpdateBody = `button  -w 50 -h 30 -label "Update Transform"
			-ann "update the Bounding volume of the object" -command "updateTransformBody"`;
		setParent ..;

//DYNAMICS RBD TAB
	string $child2 = `columnLayout -adjustableColumn true pdiRBDPropertiesTab`;
        $fieldPdiBounciness = `floatSliderGrp -label "Bounciness" -field true
	        -minValue 0.0 -maxValue 1.0 -pre 3
	        -ann "set the strength of the bounce in collision"
            -changeCommand "setPptyPdiBounciness"` ;
        $fieldPdiFriction = `floatSliderGrp -label "Friction" -field true
	        -minValue 0.0 -maxValue 1.0 -pre 3
            -ann "set the strength of friction in collision"
            -changeCommand "setPptyPdiFriction"` ;

////////////////////////////////////////active params
        $fieldPdiLdamping = `floatSliderGrp -label "Linear Damping"  -field true
	        -minValue 0.0 -maxValue 1.0 -pre 3
            -ann "set linear damping value for dynamics objects"            	        
            -changeCommand "setPptyPdiLdamping"` ;
        $fieldPdiAdamping = `floatSliderGrp -label "Angular Damping" -field true
	        -minValue 0.0 -maxValue 1.0 -pre 3
            -ann "set angular damping value for dynamics objects"            	        
            -changeCommand "setPptyPdiAdamping"` ;
        $fieldPdiGapFactor = `floatSliderGrp -label "Gap factor" -field true
	        -minValue 0.0 -maxValue 1.0 -pre 3
            -ann "gap factor forces objects to keep separate"            	        	        
            -changeCommand "setPptyPdiGapFactor"` ;
        $fieldPdiMass = `floatFieldGrp -numberOfFields 1 -label "Mass" 
	        -value1 1.0  -pre 2
            -ann "set mass of the object"            	        	        	        
            -changeCommand "setPptyPdiMass"` ;
        $fieldPdiCenterMass = `floatFieldGrp -numberOfFields 3 -label "Mass Centre" 
	        -value1 0.0 -value2 0.0 -value3 0.0  
            -ann "set center of mass for the object"            	        	        	        	        
            -changeCommand "setPptyPdiCenterMass"` ;
        frameLayout -width 50 -height 70 -label "Initial Velocity";
//		columnLayout -columnAttach "left" 20;
            $fieldPdiVelocity = `floatFieldGrp -numberOfFields 3 -label "Value" 
	            -value1 0.0 -value2 0.0 -value3 0.0  
				-ann "set linear velocity of the object"            	        	        	        	        	            
                -changeCommand "setPptyPdiVelocity"` ;
            $fieldPdiRandomV = `intFieldGrp -numberOfFields 3 -label "Random" -extraLabel "%"
	            -value1 0 -value2 0 -value3 0  
				-ann "set linear random offset when setting several objects at once"            	        	        	        	        	            
                -changeCommand "setPptyPdiVelocity"` ;
//		    setParent ..;
		setParent ..;
        frameLayout -width 50 -height 70 -label "Initial Spin";
//		columnLayout -columnAttach "left" 20;
            $fieldPdiWelocity = `floatFieldGrp -numberOfFields 3 -label "Value" 
	            -value1 0.0 -value2 0.0 -value3 0.0  
				-ann "set angular velocity of the body"            	        	        	        	        	            	            
                -changeCommand "setPptyPdiWelocity"` ;
            $fieldPdiRandomW = `intFieldGrp -numberOfFields 3 -label "Random" -extraLabel "%"
	            -value1 0 -value2 0 -value3 0  
				-ann "set angular random offset when setting several objects at once"            	        	        	        	        	            	            
                -changeCommand "setPptyPdiWelocity"` ;
//		    setParent ..;
		setParent ..;
		$chkPdiMayaFields = `checkBox -v false -label "affected by Force Fields" -align "left"
			-ann "enable/disable force fields affecting the motion of the body"            	        	        	        	        	            	            
			-changeCommand "setPptyPdiMayaFields"`;	              
		$butPdiForceFieldList =`button  -enable false -w 70 -h 30 -label "Include/Exclude"
			-ann "select the fields affecting the motion of the body" 
			-command "pdiExcludeIncludeForceFields"`;
	setParent ..;

//MANAGE RBD TAB
    string $child3 = `formLayout -numberOfDivisions 200 pdiManageRBDTab`;
    string $pdiLabelSingleBodies = `text -w 140 -font "smallBoldLabelFont" -label "Active Single Rigid Bodies"`;
    $pdiBodiesList = `textScrollList -w 100 -numberOfRows 10 -allowMultiSelection true` ;
            //-append "one"      -append "two"      -append "three"
            //-append "four"     -append "five"     -append "six"
            //-append "seven"    -append "eight"    -append "nine"
            //-append "ten"      -append "eleven"   -append "twelve"
            //-append "thirteen" -append "fourteen" -append "fifteen"
            //-selectItem "six"
            //-showIndexedItem 4`;
    string $butAdd = `button  -w 100 -label "Add"
    -ann " add selected bodies to computation"
     -command "addBodiesToPdiWorld"`;
    string $butRemove =`button  -w 100 -label "Remove"
    -ann " remove temporally selected bodies from computation "    
     -command "removeBodiesFromPdiWorld"`;
    string $butRemoveAll =`button  -w 100 -label "Remove All"
    -ann " remove temporally all bodies from computation "        
     -command "removeAllBodiesFromPdiWorld"`;
    string $butShowDisabledRbd =`button  -w 150 -label "Hide/Show Disabled Rigid Bodies" -enable true
    -ann " toggle show/hide disabled rigd bodies in viewport "    
     -command "toggleShowDisabledRigidBodies"`;
    $butDeleteSelRbd =`button  -w 150 -label "Delete Selected" -enable false
    -ann " remove permanently selected bodies from computation "    
     -command "deleteBodiesFromPdiWorld"`;

    $pdiLblNumActiveSingleBodies = `text -w 160 -al "left" -label ""`;
    $pdiLblNumDisabledSingleBodies = `text -w 170 -al "left" -label ""`;
	$pdiLblNumFragments = `text -w 160 -al "left" -label ""`;
	$pdiLblPdiGridAsGround = `text -w 160 -al "left" -label ""`;
    $butDeleteAllNodes =`button  -w 140 -label "Delete All Pdi Bodies" 
						-ann "HINT:delete Pdi nodes after baking simulation for freeing resources"
						-command "deleteAllBodiesFromPdiWorld"`;
    $butDeletePdiHelpers =`button  -w 140 -label "Delete All Pdi Entities" -en false
						-ann "HINT:delete all Pdi entities removes any dependence on Pulldownit plugin"
						-command "deleteAllPdiEntities"`;
    string $butSelectPdiNoMass =`button  -w 140 -label "Select non-solid Objects" -en true
						-ann "HINT:non-solid  objects cause issues in dynamics"
						-command "selectNegativeMassobjects"`;



    formLayout -edit
		-attachForm     $pdiLabelSingleBodies "top"    10
        -attachControl  $pdiBodiesList      "top"    0	$pdiLabelSingleBodies
        -attachForm     $pdiBodiesList      "left"    0
        -attachForm     $pdiBodiesList      "right"    0
        -attachForm     $pdiBodiesList      "bottom" 240
        -attachControl  $butAdd				"top"    0 $pdiBodiesList
        -attachForm     $butAdd				"left"   0
        -attachControl      $butRemove      "top"    0 $pdiBodiesList
        -attachControl     $butRemove		"left" 0 $butAdd
        -attachControl      $butRemoveAll   "top"    0 $pdiBodiesList
        -attachControl     $butRemoveAll    "left" 0 $butRemove
        -attachForm     $butRemoveAll		"right" 0
        -attachControl  $butShowDisabledRbd      "top"    0  $butRemoveAll
        -attachForm     $butShowDisabledRbd			"left"   0
        -attachForm     $butShowDisabledRbd			"right" 0
        -attachControl  $butDeleteSelRbd      "top"    0 $butShowDisabledRbd
        -attachForm     $butDeleteSelRbd			"left"   0
        -attachForm     $butDeleteSelRbd			"right" 0
		-attachControl	$pdiLblNumActiveSingleBodies "top" 10 $butDeleteSelRbd
        -attachForm     $pdiLblNumActiveSingleBodies "left"   20
		-attachControl	$pdiLblNumDisabledSingleBodies "top" 5 $pdiLblNumActiveSingleBodies
        -attachForm     $pdiLblNumDisabledSingleBodies "left"   20
		-attachControl	$pdiLblNumFragments				"top" 5 $pdiLblNumDisabledSingleBodies
        -attachForm     $pdiLblNumFragments				"left"   20		
		-attachControl	$pdiLblPdiGridAsGround			"top" 5 $pdiLblNumFragments
        -attachForm     $pdiLblPdiGridAsGround			"left"   20			
        -attachControl  $butDeleteAllNodes      "top" 10 $pdiLblPdiGridAsGround
        -attachForm     $butDeleteAllNodes      "left" 20
        -attachForm     $butDeleteAllNodes      "right" 20
        -attachControl  $butDeletePdiHelpers      "top" 10 $butDeleteAllNodes
        -attachForm     $butDeletePdiHelpers      "left" 20
        -attachForm     $butDeletePdiHelpers      "right" 20
        -attachControl  $butSelectPdiNoMass      "top" 10 $butDeletePdiHelpers
        -attachForm     $butSelectPdiNoMass      "left" 20
        -attachForm     $butSelectPdiNoMass      "right" 20
        -attachForm     $butSelectPdiNoMass      "right" 20
        -attachForm     $butSelectPdiNoMass      "bottom" 5
    $child3;

    tabLayout -edit
    	-tabLabel $child1 "Create"
    	-tabLabel $child2 "Dynamic Properties"
    	-tabLabel $child3 "Manage and Clean"
    $pdiRbdWindowTabs;

    
	$UpdatePdiBodyPanelJobId = `scriptJob -event SelectionChanged updateSelectionPdiBodyWindow`;
    scriptJob -uiDeleted $pdiCreateBodyWindow killUpdateBodyPanelJob;
	
	//update the window with selected objects attributes

	$VerbosePDIOutput=1;
	updatePdiBodyPanel();
	updatePdiManagePanel();
}
/****************************************
	PDI SOLVER PANEL
******************************************/
global proc setPptyGravityEnabled()
{
    global string $chkPdiGravityEnabled;
    
//    print("setPptyGravityEnabled()\n");			

    global int $pdiUpdate;
	if( $pdiUpdate==0)
	{
//        print("updating off\n");			
		return;	
	}	

    $state = `checkBox -query -value $chkPdiGravityEnabled`;
    
    string $PDISolver[]=`ls -type pdiSolverNode`;
	if( size( $PDISolver) == 0)return;

	if( $state==true)
	{		
		setAttr ($PDISolver[0] + ".gravityEnabled" ) false;
	}
	else
	{
		setAttr ($PDISolver[0] + ".gravityEnabled" ) true;
	}		

     //force update
     getAttr ($PDISolver[0] + ".ca_solverParams" );
}
global proc setPptyMayaUnits()
{
    global string $chkPdiFitUnitsMaya;
    
    global int $pdiUpdate;
	if( $pdiUpdate==0)
	{
		return;	
	}	

    confirmDialog
    -title "Pdi Info"
    -message "By changing this parameter, you`ll have probably to reassign dynamic properties for already created PDI objects"
    -button "OK" 
    -defaultButton "OK" ;

    $state = `checkBox -query -value $chkPdiFitUnitsMaya`;
    
    string $PDISolver[]=`ls -type pdiSolverNode`;
	if( size( $PDISolver) == 0)return;

	if( $state==true)
	{		
		setAttr ($PDISolver[0] + ".fitUnitsToMayaScale" ) true;
	}
	else
	{
		setAttr ($PDISolver[0] + ".fitUnitsToMayaScale" ) false;
	}		
     //force update
     getAttr ($PDISolver[0] + ".ca_solverParams" );
}
global proc updatePdiStartFrame()
{
    global string $fieldPdiStartFrame;

    int $value = `intField -q -value $fieldPdiStartFrame`;	

    int $minValue = `playbackOptions -q -min`;
    if( $value >= $minValue)
    {
		string $PDISolver[]=`ls -type pdiSolverNode`;
		if( size( $PDISolver) == 0)return;

        setAttr( $PDISolver[0] + ".startFrame" ) $value;

     //force update
		getAttr ($PDISolver[0] + ".ca_solverParams" );
    }
    else
    {
       warning -noContext "start frame cannot be less than playback start time";
    }

}
global proc updatePdiNumThreads()
{
//    global string $fieldPdiNumThreads;
    global string $chkPdiNumThreads;

    string $PDISolver[]=`ls -type pdiSolverNode`;
	if( size( $PDISolver) == 0)return;

//    int $value = `intField -q -value $fieldPdiNumThreads`;	
    $state = `checkBox -query -value $chkPdiNumThreads`;

	if( $state==true)
	{		
		setAttr ($PDISolver[0] + ".numThreads" ) 2;
	}
	else
	{
		setAttr ($PDISolver[0] + ".numThreads" ) 0;
	}		

     //force update
     getAttr ($PDISolver[0] + ".ca_numThreads" );
}
global proc setPdiCachedMode()
{
    global string $chkPdiCachedMode;

    global int $pdiUpdate;
	if( $pdiUpdate==0)
	{
		return;	
	}	

    string $PDISolver[]=`ls -type pdiSolverNode`;
	if( size( $PDISolver) == 0)return;

    $state = `checkBox -query -value $chkPdiCachedMode`;
    
	if( $state==true)
	{		
		setAttr ($PDISolver[0] + ".cacheActive" ) true;
	}
	else
	{
		setAttr ($PDISolver[0] + ".cacheActive" ) false;
	}		
     //force update
     getAttr ($PDISolver[0] + ".ca_cacheSize" );

}

global proc setPdiDisplayMode()
{
    global string $pdiDisplayStylecollection;
   	global string $pdiDisplayStyle[2];
    
    global int $pdiUpdate;
	if( $pdiUpdate==0)
	{
		return;	
	}	

    string $PDISolver[]=`ls -type pdiSolverNode`;
	if( size( $PDISolver) == 0)return;

    if( `radioButton -query -select $pdiDisplayStyle[1]`)
    {
		setAttr ($PDISolver[0] + ".displaySelected" ) true;
    }
    else
    {
		setAttr ($PDISolver[0] + ".displaySelected" ) false;
    }
    
     //force update
     getAttr ($PDISolver[0] + ".ca_displaySelected" );
     
     evalDeferred -lp "refresh";//defered it until evaluation ends 
}
global proc updatePdiSimQuality()
{
    global string $pdiCreateSolverWindow;
    global string $fieldPdiSubstep;    
    global string $comboSimQaulity;    
    global int $pdiUpdate;
	if( $pdiUpdate==0)
	{
		return;	
	}

    string $PDISolver[]=`ls -type pdiSolverNode`;
	if( size( $PDISolver) == 0)return;

	int $quality = `optionMenu -query -select $comboSimQaulity`;

	if( $quality == 1)
	{
		setAttr ($PDISolver[0] + ".substeps" ) 3;	
	}				
	else
	if( $quality == 2)
	{
		setAttr ($PDISolver[0] + ".substeps" ) 5;	
	}				
	if( $quality == 3)
	{
		setAttr ($PDISolver[0] + ".substeps" ) 10;	
	}				
	if( $quality == 4)
	{
		setAttr ($PDISolver[0] + ".substeps" ) 20;	
	}				
     //force update
     getAttr ($PDISolver[0] + ".ca_solverParams" );
}
global proc updatePdiSubStep()
{
    global string $pdiCreateSolverWindow;
    global string $fieldPdiSubstep;    
    global string $comboSimQaulity;    
    global int $pdiUpdate;
	if( $pdiUpdate==0)
	{
		return;	
	}	

    string $PDISolver[]=`ls -type pdiSolverNode`;
	if( size( $PDISolver) == 0)return;

//	int $substep = `attrFieldSliderGrp -query -s $fieldPdiSubstep`;
	int $substep = getAttr ($PDISolver[0] + ".substeps" );
	if( $substep < 5)
	{
		optionMenu -edit -select 1 $comboSimQaulity;
	}
	else
	if( $substep < 10)
	{
		optionMenu -edit -select 2 $comboSimQaulity;
	}
	else
	if( $substep < 20)
	{
		optionMenu -edit -select 3 $comboSimQaulity;
	}
	else
	{
		optionMenu -edit -select 4 $comboSimQaulity;
	}

	setAttr ($PDISolver[0] + ".substeps" ) $substep;	
     //force update
     getAttr ($PDISolver[0] + ".ca_solverParams" );

//   showWindow $pdiCreateSolverWindow;
}
global proc setPdiGridAsGround()
{
    global string $chkPdiGridAsGround;
    
    global int $pdiUpdate;
	if( $pdiUpdate==0)
	{
		return;	
	}	

    $state = `checkBox -query -value $chkPdiGridAsGround`;
    
    string $PDISolver[]=`ls -type pdiSolverNode`;
	if( size( $PDISolver) == 0)return;

	if( $state==true)
	{
		int $state=`grid -q -toggle`;
		if( $state==false)
		{
			grid -toggle true;
		}				
//		displayColor -dormant "grid" 15;	
		setAttr ($PDISolver[0] + ".useGroundGrid" ) true;
	}
	else
	{	   
//		displayColor -dormant "grid" 3;	
		setAttr ($PDISolver[0] + ".useGroundGrid" ) false;
	}		
     //force update
     getAttr ($PDISolver[0] + ".ca_solverParams" );


	if ( `window -ex winCreatePdiBodies` )
	{                
		updatePdiManagePanel();
	}
}
global proc updatePdiSolverPanel()
{
    global string $pdiCreateSolverWindow;
    global string $chkPdiFitUnitsMaya;
    global string $chkPdiGravityEnabled;
    global string $chkPdiGridAsGround;    
//    global string $fieldPdiNumThreads;
    global string $chkPdiNumThreads;
    global string $chkPdiCachedMode;
	global string $lblPdiCacheState;
	global string $butClearPDiCache;
    global string $fieldPdiSubstep;    
    global string $fieldPdiStartFrame;
	global string $lblPdiStartFrame;
    global string $pdiDisplayStylecollection;
   	global string $pdiDisplayStyle[2];
    global string $comboSimQaulity;    
	global string $lblPdiSolverHint;
	global string $fieldPdiGravity;

    global int $pdiUpdate;

//	print "updatePdiSolverPanel\n";

    //check if the window exists
    if ( !`window -ex winPdiSolver` )
    {                
        //window iconified, abort
	     return;
    }

    string $PDISolver[]=`ls -type pdiSolverNode`;
	if( size( $PDISolver) == 0)
	{
		radioButton -edit -enable false $pdiDisplayStyle[0];
		radioButton -edit -enable false $pdiDisplayStyle[1];

	 	checkBox -edit -enable false $chkPdiGridAsGround;	
		intField -edit -enable false $fieldPdiStartFrame;
		text -edit -enable false $lblPdiStartFrame;
		checkBox -edit -enable false $chkPdiNumThreads;	
	    checkBox -edit -enable false $chkPdiGravityEnabled;

	    checkBox -edit -enable false $chkPdiCachedMode;	
		button -edit -enable false $butClearPDiCache;
		optionMenu -edit -enable false $comboSimQaulity;
		attrFieldSliderGrp	-edit -enable false $fieldPdiSubstep;
        attrFieldGrp	-edit -enable false $fieldPdiGravity;

		text -edit -label "HINT:Create Pdi bodies to enable solver options" $lblPdiSolverHint;

		showWindow $pdiCreateSolverWindow;

		return;
	}

    $pdiUpdate = 0;//disable update					

	text -edit -label "" $lblPdiSolverHint;
	attrFieldGrp -e -at ($PDISolver[0] + ".gravity") $fieldPdiGravity;
	attrFieldSliderGrp -e -at ($PDISolver[0] + ".substeps") $fieldPdiSubstep;
	attrFieldGrp -edit -enable true $fieldPdiGravity;
    attrFieldSliderGrp	-edit -enable true $fieldPdiSubstep;

	radioButton -edit -enable true $pdiDisplayStyle[0];
	radioButton -edit -enable true $pdiDisplayStyle[1];

    int $displayMode = getAttr ($PDISolver[0] + ".displaySelected" );
	if( $displayMode > 0)
	{	
		radioCollection -edit -select $pdiDisplayStyle[1] $pdiDisplayStylecollection;
	}
	else
	{	
		radioCollection -edit -select $pdiDisplayStyle[0] $pdiDisplayStylecollection;
	}

//   int $useMayaUnits = getAttr ($PDISolver[0] + ".fitUnitsToMayaScale" );
//	 if( $useMayaUnits > 0)
//	 {	
// 		checkBox -edit -value 1 $chkPdiFitUnitsMaya;		
//   }
//   else
//	 {	
//	 	checkBox -edit -value 0 $chkPdiFitUnitsMaya;		
//	 }

 	 checkBox -edit -enable true $chkPdiGridAsGround;	

     int $gridAsGround = getAttr ($PDISolver[0] + ".useGroundGrid" );
	 if( $gridAsGround > 0)
	 {	
 		checkBox -edit -value 1 $chkPdiGridAsGround;		
     }
     else
	 {	
	 	checkBox -edit -value 0 $chkPdiGridAsGround;		
	 }

    int $startFrame = getAttr ($PDISolver[0] + ".startFrame" );

	text -edit -enable true $lblPdiStartFrame;
	intField -edit -enable true $fieldPdiStartFrame;
    intField -edit -value $startFrame $fieldPdiStartFrame;

//    int $numThreads = getAttr ($PDISolver + ".numThreads" );
//    intField -edit -value $numThreads $fieldPdiNumThreads;

	checkBox -edit -value 0 $chkPdiNumThreads;		

    int $gravityEnabled = getAttr ($PDISolver[0] + ".gravityEnabled" );
	if( $gravityEnabled > 0)
	{	
		checkBox -edit -value 0 $chkPdiGravityEnabled;		
	}
	else
	{	
		checkBox -edit -value 1 $chkPdiGravityEnabled;		
	}

    int $useCachedMode = getAttr ($PDISolver[0] + ".cacheActive" );
    int $pdiCachedState = getAttr ($PDISolver[0] + ".cachedMode" );

	checkBox -edit -enable true $chkPdiCachedMode;	

	if( $useCachedMode > 0)
	{	
	    int $lastComputedFrame = `pdiSolver -rct`;

		checkBox -edit -value 1 $chkPdiCachedMode;		
		button -edit -enable true $butClearPDiCache;
		if( $pdiCachedState > 0)
		{
			text -edit -label "PDI Cache State: Active" $lblPdiCacheState;	
		}
		else
		{
		  if( $lastComputedFrame > 1)
			text -edit -label "PDI Cache State: in Progress.." $lblPdiCacheState;	
		  else
			text -edit -label "PDI Cache State: Clear" $lblPdiCacheState;	
		}
	}
	else
	{	
		checkBox -edit -value 0 $chkPdiCachedMode;		
		text -edit -label "PDI Cache State: Disabled" $lblPdiCacheState;	
		button -edit -enable false $butClearPDiCache;
	}

	optionMenu -edit -enable true $comboSimQaulity;

	int $substep = getAttr ($PDISolver[0] + ".substeps" );
	if( $substep < 5)
	{
		optionMenu -edit -select 1 $comboSimQaulity;
	}
	else
	if( $substep < 10)
	{
		optionMenu -edit -select 2 $comboSimQaulity;
	}
	else
	if( $substep < 20)
	{
		optionMenu -edit -select 3 $comboSimQaulity;
	}
	else
	{
		optionMenu -edit -select 4 $comboSimQaulity;
	}
	

    $pdiUpdate = 1;//enable update			

    showWindow $pdiCreateSolverWindow;

}

global proc createPdiSolverPanel()
{
    global string $pdiCreateSolverWindow;
//    global string $chkPdiFitUnitsMaya;
    global string $chkPdiGridAsGround;
    global string $chkPdiGravityEnabled;
//    global string $fieldPdiNumThreads;
    global string $chkPdiNumThreads;
    global string $fieldPdiSubstep;
    global string $chkPdiCachedMode;
	global string $lblPdiCacheState;
	global string $butClearPDiCache;
    global string $fieldPdiStartFrame;
	global string $lblPdiStartFrame;
    global int $pdiUpdate;
    global string $pdiDisplayStylecollection;
   	global string $pdiDisplayStyle[2];
   	global string $comboSimQaulity;    
	global string $lblPdiSolverHint;
	global string $fieldPdiGravity;
    
    //check if the window exists
    if ( `window -ex winPdiSolver` )
    {                
        updatePdiSolverPanel();
        
        return;
    }
 
    $pdiUpdate = 1;//enable update			

    //create pdiSolver node if necessary
//	string $thePdiSolver =0;
//    string $PDISolver[]=`ls -type pdiSolverNode`;
//	if( size( $PDISolver) == 0)
//	{
//	    print "creating temporal pdi solver\n";
//		$thePdiSolver = `pdiSolver`;//needed exist to create associated controls
//	}
//	else
//	{
//		$thePdiSolver = $PDISolver[0];
//	}

    
	$pdiCreateSolverWindow = `window -rtf true -t "Pdi Solver Window" -width 400 -height 80 winPdiSolver`;
//    $pdiSolverWindowTabs = `tabLayout -innerMarginWidth 5 -innerMarginHeight 5`;
	string $child1 = `columnLayout -adjustableColumn true`; 
    frameLayout -width 400 -height 50 -label "Display";
	    rowLayout -numberOfColumns 2 -cw2 100 200;
	    $pdiDisplayStylecollection =`radioCollection`;
        $pdiDisplayStyle[0]=`radioButton -label "All Pdi Entities" -onc "setPdiDisplayMode"`;
        $pdiDisplayStyle[1]=`radioButton -label "Selected only" -select -onc "setPdiDisplayMode"`;
        setParent ..;
    setParent ..;
    frameLayout -width 400 -height 100 -label "Performance";
		columnLayout -adjustableColumn true -rs 10;
        rowColumnLayout -numberOfRows 1 -co 1 "left" 30;
	//        text -label "Number of threads"   -align "left";
	//        $fieldPdiNumThreads = `intField -w 50 -s 1 -minValue -1 -maxValue 4 -value 1 -changeCommand "updatePdiNumThreads"`;      
			$chkPdiNumThreads = `checkBox -label "Enable Multithreading" -align "left" -enable 1
        -ann " enable/disable using all cores for computing" -changeCommand "updatePdiNumThreads"`;	                       
        text -label "        "   -align "left";        
        $chkPdiCachedMode = `checkBox -label "Enable cached mode" -align "left" -enable 1
        -ann " enable/disable computation cached during playback" -changeCommand "setPdiCachedMode"`;	              
        setParent ..;
		$lblPdiCacheState = `text -label "PDI Cache State: "  -align "left"`;
		$butClearPDiCache = `button  -w 100 -h 20 -label "Clear PDI Cache" -command "pdiSolver -cch;updatePdiSolverPanel()"`;// -aop false
		setParent ..;
    setParent ..;
	frameLayout -width 400 -height 70 -label "Gravity";
	    columnLayout -columnAttach "left" 30;
		$chkPdiGravityEnabled = `checkBox -label "disabled" -align "left" -changeCommand "setPptyGravityEnabled"`;
//        $fieldPdiGravity = `attrFieldGrp -at ($thePdiSolver + ".gravity") -changeCommand "setPptyGravityEnabled"` ;
        $fieldPdiGravity = `attrFieldGrp -label "Gravity" -changeCommand "setPptyGravityEnabled"` ;
	    setParent ..;
    setParent ..;    
    frameLayout -width 400 -height 140 -label "Simulation options";    
		columnLayout -columnAttach "left" 30;
			$comboSimQaulity = `optionMenu -label "Quality " 
				-ann " set the overall acurracy of the computation" -cc "updatePdiSimQuality"`;
				menuItem -label "Preview";
				menuItem -label "Low";
				menuItem -label "Medium";
				menuItem -label "High";
//			$fieldPdiSubstep = `attrFieldSliderGrp -min 1 -max 150 -s 5 -at ($thePdiSolver + ".substeps")
//				-ann "set computation steps per frame" -cc "updatePdiSubStep"`;
			$fieldPdiSubstep = `attrFieldSliderGrp  -label "Substeps" -min 1 -max 150 -s 5 
				-ann "set computation steps per frame" -cc "updatePdiSubStep"`;
			rowColumnLayout -numberOfRows 1 -co 1 "left" 85;
				$lblPdiStartFrame =`text -label "Start frame "   -align "left" `;
				$fieldPdiStartFrame = `intField -w 50 -value 1
				-ann " changes the start frame for dynamics" -changeCommand "updatePdiStartFrame"`;  
			setParent ..;
		$chkPdiGridAsGround = `checkBox -label "Use Maya grid as ground" -align "left" -changeCommand "setPdiGridAsGround"`;	              
	    setParent ..;        
		$lblPdiSolverHint =`text -label ""   -align "left" `;			              
//    setParent ..;

//    tabLayout -edit
//    	-tabLabel $child1 "Solver Options"
//    	-tabLabel $child2 "Dynamics Properties"
//    $pdiSolverWindowTabs;


//	if( size( $PDISolver) == 0)
//	{
	  //delete the aux solver
//	    print "deleting temporal pdi solver\n";
//		deleteUserNode $thePdiSolver;
//	}
//	else
//	{
    updatePdiSolverPanel();
//	}
}
/****************************************
	PDI MANAGE PANEL
******************************************/
global proc addBodiesToPdiWorld()
{
    global string $pdiBodiesList;

	string  $PDIObjects[];
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;

    if( size( $PDIObjects) == 0)
    {
       warning -noContext "PDi Info: Not Pdi bodies selected";

       return;
    }

	string  $disabledPDIObjects[];
    for( $obj in $PDIObjects)
    {
		int $enabled = getAttr ($obj + ".enabled" );
        if( $enabled == 0)
        {
            $disabledPDIObjects[size($disabledPDIObjects)]= $obj;
        }
    }
	if( size($disabledPDIObjects) > 0)
	{
    ManagePdiListCmd -add true $disabledPDIObjects;

    int $i;
    for ( $i=0; $i < size($disabledPDIObjects); $i++ )
	{
        textScrollList -edit -append $disabledPDIObjects[$i] $pdiBodiesList;
    }
    updatePdiManagePanel();
}
}
global proc deleteBodiesFromPdiWorld()
{
    global string $pdiBodiesList;
	int $NumSingleRigidBodyDeleted=0;
    string $selection[];
    $selection = `textScrollList -query -selectItem $pdiBodiesList`;

	if( size($selection) == 0)
	{
		return;
	}

	$NumSingleRigidBodyDeleted=size($selection);
	string $result="Yes";

	if( size($selection) > 1)
	{
		 $result = `confirmDialog -title "Confirm" -message "This action will destroy selected Pdi nodes, are you sure?"
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`;
	}

    if( $result == "Yes")
    {
		undoInfo -swf off;

		//delete selected active rigid bodies

        ManagePdiListCmd $selection;

        int $i;
        for ( $i=0; $i < size($selection); $i++ )
	    {
            textScrollList -edit -removeItem $selection[$i] $pdiBodiesList;
        }

    	for ( $obj in $selection )
	    {
//            deleteUserNode $obj;
            delete $obj;
        }

		//delete selected disabled rigid bodies

		string $PDISelBodies[] = `ls -selection -dag -leaf -type pdiRigidBody`;
    	for ( $obj in $PDISelBodies )
		{                
            $connections = `listConnections -d off -s on ($obj +".fracture")`;

            if( size($connections)==0 )
            {
		    	int $enabled = getAttr ($obj + ".enabled" );
	            if(  $enabled == 0 )
		        {  
					$NumSingleRigidBodyDeleted++;
				delete $obj;
			}
        }
        }

		if( $NumSingleRigidBodyDeleted==0)
		{
			warning -noContext "no single rigid bodies found in selection";
		}
		else
		{
			print( $NumSingleRigidBodyDeleted + " single rigid bodies deleted\n");
		}

	    undoInfo -swf on;
		updatePdiManagePanel();
		updatePdiBodyPanel();
    }
}
global proc deleteAllPdiEntities()
{
    string $result = `confirmDialog -title "Confirm" -message "this action will prevent forever to apply Pdi jaggyness to fragments,are you sure?"
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`;

    if( $result == "Yes")
    {
	    undoInfo -swf off;
	    waitCursor -state on;

        //collect voronoi nodes
   	    string $PDIFragments[];
    	 string  $VoroObjects[];
	     $VoroObjects = `ls -dag -leaf -type "pdiVoronoiNode"`;
	     print $VoroObjects;
    	 for ( $obj in $VoroObjects )
	     {
            $transform = `listRelatives -parent $obj`;
			$ShatterGroup = `listRelatives -parent $transform[0]`;

			//delete voronoi node
            delete $obj;
            delete $transform;

			//delete history of pdi fragments
			 $PDIFragments=`listRelatives  -typ "transform" $ShatterGroup`;
			 //print ( "\n" );
			 //print $PDIFragments;
			 
	    	 for ( $node in $PDIFragments )
		     {
		         $childs=`listRelatives -typ "transform" $node`;
		         if( size($childs)>0)
		         {
				    //looks like the fragment has been recomputed			 			
					$shapes=`listRelatives  -path -ni -typ "mesh" $node`;
					if( size($shapes)>0)
					{
						// delete hidden geo
						int $visible = `getAttr ( $shapes[0] + ".visibility" )`;		         				
						if( $visible==0)delete $shapes[0];
					}
				}
//			    print ("delete history fragment" + $obj + "\n");			 	
				delete -ch $node;
         }
         }

		 // delete shatter locators if any
		 string $shatterLocator[] = `ls  -dag -type "ShatterLocator"`;
    	 for ( $obj in $shatterLocator )
	     {
			delete $obj;
		 }

    	 string  $pdiSolver[]=`ls -type pdiSolverNode`;
		 if( size($pdiSolver) > 0 )
		 {
			deleteUserNode $pdiSolver[0];
		 }
    
	    waitCursor -state off;
		undoInfo -swf on;    

		updatePdiManagePanel();
	}	
}
global proc deleteAllBodiesFromPdiWorld()
{
	global string $butDeletePdiHelpers;
	global string $pdiLblPdiGridAsGround;


    string $result = `confirmDialog -title "Confirm" -message "This action will destroy all Pdi rigid and fracture nodes, are you sure?"
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`;

    if( $result == "Yes")
    {
	    undoInfo -swf off;
	    waitCursor -state on;

//        deleteAllPdiFbodies();
    	string  $PDIFbodies[];
	    $PDIFbodies = `ls -type pdiFbodyNode`;
	    
//	    int nfbodies=size( $PDIFbodies);	    
			for ( $obj in $PDIFbodies )
			{
				deletePdiFBody $obj;
			}

    		string  $PDIObjects[];
			$PDIObjects = `ls -dag -leaf -type pdiRigidBody`;
	//	    int nbodies=size( $PDIObjects);

    		for ( $obj in $PDIObjects )
			{
				deleteUserNode $obj;
	//            delete $obj;
			}

			// delete crackers if any
	    	string  $PDICrackers[];
		    $PDICrackers = `ls -dag -leaf -type pdiCracker`;

			select -clear;

    		for ( $obj in $PDICrackers )
			{
				$parent =`listRelatives -p $obj`;
				select -add $parent[0];
				deleteUserNode $obj;
	//			delete $parent;
			}
			//set crackers shapes in a hidden layer so user can recover them
			string $newLayer=`createDisplayLayer  -name "PDICrackersGeo"`;
			setAttr ($newLayer + ".visibility" ) 0;
	  
	    	 string  $pdiSolver[]=`ls -type pdiSolverNode`;
			 if( size($pdiSolver) > 0 )// && size($PDICrackers)==0)
			{
				deleteUserNode $pdiSolver[0];
			}
	    
	
	    button -e -enable true  $butDeletePdiHelpers;		

	    if ( `window -ex winCreatePdiBodies` )
		{                
//			updatePdiBodyPanel();
			updatePdiManagePanel();
		}

	    if ( `window -ex winPdiBasicFractures` )
		{                
			updatePdiFracturesPanel();
		}

        print( "PDI info: all PDI bodies has been deleted");	    
		undoInfo -swf on;
		waitCursor -state off;
    }
}
global proc deleteAllBodiesFromPdiWorldWithoutConfirm()
{
    global string $pdiBodiesList;
	global string $butDeletePdiHelpers;

	undoInfo -swf off;
	waitCursor -state on;

//        deleteAllPdiFbodies();
    string  $PDIFbodies[];
	$PDIFbodies = `ls -type pdiFbodyNode`;	    
//	    int nfbodies=size( $PDIFbodies);
	    
		for ( $obj in $PDIFbodies )
		{
			deletePdiFBody $obj;
		}

	    string  $PDIObjects[];
		$PDIObjects = `ls -dag -leaf -type pdiRigidBody`;
//	    int nbodies=size( $PDIObjects);

		if ( `textScrollList -ex $pdiBodiesList` )
		{
			textScrollList -edit -removeAll $pdiBodiesList;
		}

    	for ( $obj in $PDIObjects )
		{
			deleteUserNode $obj;
//            delete $obj;
		}

		// delete crackers if any
	    string  $PDICrackers[];
		$PDICrackers = `ls -dag -leaf -type pdiCracker`;

    	for ( $obj in $PDICrackers )
		{
			$parent =`listRelatives -p $obj`;
			deleteUserNode $obj;
			delete $parent;
		}
	    
	    	 string  $pdiSolver[]=`ls -type pdiSolverNode`;
			 if( size($pdiSolver) > 0 )// && size($PDICrackers)==0)
			 {
				deleteUserNode $pdiSolver[0];
			 }
	
	button -e -enable true  $butDeletePdiHelpers;		

	if ( `window -ex winPdiBasicFractures` )
	{                
		updatePdiFracturesPanel();
	}

	if ( `window -ex winCreatePdiBodies` )
	{                
		updatePdiManagePanel();
	}

	if ( `window -ex pdiCrakersWin` )
	{                
		updatePdiCrackersPanel();
	}

	undoInfo -swf on;
	waitCursor -state off;
	updatePdiManagePanel();
}

global proc toggleShowDisabledRigidBodies()
{
 	global string $PDIdisabledRbds[];
	int $numDisabledSingleBodies = size( $PDIdisabledRbds);

	if( $numDisabledSingleBodies ==0)
	{
		print( "No disabled rigid bodies found in this scene\n");
	}
	else
	{
		select -clear;
		string $transformNode[]=`listRelatives -p $PDIdisabledRbds[0]`;
		int $visible = `getAttr ( $transformNode[0] + ".visibility" )`;
		
		if( $visible == 0)
		{
			showHidden -a  $PDIdisabledRbds;
			for ( $obj in $PDIdisabledRbds )
			{
				string $transformNode[]=`listRelatives -p $obj`;
				select -add $transformNode[0];
			}

		}
		else
		{
			for ( $obj in $PDIdisabledRbds )
			{
				string $transformNode[]=`listRelatives -p $obj`;
				hide $transformNode[0];
			}
		}
	}
}

global proc removeAllBodiesFromPdiWorld()
{
    global string $pdiBodiesList;

    string $selection[];
    $selection = `textScrollList -query -allItems $pdiBodiesList`;

    ManagePdiListCmd -add false $selection;

    int $i;
    for ( $i=0; $i < size($selection); $i++ )
	{
        textScrollList -edit -removeItem $selection[$i] $pdiBodiesList;
    }

//    textScrollList -removeAll $pdiBodiesList;

	updatePdiManagePanel();
}

global proc removeBodiesFromPdiWorld()
{
    global string $pdiBodiesList;

    string $selection[];
    $selection = `textScrollList -query -selectItem $pdiBodiesList`;

	if( size( $selection) > 0)
	{
    ManagePdiListCmd $selection;

    int $i;
    for ( $i=0; $i < size($selection); $i++ )
	{
        textScrollList -edit -removeItem $selection[$i] $pdiBodiesList;
    }
	 updatePdiManagePanel();
}
	else
	{
		warning -noContext " no active single rigid bodies found on selection";
	}
}
global proc updateSelectedPdiManagePanel()
{
//    global string $pdiCreateBodyWindow;
   global string $pdiBodiesList;
	global	string  $PDIdisabledRbds[];
	global string $butDeleteSelRbd;

    int $bWExist = `window -ex winCreatePdiBodies`;
    int $bListExist  = `textScrollList -ex $pdiBodiesList`;//the window ex flag seem doesnt work
    if( $bWExist == false || $bListExist == false)
    {
//		print("pidBodyPanel iconified, abort\n");			
        return;
    }

	//deselect last selected
	string $pdiLastSelectedRbds[] = `textScrollList -query -selectItem $pdiBodiesList`;

    for ( $obj in $pdiLastSelectedRbds )
    {
	    setAttr ($obj + ".selected" ) 0;
        //force update 
        getAttr ($obj + ".ca_selected" );            
    }    
	clear( $pdiLastSelectedRbds);
	
	//deselect all disabled bodies
    for ( $obj in $PDIdisabledRbds )
    {
	    setAttr ($obj + ".selected" ) 0;
        //force update 
        getAttr ($obj + ".ca_selected" );            
    }    

	string  $PDIRbdSelected[];
    $PDIRbdSelected = `ls -selection -leaf -type pdiRigidBody`;
    if( size($PDIRbdSelected)==0 )
    {
		string $TRSnodes[] = `ls -selection  -type transform`;
		for ( $obj in $TRSnodes )
		{
			string $PDInode[] =`listRelatives -type pdiRigidBody $obj`;
			if( size($PDInode) > 0)
				$PDIRbdSelected[size($PDIRbdSelected)]=$PDInode[0];
		}
	}

        textScrollList -edit -deselectAll $pdiBodiesList;
    for ( $obj in $PDIRbdSelected )
        {
    		int $enabled = getAttr ($obj + ".enabled" );
            $connections = `listConnections -d off -s on ($obj +".fracture")`;

        if( size($connections)==0 )
            {
		   // is a single rigid body
		    setAttr ($obj + ".selected" ) 1;
		    //force update 
			getAttr ($obj + ".ca_selected" );            

			if(  $enabled > 0 )
                textScrollList -edit -selectItem $obj $pdiBodiesList;
            }
        }

	if(size($PDIRbdSelected) > 0)
	{
		button -e -enable true $butDeleteSelRbd;
	}
	else
	{
		button -e -enable false $butDeleteSelRbd;
	}

	clear( $PDIRbdSelected);
}
global proc selectNegativeMassobjects()
{
	string  $PDIObjects[];
	$PDIObjects = `ls -dag -leaf -type pdiRigidBody`;
    if( size($PDIObjects) > 0)
    {
	    int $i=0;
	    string $dynamicSelection[];	   
		for( $obj in $PDIObjects)
	    {
	        int $isMassNegative =`queryPdiBody -imn  $obj`;
		    if( $isMassNegative > 0 )
		    {
				string $parentobject[] =`listRelatives -p $obj`;		    
			    $dynamicSelection[$i] = $parentobject[0];$i++;
			}
		}
		int $nSelected=size($dynamicSelection);
		if( $nSelected > 0)
		{
			select $dynamicSelection;
			print("Found " + $nSelected + " Pdi bodies non-solid\n");
		}		
		else
		{
			print(" PDi Scene is clean of non-solid objects\n");					
		}		
	}	
	else
	{
      print(" PDi scene is empty, nothing to check\n");		
	}	
}
global proc updatePdiManagePanel()
{
    global string $pdiCreateBodyWindow;
    global string $pdiBodiesList;
	global string $pdiLblNumActiveSingleBodies;
	global string $pdiLblNumDisabledSingleBodies;
	global string $pdiLblNumFragments;
	global string $pdiLblPdiGridAsGround;
	global string $butDeleteAllNodes;
	global string $butDeletePdiHelpers;
	global string $PDIdisabledRbds[];
	global int $VerbosePDIOutput;

    int $bWExist = `window -ex winCreatePdiBodies`;
    int $bLstExist  = `textScrollList -ex $pdiBodiesList`;//the window ex flag seem doesnt work
    if( $bWExist == false || $bLstExist == false)
    {
//		print("pdiManageWindow iconified, abort\n");			
        return;
    }

	clear( $PDIdisabledRbds);

	textScrollList -edit -removeAll $pdiBodiesList;

	string  $PDIObjects[];
	$PDIObjects = `ls -dag -leaf -type pdiRigidBody`;
    
	if(size($PDIObjects) > 0)
	{
        string  $connections[];

		$pdiUpdate = 0;//disable update		

//        print( "creating list..");
        //int $n = size($PDIObjects);
        //textScrollList -edit -numberOfRows $n $pdiBodiesList;

		int $numActiveSingleBodies = 0;
		int $numDisabledSingleBodies = 0;
		int $numPdiFragments = 0;
    	for ( $obj in $PDIObjects )
	    {
    		int $enabled = getAttr ($obj + ".enabled" );
            $connections = `listConnections -d off -s on ($obj +".fracture")`;

            if( size($connections)==0 )
            {
				if( $enabled > 0)
				{
					textScrollList -edit -append $obj $pdiBodiesList;
					$numActiveSingleBodies++;
				}
				else
				{
					$PDIdisabledRbds[size($PDIdisabledRbds)]=$obj;
					$numDisabledSingleBodies++;
				}
            }
			else
			{
				$numPdiFragments++;
			}			
        }
		string $message = ($numActiveSingleBodies +  " active Single Rigid Bodies");
		text -e -label $message $pdiLblNumActiveSingleBodies;

		$message = ($numDisabledSingleBodies +  " disabled Single Rigid Bodies");
		text -e -label $message $pdiLblNumDisabledSingleBodies;

		$message = ($numPdiFragments +  " Fragments Bodies");
		text -e -label $message $pdiLblNumFragments;

	 	button -e -enable true $butDeleteAllNodes;			
		button -e -enable false $butDeletePdiHelpers;			

        //select the objects selected 
        updateSelectedPdiManagePanel();

		$pdiUpdate = 1;//enable update			
    }
    else
	{
		string $message = ("0 active Single Rigid Bodies");
		text -e -label $message $pdiLblNumActiveSingleBodies;
		$message = ("0 disabled Single Rigid Bodies");
		text -e -label $message $pdiLblNumDisabledSingleBodies;
		$message = ("0 Fragments Bodies");
		text -e -label $message $pdiLblNumFragments;

    	 string  $pdiSolver[]=`ls -type pdiSolverNode`;
    	 string  $VoroObjects[];
	     $VoroObjects = `ls -dag -leaf -type "pdiVoronoiNode"`;
     	 string  $PDICrackers[];
 	     $PDICrackers = `ls -dag -leaf -type pdiCracker`;

		 
		 	
//crackers arent deleted as rigid bodies but as pdi entities
//		 if( size( $PDICrackers) > 0)
//		 {
//	 		button -e -enable true $butDeleteAllNodes;			
//			button -e -enable false  $butDeletePdiHelpers;			
//			if( $VerbosePDIOutput)		
//				print( "Pdi Info: there are pdi Cracker objects on scene\n");	    
//		 }
//		 else
		 if( size($VoroObjects) > 0 || size($pdiSolver) > 0  || size( $PDICrackers) > 0)
		 {
	 		button -e -enable false $butDeleteAllNodes;			
			button -e -enable true  $butDeletePdiHelpers;			
			if( $VerbosePDIOutput)				
	         print( "Pdi Info: there are still pdi helper objects on scene\n");	    
		 }
		 else			 	
		 {
	 		button -e -enable false $butDeleteAllNodes;			
			button -e -enable false  $butDeletePdiHelpers;			
			if( $VerbosePDIOutput)
				print( "Pdi Info: all dependencies with Pdi plugin have been removed\n");	    
		 }
	}	 

	//check grid as ground exist
	string $pdiSolver[]=`ls -type pdiSolverNode`;
	if( size($pdiSolver) >0)
	{
		int $gridAsGround = getAttr ($pdiSolver[0] + ".useGroundGrid" );

		if( $gridAsGround==1)
		{
			string $message = ("Maya grid as ground enabled");
			text -e -label $message $pdiLblPdiGridAsGround;		
		 	button -e -enable true $butDeleteAllNodes;							
		}
		else
		{
			string $message = ("Maya grid as ground disabled");
			text -e -label $message $pdiLblPdiGridAsGround;			
		}	
	}
	else
	{
		string $message = ("Maya grid as ground disabled");
		text -e -label $message $pdiLblPdiGridAsGround;			
	}	
		 
	$VerbosePDIOutput=0;		 

    showWindow $pdiCreateBodyWindow;
}

/****************************************
	PDI PPTIES PANEL
******************************************/
global proc setPptyPdiFriction()
{
   global string $fieldPdiFriction;
    global int $pdiUpdate;
	if( $pdiUpdate == false)
	{
		return;	
	}	

    float $friction = `floatSliderGrp -query -value $fieldPdiFriction`;

	string  $PDIObjects[];
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;

    if( size( $PDIObjects) == 0)
    {
       warning -noContext "Pdi Info: Not Pdi bodies selected";

	   return;
    }

	$connections = `listConnections -type pdiFbodyNode $PDIObjects[0]`;
	if( size($connections) > 0)
	{		    
		$transform = `listRelatives -p $PDIObjects[0]`;  
		string $msg = ($transform[0] + " belong to a fracture body." + ", use fracture options to modify it state");
		confirmDialog
		-title "Pdi Info"
		-message $msg
		-button "OK" 
		-defaultButton "OK" ;
			
		return;			 	
	}

	for ( $obj in $PDIObjects )
	{
		setAttr ($obj + ".friction" ) $friction;
        setAttr ($obj + ".usercommand" ) true;
        //force update
        getAttr ($obj + ".ca_rigidBodyParam" );                
    }

}
global proc setPptyPdiBounciness()
{
    global string $fieldPdiBounciness;
    global int $pdiUpdate;
	if( $pdiUpdate == false)
	{
		return;	
	}	

    float $bounciness = `floatSliderGrp -query -value $fieldPdiBounciness`;

	string  $PDIObjects[];
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;

    if( size( $PDIObjects) == 0)
    {
       warning -noContext "PDI Info: Not Pdi bodies selected";

	   return;
    }

	$connections = `listConnections -type pdiFbodyNode $PDIObjects[0]`;
	if( size($connections) > 0)
	{		    
		$transform = `listRelatives -p $PDIObjects[0]`;  
		string $msg = ($transform[0] + " belong to a fracture body." + ", use fracture options to modify it state");
		confirmDialog
		-title "Pdi Info"
		-message $msg
		-button "OK" 
		-defaultButton "OK" ;
			
		return;			 	
	}


	for ( $obj in $PDIObjects )
	{
		setAttr ($obj + ".bounciness" ) $bounciness;
        setAttr ($obj + ".usercommand" ) true;
        //force update
        getAttr ($obj + ".ca_rigidBodyParam" );                
        
    }
}
global proc setPptyPdiLdamping()
{
    global string $fieldPdiLdamping;
    global int $pdiUpdate;
	if( $pdiUpdate == false)
	{
		return;	
	}	

    float $ldamping = `floatSliderGrp -query -value $fieldPdiLdamping`;

	string  $PDIObjects[];
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;

    if( size( $PDIObjects) == 0)
    {
       warning -noContext "PDI Info:Not Pdi bodies selected";

	   return;
    }

	$connections = `listConnections -type pdiFbodyNode $PDIObjects[0]`;
	if( size($connections) > 0)
	{		    
		$transform = `listRelatives -p $PDIObjects[0]`;  
		string $msg = ($transform[0] + " belong to a fracture body." + ", use fracture options to modify it state");
		confirmDialog
		-title "Pdi Info"
		-message $msg
		-button "OK" 
		-defaultButton "OK" ;
			
		return;			 	
	}


	for ( $obj in $PDIObjects )
	{
		setAttr ($obj + ".linearDamping" ) $ldamping;
        setAttr ($obj + ".usercommand" ) true;
        //force update
        getAttr ($obj + ".ca_rigidBodyParam" );                
    }
}
global proc setPptyPdiAdamping()
{
    global string $fieldPdiAdamping;
    global int $pdiUpdate;
	if( $pdiUpdate == false)
	{
		return;	
	}	

    float $adamping = `floatSliderGrp -query -value $fieldPdiAdamping`;

	string  $PDIObjects[];
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;

    if( size( $PDIObjects) == 0)
    {
       warning -noContext "PDI Info: Not Pdi bodies selected";

	   return;
    }

	$connections = `listConnections -type pdiFbodyNode $PDIObjects[0]`;
	if( size($connections) > 0)
	{		    
		$transform = `listRelatives -p $PDIObjects[0]`;  
		string $msg = ($transform[0] + " belong to a fracture body." + ", use fracture options to modify it state");
		confirmDialog
		-title "Pdi Info"
		-message $msg
		-button "OK" 
		-defaultButton "OK" ;
			
		return;			 	
	}

	for ( $obj in $PDIObjects )
	{
		setAttr ($obj + ".angularDamping" ) $adamping;
        setAttr ($obj + ".usercommand" ) true;
        //force update
        getAttr ($obj + ".ca_rigidBodyParam" );                
    }
}
global proc setPptyPdiMass()
{
    global string $fieldPdiMass;
    global int $pdiUpdate;
	if( $pdiUpdate == false)
	{
		return;	
	}	

    float $mass = `floatFieldGrp -query -value1 $fieldPdiMass`;

	string  $PDIObjects[];
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;

    if( size( $PDIObjects) == 0)
    {
       warning -noContext "PDI Info: Not Pdi bodies selected";

	   return;
    }

	$connections = `listConnections -type pdiFbodyNode $PDIObjects[0]`;
	if( size($connections) > 0)
	{		    
		$transform = `listRelatives -p $PDIObjects[0]`;  
		string $msg = ($transform[0] + " belong to a fracture body." + ", use fracture options to modify it state");
		confirmDialog
		-title "Pdi Info"
		-message $msg
		-button "OK" 
		-defaultButton "OK" ;
			
		return;			 	
	}


	for ( $obj in $PDIObjects )
	{
		setAttr ($obj + ".mass" ) $mass;
        setAttr ($obj + ".usercommand" ) true;
        //force update
        getAttr ($obj + ".ca_rigidBodyParam" );                
    }
}
global proc setPptyPdiCenterMass()
{
   global string $fieldPdiCenterMass;
    global int $pdiUpdate;
	if( $pdiUpdate == false)
	{
		return;	
	}	

    float $cx = `floatFieldGrp -query -value1 $fieldPdiCenterMass`;
    float $cy = `floatFieldGrp -query -value2 $fieldPdiCenterMass`;
    float $cz = `floatFieldGrp -query -value3 $fieldPdiCenterMass`;

	string  $PDIObjects[];
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;

    if( size( $PDIObjects) == 0)
    {
       warning -noContext "PDI Info: Not Pdi bodies selected";

	   return;
    }

	$connections = `listConnections -type pdiFbodyNode $PDIObjects[0]`;
	if( size($connections) > 0)
	{		    
		$transform = `listRelatives -p $PDIObjects[0]`;  
		string $msg = ($transform[0] + " belong to a fracture body." + ", use fracture options to modify it state");
		confirmDialog
		-title "Pdi Info"
		-message $msg
		-button "OK" 
		-defaultButton "OK" ;
			
		return;			 	
	}


    string $PDISolver[]=`ls -type pdiSolverNode`;
	if( size( $PDISolver) == 0)
	{
		return;//sover not found,error 
	}

    int $startTime= getAttr ($PDISolver[0] + ".startFrame" );
	int $currrentTime =`currentTime -query`; 
	if( $currrentTime > $startTime)
	{
		warning -noContext " go to start frame to change centre mass";        		
		updatePdiPropertiesPanel();
		return;
	}		 	


	for ( $obj in $PDIObjects )
	{
        setAttr ($obj + ".massCenter" ) -type "float3" $cx $cy $cz;
        //force update
        getAttr ($obj + ".ca_centerMass" );                        
    }

//    updatePdiPropertiesPanel();

}
global proc setPptyPdiVelocity()
{
   global string $fieldPdiVelocity;
    global string $fieldPdiRandomV;
    //global int $rvx;
    //global int $rvy;
    //global int $rvz;

    global int $pdiUpdate;
	if( $pdiUpdate == false)
	{
		return;	
	}	

    float $vx0 = `floatFieldGrp -query -value1 $fieldPdiVelocity`;
    float $vy0 = `floatFieldGrp -query -value2 $fieldPdiVelocity`;
    float $vz0 = `floatFieldGrp -query -value3 $fieldPdiVelocity`;

    int $rvx = `intFieldGrp -query -value1 $fieldPdiRandomV`;
    int $rvy = `intFieldGrp -query -value2 $fieldPdiRandomV`;
    int $rvz = `intFieldGrp -query -value3 $fieldPdiRandomV`;

    seed 7718;

	string  $PDIObjects[];
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;

    if( size( $PDIObjects) == 0)
    {
       warning -noContext "No Pdi bodies selected";

	   return;
    }

	$connections = `listConnections -type pdiFbodyNode $PDIObjects[0]`;
	if( size($connections) > 0)
	{		    
		$transform = `listRelatives -p $PDIObjects[0]`;  
		string $msg = ($transform[0] + " belong to a fracture body." + ", use fracture options to modify it state");
		confirmDialog
		-title "Pdi Info"
		-message $msg
		-button "OK" 
		-defaultButton "OK" ;
			
		return;			 	
	}


	for ( $obj in $PDIObjects )
	{
        float $vx = $vx0; 
        float $vy = $vy0; 
        float $vz = $vz0; 

        float $rnd = `rand 1`;
        if( $rvx > 0.0)
        {
            float $randFactorX = $rnd * (2.0*$rvx) - $rvx;
            $vx += $vx*($randFactorX/100.0);
        }    
        if( $rvy > 0.0)
        {
            float $randFactorY = $rnd * (2.0*$rvy) - $rvy;
            $vy += $vy*($randFactorY/100.0);
        }    
        if( $rvz > 0.0)
        {
            float $randFactorZ = $rnd * (2.0*$rvz) - $rvz;
            $vz += $vz*($randFactorZ/100.0);
        }    

        setAttr ($obj + ".initialVelocity" ) -type "float3" $vx $vy $vz;
        setAttr ($obj + ".randomVX" )  $rvx;
        setAttr ($obj + ".randomVY" )  $rvy;
        setAttr ($obj + ".randomVZ" )  $rvz;

        //force update
        getAttr ($obj + ".caiv" );
    }

//    updatePdiPropertiesPanel();

}
global proc setPptyPdiWelocity()
{
   global string $fieldPdiWelocity;
   global string $fieldPdiRandomW;

    global int $pdiUpdate;
	if( $pdiUpdate == false)
	{
		return;	
	}	

    float $vx0 = `floatFieldGrp -query -value1 $fieldPdiWelocity`;
    float $vy0 = `floatFieldGrp -query -value2 $fieldPdiWelocity`;
    float $vz0 = `floatFieldGrp -query -value3 $fieldPdiWelocity`;

    int $rwx = `intFieldGrp -query -value1 $fieldPdiRandomW`;
    int $rwy = `intFieldGrp -query -value2 $fieldPdiRandomW`;
    int $rwz = `intFieldGrp -query -value3 $fieldPdiRandomW`;

    seed 7718;

	string  $PDIObjects[];
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;

    if( size( $PDIObjects) == 0)
    {
       warning -noContext "No Pdi bodies selected";

	   return;
    }

	$connections = `listConnections -type pdiFbodyNode $PDIObjects[0]`;
	if( size($connections) > 0)
	{		    
		$transform = `listRelatives -p $PDIObjects[0]`;  
		string $msg = ($transform[0] + " belong to a fracture body." + ", use fracture options to modify it state");
		confirmDialog
		-title "Pdi Info"
		-message $msg
		-button "OK" 
		-defaultButton "OK" ;
			
		return;			 	
	}


	for ( $obj in $PDIObjects )
	{
        float $vx = $vx0; 
        float $vy = $vy0; 
        float $vz = $vz0; 

        float $rnd = `rand 1`;
        if( $rwx > 0.0)
        {
            float $randFactorX = $rnd * (2.0*$rwx) - $rwx;
            $vx += $vx*($randFactorX/100.0);
        }    
        if( $rwy > 0.0)
        {
            float $randFactorY = $rnd * (2.0*$rwy) - $rwy;
            $vy += $vy*($randFactorY/100.0);
        }    
        if( $rwz > 0.0)
        {
            float $randFactorZ = $rnd * (2.0*$rwz) - $rwz;
            $vz += $vz*($randFactorZ/100.0);
        }    

        setAttr ($obj + ".initialSpin" ) -type "float3" $vx $vy $vz;
        setAttr ($obj + ".randomWX" )  $rwx;
        setAttr ($obj + ".randomWY" )  $rwy;
        setAttr ($obj + ".randomWZ" )  $rwz;

        //force update
        getAttr ($obj + ".caiw" );

    }

//    updatePdiPropertiesPanel();

}
global proc setPptyPdiMayaFields()
{
    global string $butPdiForceFieldList;
    global string $chkPdiMayaFields;

    global int $pdiUpdate;
	if( $pdiUpdate==0)
	{
		return;	
	}	

    $state = `checkBox -query -value $chkPdiMayaFields`;

	string  $PDIObjects[];
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;
    if( size($PDIObjects) == 0)
    {
       warning -noContext "No Pdi bodies selected";

		return;    
	}

	$connections = `listConnections -type pdiFbodyNode $PDIObjects[0]`;
	if( size($connections) > 0)
	{		    
		$transform = `listRelatives -p $PDIObjects[0]`;  
		string $msg = ($transform[0] + " belong to a fracture body." + ", use fracture options to modify it state");
		confirmDialog
		-title "Pdi Info"
		-message $msg
		-button "OK" 
		-defaultButton "OK" ;
			
		return;			 	
	}

	for ( $obj in $PDIObjects )
	{
        setAttr ($obj + ".affectForceFields" ) $state;
         //force update
        getAttr ($obj + ".ca_forceFields" );
    }


    string  $forceFields[];
    if( $state == true)
    {
        $forceFields = `ls -tr -dag -leaf`;//note this includes all transform nodes in scene
    }

    for( $obj in $PDIObjects)
    {
        pdiConnectForceFields -bodyName $obj -connect $forceFields;
    }

//    updatePdiPropertiesPanel();

}
global proc setPptyPdiGapFactor()
{
    global string $fieldPdiGapFactor;
    global int $pdiUpdate;
	if( $pdiUpdate == false)
	{
		return;	
	}	

    float $gapfactor = `floatSliderGrp -query -value $fieldPdiGapFactor`;

	string  $PDIObjects[];
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;

    if( $gapfactor > 0.25)
    {
        warning -noContext " This gap value can cause unstabilities";
    }
    else
    {
        print (" ");
    }

    if( size( $PDIObjects) == 0)
    {
        warning -noContext "no Pdi bodies selected";
    }

	for ( $obj in $PDIObjects )
	{
		setAttr ($obj + ".gapfactor" ) $gapfactor;
        setAttr ($obj + ".usercommand" ) true;
    }
}

global proc pdiIncludeField()
{
    global string $pdiExludedFieldsList;
    global string $pdiIncludedFieldsList;

    string $selection[];
    $selection = `textScrollList -query -selectItem $pdiExludedFieldsList`;

    for ( $obj in $selection)
	{
        textScrollList -edit -append $obj $pdiIncludedFieldsList;
        textScrollList -edit -removeItem $obj $pdiExludedFieldsList;
    }
}

global proc pdiExcludeField()
{
    global string $pdiExludedFieldsList;
    global string $pdiIncludedFieldsList;

    string $selection[];
    $selection = `textScrollList -query -selectItem $pdiIncludedFieldsList`;

    for ( $obj in $selection)
	{
        textScrollList -edit -removeItem $obj $pdiIncludedFieldsList;
        textScrollList -edit -append $obj $pdiExludedFieldsList;
    }
}
global proc pdiAcceptFields()
{
    global string $pdiIncludedFieldsList;

    string  $forceFields[];
    $forceFields = `textScrollList -query -allItems $pdiIncludedFieldsList`;

	string  $PDIObjects[];
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;

    for( $obj in $PDIObjects)
    {
        pdiConnectForceFields -bodyName $obj -connect $forceFields;
    }

    layoutDialog -dismiss "OK";
}

global proc pdiExcludeIncludeForceFields()
{
    warning -noContext "PDI Info: This feature is not included in demo version\n";
}
global proc updatePdiPropertiesPanel()
{
   global string $pdiCreateBodyWindow;
   global string $chkPdiMayaFields;
   global string $fieldPdiFriction;
   global string $fieldPdiBounciness;
   global string $fieldPdiLdamping;
   global string $fieldPdiAdamping;
   global string $fieldPdiGapFactor;
   global string $fieldPdiGapFactor;
   global string $fieldPdiMass;
   global string $fieldPdiCenterMass;
   global string $fieldPdiVelocity;
   global string $fieldPdiWelocity;
   global string $fieldPdiRandomV;
   global string $fieldPdiRandomW;
   global string $butPdiForceFieldList;
   global string $ChkPdiPassive;    

   global int $pdiUpdate;

    int $bWExist = `window -ex winCreatePdiBodies`;
    int $bFieldExist  = `floatFieldGrp -ex $fieldPdiMass`;//the window ex flag seem doesnt work
    if( $bWExist == false || $bFieldExist == false)
    {
//		print("pidBodyPanel iconified, abort\n");			
        return;
    }
	string  $PDIObjects[];
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;
//    print "pdi objects update  ppties\n";
	if(size($PDIObjects) != 0)
	{
		$pdiUpdate = 0;//disable update					

        string $selectedObject = $PDIObjects[0];
        //select a dynamics objects if any
        int $passive = 0;
        for( $obj in $PDIObjects)
        {
            $selectedObject = $obj;
    		$passive = getAttr ($obj + ".passive" );
            if( $passive == 0)
            {
                break;
            }
        }
		int $frstHitActive = getAttr ($PDIObjects[0] + ".firstHitActive" );
                
        float $mass = getAttr ($selectedObject + ".mass" );
        int $mayaFieldsValue = getAttr ($selectedObject + ".affectForceFields" );
        float $friction = getAttr ($selectedObject + ".friction" );
        float $bounciness = getAttr ($selectedObject + ".bounciness" );
        float $ldamping = getAttr ($selectedObject + ".linearDamping" );
        float $adamping = getAttr ($selectedObject + ".angularDamping" );
        float $gapfactor = getAttr ($selectedObject + ".gapfactor" );
        vector $masscenter = getAttr ($selectedObject + ".massCenter" );
        vector $velocity = getAttr ($selectedObject + ".initialVelocity" );
        vector $welocity = getAttr ($selectedObject + ".initialSpin" );
        int $rvx = getAttr ($selectedObject + ".randomVX" );
        int $rvy = getAttr ($selectedObject + ".randomVY" );
        int $rvz = getAttr ($selectedObject + ".randomVZ" );
        int $rwx = getAttr ($selectedObject + ".randomWX" );
        int $rwy = getAttr ($selectedObject + ".randomWY" );
        int $rwz = getAttr ($selectedObject + ".randomWZ" );

        checkBox -edit -value $mayaFieldsValue $chkPdiMayaFields;
        floatSliderGrp -edit -value $friction $fieldPdiFriction;
        floatSliderGrp -edit -value $bounciness $fieldPdiBounciness;
        floatSliderGrp -edit -value $ldamping $fieldPdiLdamping;
        floatSliderGrp -edit -value $adamping $fieldPdiAdamping;
        floatSliderGrp -edit -value $gapfactor $fieldPdiGapFactor;
        if( $gapfactor > 0.25)
        {
            warning -noContext " This gap value can cause unstabilities";
        }
        floatFieldGrp  -edit -value1 $mass $fieldPdiMass;
        floatFieldGrp  -edit
            -value1 ($masscenter.x)
            -value2 ($masscenter.y)
            -value3 ($masscenter.z)
            $fieldPdiCenterMass;
        floatFieldGrp  -edit
            -value1 ($velocity.x)
            -value2 ($velocity.y)
            -value3 ($velocity.z)
            $fieldPdiVelocity;
        floatFieldGrp  -edit
            -value1 ($welocity.x)
            -value2 ($welocity.y)
            -value3 ($welocity.z)
            $fieldPdiWelocity;
        intFieldGrp  -edit
            -value1 $rvx
            -value2 $rvy
            -value3 $rvz
            $fieldPdiRandomV;
        intFieldGrp  -edit
            -value1 $rwx
            -value2 $rwy
            -value3 $rwz
            $fieldPdiRandomW;

	    if( $passive > 0 && $frstHitActive == 0)
	    {
			checkBox -edit -enable 0 $chkPdiMayaFields;
			floatSliderGrp -edit -enable 0 $fieldPdiLdamping;
			floatSliderGrp -edit -enable 0 $fieldPdiAdamping;
			floatSliderGrp -edit -enable 0 $fieldPdiGapFactor;	   
	        floatFieldGrp  -edit -enable 0 $fieldPdiMass;	
	        floatFieldGrp  -edit -enable 0 $fieldPdiCenterMass;	
	        floatFieldGrp  -edit -enable 0 $fieldPdiVelocity;	
	        floatFieldGrp  -edit -enable 0 $fieldPdiWelocity;	
	        intFieldGrp  -edit -enable 0 $fieldPdiRandomV;	
	        intFieldGrp  -edit -enable 0 $fieldPdiRandomW;	 	
		}
		else
		{
			checkBox -edit -enable 1 $chkPdiMayaFields;
			floatSliderGrp -edit -enable 1 $fieldPdiLdamping;
			floatSliderGrp -edit -enable 1 $fieldPdiAdamping;
			floatSliderGrp -edit -enable 1 $fieldPdiGapFactor;	   
	        floatFieldGrp  -edit -enable 1 $fieldPdiMass;	
	        floatFieldGrp  -edit -enable 1 $fieldPdiCenterMass;	
	        floatFieldGrp  -edit -enable 1 $fieldPdiVelocity;	
	        floatFieldGrp  -edit -enable 1 $fieldPdiWelocity;	
	        intFieldGrp  -edit -enable 1 $fieldPdiRandomV;	
	        intFieldGrp  -edit -enable 1 $fieldPdiRandomW;	 
		}

		$pdiUpdate = 1;//enable update			
    }

//    showWindow $pdiCreateBodyWindow;    
//	evalDeferred -lp "setFocus MayaWindow";
}
/////////////////////////////////////////////////
//  
//  Bake  Keys  Panels
//
/////////////////////////////////////////////////
global proc bakePdiSimulation()
{
//    global string $pdiBakeSimWindow;
    global string $gMainProgressBar;  // This is defined on maya startup
    global string $fieldPdiKeysThr;
    global string $fieldPdiRotKeysThr;
    global string $fieldPdiSampleBy;
    global string $pdiFBodiesList;
    string $transform[];
    string $pdiSelection[];
	$pdiSelection = `ls -dag -leaf -type pdiRigidBody`;

    string $pdiSolver[]=`ls -type pdiSolverNode`;
	if( size( $pdiSolver) == 0)
	{
	    print " pdi solver is empty, nohing to bake\n";
		return;
	}

    if ( `window -ex winPdiBasicFractures` )
    {               
        //unselect al fracture bodies before baking keys 

        textScrollList -edit -deselectAll $pdiFBodiesList;
        string $allFbodies[]= `textScrollList -query -allItems $pdiFBodiesList`;

        for( $obj in $allFbodies)
        {
            setAttr( $obj + ".selected" ) false;
        }
    }

    int $minTime = `playbackOptions -query -minTime`;
    int $startTime= getAttr ($pdiSolver[0] + ".startFrame" );
    int $endTime = `playbackOptions -query -maxTime`;
    int $simTine = $endTime - $startTime;
    int $pdiCacheModeOn = getAttr ($pdiSolver[0] + ".cachedMode" );
    int $pdiCacheEnabled = getAttr ($pdiSolver[0] + ".cacheActive" );
    
    string $dynamicSelection[];
	int $allowFastBaking=1;

	if( $pdiCacheModeOn)
	{
		//dynamics is cached, bake bodies with cache filled
		for( $obj in $pdiSelection)
		{
			int $enabled = getAttr ($obj + ".enabled" );

			if($enabled > 0)
			{
				int $isCacheOn =`queryPdiBody -ico  $obj`;

				if( $isCacheOn != 0)
				{
					$dynamicSelection[size($dynamicSelection)] = $obj;
				}
			}
		}
	}

	if(size($dynamicSelection)==0)
	{
		//cache isnt present select dynamic bodies
//		$allowFastBaking=0;

		for( $obj in $pdiSelection)
		{
			int $hasKeys = getAttr ($obj + ".hasPdiKeys" );
			if( $hasKeys)continue;

			int $enabled = getAttr ($obj + ".enabled" );
			int $passive = getAttr ($obj + ".passive" );
			int $isFirstHitActive = getAttr ($obj + ".firstHitActive" );

			if($enabled > 0)
			{
				if( $passive != 0)
				{
					if( $isFirstHitActive)
					{
						$dynamicSelection[size($dynamicSelection)] = $obj;
					}
				}
				else
				{
					$dynamicSelection[size($dynamicSelection)] = $obj;
				}
			}
		}
	}

	if(size($dynamicSelection)==0)
	{
        print( "PDI world is empty, nothing to bake");	    
		return;	  
	}

//    dResumeSim $dynamicSelection;// just in case resume simulation

    float $treshold = 0;
    float $treshold2 = 0;
    float $sampleby = 0;

//    $treshold = `floatSliderGrp -query -value $fieldPdiKeysThr`;
//    $treshold2 = `floatSliderGrp -query -value $fieldPdiRotKeysThr`;

    if ( `floatSliderGrp -ex $fieldPdiSampleBy` )
    {                
        $sampleby = `floatSliderGrp -query -value $fieldPdiSampleBy`;
    }

    if( $treshold != 0.0 || $treshold2!=0.0)
    {
        $allowFastBaking=0;
    }

	undoInfo -swf off;
    waitCursor -state on;

	warning -noContext ( "baking PDI simulation, press ESC to cancel.." );

	if( $pdiCacheEnabled==0 ||  $startTime > $minTime)
	{
		//needed reset scene to set initial states
	    currentTime -edit $minTime;
	}

	refresh -suspend true;

    if( $allowFastBaking > 0)
    {
//        print ("Bake PDi fast mode On " +  $startTime + ":" + $endTime + " step =" +  $sampleby + "\n");

//		dgtimer -on -reset;

        currentTime -edit $startTime;

        string $dynamicSelectionTransform[];

        for( $obj in $dynamicSelection)
        {
            string $parentobject[] =`listRelatives -p $obj`;
            $dynamicSelectionTransform[size($dynamicSelectionTransform)] =  $parentobject[0];
        }
        string $timelapse = $startTime +":" + $endTime;
        bakeResults -t $timelapse -sm true -shape false -sb $sampleby 
         -at "translateX" -at "translateY" -at "translateZ"
         -at "rotateX" -at "rotateY" -at "rotateZ"
		  $dynamicSelectionTransform ; 

        clear($dynamicSelectionTransform);

//		dgtimer -off;		
//		dgtimer -q;
    }
    else
    {
        progressBar -edit
        -beginProgress
        -isInterruptable true
        -status "Baking keys..."
        -maxValue $simTine
        $gMainProgressBar;

        print ("Bake PDi fast mode Off" + "\n");
//		print("treshold =" + $treshold + "treshold2 =" + $treshold2 + "\n");	

        float $i=0.0;
//        float $time_sample = 0.25;

        for($i=$startTime; $i <= $endTime; $i+= $sampleby)
        {
//            print ("baking frame.." + $i + "\n");

	        currentTime -edit $i;

            if(`progressBar -query -isCancelled $gMainProgressBar`)
                break;

            progressBar -edit -step 1 $gMainProgressBar;

            int $j;
            for( $j = 0; $j  < size($dynamicSelection); $j++)
            {
    		    int $passive = getAttr ($dynamicSelection[$j] + ".passive" );
        		int $isFirstHitActive = getAttr ($dynamicSelection[$j] + ".firstHitActive" );

                if( $passive > 0 && $isFirstHitActive == 0)// && $isTransitionNode[$j]==0)
                {
                    continue;
                }

                $transform = `listRelatives -parent $dynamicSelection[$j]`;

                if( size( $transform) > 0)
                {
                    //bake translation
	                float  $linX    = `getAttr ($transform[0] + ".translateX")`;
	                float  $linY    = `getAttr ($transform[0] + ".translateY")`;
	                float  $linZ    = `getAttr ($transform[0] + ".translateZ")`;
                                        
//					 string $keytras =  "key tras : " + $linX + " " + $linY + " " + $linZ + "\n";
//                   print $keytras;

	                setKeyframe -shape false -v $linX -at translateX $transform[0];
	                setKeyframe -shape false -v $linY -at translateY $transform[0];
	                setKeyframe -shape false -v $linZ -at translateZ $transform[0];

//                    setAttr ($dynamicSelection[$j] + ".lastPosition" ) -type "float3" $linX $linY $linZ;

                    //bake rotation
	                float  $angleX    = `getAttr ($transform[0] + ".rotateX")`;
	                float  $angleY    = `getAttr ($transform[0] + ".rotateY")`;
	                float  $angleZ    = `getAttr ($transform[0] + ".rotateZ")`;

//                   string $keyrot =  "key rot : " + $angleX + " " + $angleY + " " + $angleZ + "\n";
//                   print $keyrot;

	                setKeyframe -shape false -v $angleX -at rotateX $transform[0];
	                setKeyframe -shape false -v $angleY -at rotateY $transform[0];
	                setKeyframe -shape false -v $angleZ -at rotateZ $transform[0];

//                    setAttr ($dynamicSelection[$j] + ".lastRotation" ) -type "float3" $angleX $angleY $angleZ;
                }
            }
        }

        progressBar -edit -endProgress $gMainProgressBar;
    }
    
    //set pdi keys attribute
    for( $obj in $dynamicSelection)
    {            
        int $passive = getAttr ($obj + ".passive" );
        int $isFirstHitActive = getAttr ($obj + ".firstHitActive" );

        if( $passive > 0 && $isFirstHitActive == 0 )
        {
            continue;
        }

        setAttr ($obj + ".hasPdiKeys" ) true;        

    }

    //diconnect pdi dynamics
    string $time[];
    $time = `ls -type time`;

    disconnectAttr ($time[0] + ".outTime") ($pdiSolver[0] + ".inTime");

    setAttr ($pdiSolver[0] + ".cachedMode" ) false;

	refresh -suspend false;

    //this fail why?
//    string $startCrono = `timerX`;
//    string $totalCrono = `timerX -startTime $startCrono`;
//    string $strTotalCrono = "Total Time Baking: "+$totalCrono+"\n";
//    print $strTotalCrono;

    print ("Pdi simulation is baked, delete all PDI keys to revert to dynamics");
	
    waitCursor -state off;
    undoInfo -swf on;
	flushUndo; //undo after baking keys make maya crash

    confirmDialog
    -title "Pdi Info"
    -message "Pdi dynamics has been disabled, delete all Pdi keys will enable it again"
    -button "OK" 
    -defaultButton "OK" ;
    
    //set playback speed to working units
    evalDeferred -lp "playbackOptions -ps 1";//defered it until bakeResults ends
    
}
global proc bakePdiSelectedOnly()
{
    global string $gMainProgressBar;  // This is defined on maya startup
    global string $fieldPdiKeysThr;
    global string $fieldPdiRotKeysThr;
    global string $fieldPdiSampleBy;
    global string $selectedPdiFbody;
    global string $pdiFBodiesList;

    string $transform[];

    string $pdiSolver[]=`ls -type pdiSolverNode`;
	if( size( $pdiSolver) == 0)
	{
	    print " pdi solver is empty, nohing to bake\n";
		return;
	}


    int $minTime = `playbackOptions -query -minTime`;
    int $startTime= getAttr ($pdiSolver[0] + ".startFrame" );
    int $endTime = `playbackOptions -query -maxTime`;
    int $simTine = $endTime - $startTime;
    int $pdiCacheModeOn = getAttr ($pdiSolver[0] + ".cachedMode" );
    int $pdiCacheEnabled = getAttr ($pdiSolver[0] + ".cacheActive" );
    
	int $allowFastBaking=1;

	string $selectedfractureBodies[];
    string $pdiSelection[];
	{	   
		$pdiSelectedRigidBodies = `ls -selection -dag -leaf -type pdiRigidBody`;
		if( size($pdiSelectedRigidBodies) > 0)
		{
			int $numFbodies=0;
			for( $obj in $pdiSelectedRigidBodies)
			{
	    		string  $connections[]=`listConnections -type pdiFbodyNode $obj`;
				if( size($connections) > 0)
				{
					if( $numFbodies >0 && $selectedfractureBodies[$numFbodies-1] == $connections[0])
					{
						continue;
					}

					$selectedfractureBodies[$numFbodies] =  $connections[0];$numFbodies++;
				}
				else
				{
					$pdiSelection[size($pdiSelection)] = $obj;
				}
			}

			for( $fbody in $selectedfractureBodies)
			{
				string  $connections[] = `listConnections -d on -s off  ($fbody + ".rigidBodies")`;
				for( $obj in $connections)
				{
					string $pdiobject[] =`listRelatives -type pdiRigidBody $obj`;
		
					if( size($pdiobject)>0)
						$pdiSelection[size($pdiSelection)] = $pdiobject[0];				
				}
				$connections = `listConnections -d on -s off  ($fbody + ".clusters")`;
				for( $obj in $connections)
				{
					string  $connections2[] = `listConnections -d on -s off  ($obj + ".rigidBodies")`;
					for( $obj2 in $connections2)
					{
						string $pdiobject[] =`listRelatives -type pdiRigidBody $obj2`;
		
						if( size($pdiobject)>0)
							$pdiSelection[size($pdiSelection)] = $pdiobject[0];				
					}
				}
			}
		}
		else
		if( `objExists $selectedPdiFbody`)
		{	   
			//bake selected fbody
			string  $connections[] = `listConnections -d on -s off  ($selectedPdiFbody + ".rigidBodies")`;
			for( $obj in $connections)
			{
				string $pdiobject[] =`listRelatives -type pdiRigidBody $obj`;
		
				if( size($pdiobject)>0)
					$pdiSelection[size($pdiSelection)] = $pdiobject[0];				
			}
			$connections = `listConnections -d on -s off  ($selectedPdiFbody + ".clusters")`;
			for( $obj in $connections)
			{
				string  $connections2[] = `listConnections -d on -s off  ($obj + ".rigidBodies")`;
				for( $obj2 in $connections2)
				{
					string $pdiobject[] =`listRelatives -type pdiRigidBody $obj2`;
		
					if( size($pdiobject)>0)
						$pdiSelection[size($pdiSelection)] = $pdiobject[0];				
				}
			}
			
			$selectedfractureBodies[0] = $selectedPdiFbody;
		}
	}

    string $dynamicSelection[];

	if( $pdiCacheModeOn)
	{
		//dynamics is cached, bake bodies with cache filled
		for( $obj in $pdiSelection)
		{
			int $enabled = getAttr ($obj + ".enabled" );

			if($enabled > 0)
			{
				int $isCacheOn =`queryPdiBody -ico  $obj`;

				if( $isCacheOn != 0)
				{
					string $parentobject[] =`listRelatives -p $obj`;

					$dynamicSelection[size($dynamicSelection)] = $parentobject[0];
				}
			}
		}
	}

	if(size($dynamicSelection)==0)
	{
		//cache isnt present select dynamic bodies
		for( $obj in $pdiSelection)
		{
			int $enabled = getAttr ($obj + ".enabled" );
			int $passive = getAttr ($obj + ".passive" );
			int $isFirstHitActive = getAttr ($obj + ".firstHitActive" );

			if($enabled > 0)
			{
				string $parentobject[] =`listRelatives -p $obj`;

				if( $passive != 0)
				{
					if( $isFirstHitActive)
					{
						$dynamicSelection[size($dynamicSelection)] =  $parentobject[0];
					}
				}
				else
				{
					$dynamicSelection[size($dynamicSelection)] =  $parentobject[0];
				}
			}
		}
	}
	if(size($dynamicSelection)==0)
	{
        print( "no shatter groups or PDi rigid bodies found in selection, nothing to bake");	    
		return;	  
	}

    //hilight selected fractrure bodies
    for( $obj in $selectedfractureBodies)
    {
		setAttr( $obj + ".selected" ) true;

		//force update
		getAttr ($obj + ".ca_selected" );
    }

	refresh -cv -force;

    string $result = `confirmDialog -title "Confirm" -message "This action will delete the selected rigid and fracture bodies, are you sure?"
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`;

    if( $result == "No")
    {
		//turn off selected fractrure bodies
		for( $obj in $selectedfractureBodies)
		{
			setAttr( $obj + ".selected" ) false;
			//force update
			getAttr ($obj + ".ca_selected" );
		}

        return;
    }

    undoInfo -swf off;
    waitCursor -state on;

    if ( `window -ex winPdiBasicFractures` )
    {               
        //unselect al fracture bodies before baking keys 

        textScrollList -edit -deselectAll $pdiFBodiesList;
        string $allFbodies[]= `textScrollList -query -allItems $pdiFBodiesList`;

        for( $obj in $allFbodies)
        {
            setAttr( $obj + ".selected" ) false;
			//force update
			//getAttr ($obj + ".ca_selected" );
        }
    }

    float $sampleby = 0;
    if ( `floatSliderGrp -ex $fieldPdiSampleBy` )
    {                
        $sampleby = `floatSliderGrp -query -value $fieldPdiSampleBy`;
    }

	refresh -suspend true;

	if( $pdiCacheEnabled==0 ||  $startTime > $minTime)
	{
		//needed reset scene to set initial states
	    currentTime -edit $minTime;
	}
	else
	{
		currentTime -edit $startTime;
	}

	warning -noContext ( "baking PDI simulation, please wait.." );
	//reset scene if cached disabled to set initial states

    string $timelapse = $startTime +":" + $endTime;
    int $bakeResultsresult = `bakeResults -t $timelapse -sm true -shape false -sb $sampleby 
        -at "translateX" -at "translateY" -at "translateZ"
        -at "rotateX" -at "rotateY" -at "rotateZ"
		$dynamicSelection` ; 


	refresh -suspend false;

      print( size($dynamicSelection) + " selected objects has been baked: " + "\n");
//	print( "bakeResults = " + $bakeResultsresult);	    

//	print("baked fracture bodies = " + size($selectedfractureBodies));

	//setDefaultsPdiFbodyParams( $selectedfractureBodies[0]);    

	for( $obj in $selectedfractureBodies)
	{
		if( `objExists $obj`)//list may have duplicated entries
		{
       $result = `deletePdiFBody -db $obj`;
	}
	}
	
	//delete any rigid body baked which left
	$pdiSelection = `ls -selection -dag -leaf -type pdiRigidBody`;
	for( $obj in $pdiSelection)
	{
// clean before delete?
//		disconnectAttr ($pdiSolver[0] + ".inTime") ($obj + ".inTimeRbd");
//		disconnectAttr  ($pdiSolver[0] + ".rigidBodies") ($obj + ".solver");
//		string $parentobject[] =`listRelatives -p $obj`;
//		disconnectAttr  ($obj + ".keysTX") ($parentobject[0] + ".rotatePivotX");
//		disconnectAttr  ($obj + ".keysTY") ($parentobject[0] + ".rotatePivotY");
//		disconnectAttr  ($obj + ".keysTZ") ($parentobject[0] + ".rotatePivotZ");
//		delete -ch $obj;

        delete $obj;
	}

    waitCursor -state off;
    undoInfo -swf on;
	flushUndo; //undo after baking kas make maya crash

	//in case it is open
	if ( `window -ex winPdiBasicFractures` )
	{                
		updatePdiFracturesPanel();
	}
	if ( `window -ex winCreatePdiBodies` )
	{ 
		updatePdiBodyPanel();	               
		updatePdiManagePanel();
	}

    setAttr ($pdiSolver[0] + ".cachedMode" ) false;

    confirmDialog
    -title "Pdi Info"
    -message "keys has been baked for selected objects, \n HINT:set fragments as kinematic bodies to interact in dynamics"
    -button "OK" 
    -defaultButton "OK" ;

    clear($dynamicSelection);

	refresh -cv -force;

    //set playback speed to working units
    evalDeferred -lp "playbackOptions -ps 1";//defered it until bakeResults ends
}


global proc pdiTransferKeys(string $sourceNode, string $targetNode, string $timelapse)
{
	int $nCurvesCopied = `copyKey -time $timelapse -attribute "translateX" $sourceNode`;
	if( $nCurvesCopied > 0)
	{
		pasteKey -attribute "translateX" -o "replace"  $targetNode;
	}
	$nCurvesCopied = `copyKey -time $timelapse -attribute "translateY"  $sourceNode`;
	if( $nCurvesCopied > 0)
	{
		pasteKey -attribute "translateY" -o "replace"  $targetNode;
	}
	$nCurvesCopied = `copyKey -time $timelapse -attribute "translateZ"  $sourceNode`;
	if( $nCurvesCopied > 0)
	{
		pasteKey -attribute "translateZ" -o "replace"  $targetNode;
	}
	$nCurvesCopied = `copyKey -time $timelapse -attribute "rotateX"  $sourceNode`;
	if( $nCurvesCopied > 0)
	{
		pasteKey  -attribute "rotateX" -o "replace"  $targetNode;
	}
	$nCurvesCopied = `copyKey -time $timelapse -attribute "rotateY"  $sourceNode`;
	if( $nCurvesCopied > 0)
	{
		pasteKey -attribute "rotateY" -o "replace"  $targetNode;
	}
	$nCurvesCopied = `copyKey -time $timelapse -attribute "rotateZ"  $sourceNode`;
	if( $nCurvesCopied > 0)
	{
		pasteKey -attribute "rotateZ" -o "replace"  $targetNode;
	}
}
global proc pdiTransferKeysGroups(string $sourceGroup, string $targetGroup)
{
	if(!(`objExists $sourceGroup`) )
	{
	    error  -noContext ($sourceGroup + " for transfering keys not found \n");
		return;
	}
	if(!(`objExists $targetGroup`))
	{
	    error  -noContext ($targetGroup + " for transfering keys not found \n");
		return;
	}

	int $startTime = `playbackOptions -query -minTime`;
	int $endTime = `playbackOptions -query -maxTime`;
//	string $thetimelapse = $startTime +":" + $endTime;
	string $thetimelapse = ":" ;// ":" means all attribute keys

	string $sourceMeshes[] = `listRelatives -path -ni -ad  -typ "mesh" $sourceGroup`;
	int $numSourceMeshes=size($sourceMeshes);
	if($numSourceMeshes == 0)
	{
	    error  -noContext ($sourceGroup + " has no shapes \n");
		return;
	}

	string $targetMeshes[] = `listRelatives -path -ni -ad  -typ "mesh" $targetGroup`;

	int $numTargetMeshes=size($targetMeshes);
	if($numTargetMeshes == 0)
	{
	    error  -noContext ($targetGroup + " has no shapes \n");
		return;
	}

	print( "Transfering keys..\n");
	int $numMatches=0;
	if( $numTargetMeshes == $numSourceMeshes)
	{
		int $i;
		for($i=0; $i < $numSourceMeshes; $i++)
		{       
			string $sourceTRS[]=`listRelatives -p $sourceMeshes[$i]`;        
			string $targetTRS[] = `listRelatives -p $targetMeshes[$i]`; 
			string $sourceObj=$sourceTRS[0];
			string $targetObj=$targetTRS[0];

			//keyframe -query -keyframeCount surface1.translateX;

			pdiTransferKeys($sourceObj, $targetObj, $thetimelapse);
		}
		$numMatches= $numSourceMeshes;
	}
	else
	{
		string $sourceUncoupled[];
		string $targetUncoupled[];
		float $box[] = `exactWorldBoundingBox $sourceGroup`;
		float $sourceWcenter[3];
		$sourceWcenter[0]=($box[0] + $box[3])*.5;
		$sourceWcenter[1]=($box[1] + $box[4])*.5;
		$sourceWcenter[2]=($box[2] + $box[5])*.5;

		float $box2[] = `exactWorldBoundingBox $targetGroup`;
		float $targetWcenter[3];
		$targetWcenter[0]=($box2[0] + $box2[3])*.5;
		$targetWcenter[1]=($box2[1] + $box2[4])*.5;
		$targetWcenter[2]=($box2[2] + $box2[5])*.5;

		int $i=0,$j=0;
		for($i=0; $i < $numSourceMeshes; $i++)
		{       
			string $sourceTRS[]=`listRelatives -p $sourceMeshes[$i]`;        
			string $targetTRS[] = `listRelatives -p $targetMeshes[$j]`; 
			string $sourceObj=$sourceTRS[0];
			string $targetObj=$targetTRS[0];
			float $sourcecenter[] = `objectCenter -gl  $sourceObj`;
			float $targetcenter[] = `objectCenter -gl  $targetObj`;

			//we need local coordinates to the group center in case groups are not solaping each other
			$sourcecenter[0]-=$sourceWcenter[0];
			$sourcecenter[1]-=$sourceWcenter[1];
			$sourcecenter[2]-=$sourceWcenter[2];

			$targetcenter[0]-=$targetWcenter[0];
			$targetcenter[1]-=$targetWcenter[1];
			$targetcenter[2]-=$targetWcenter[2];

			float $dif[3];
			$dif[0] = $targetcenter[0] - $sourcecenter[0];
			$dif[1] = $targetcenter[1] - $sourcecenter[1];
			$dif[2] = $targetcenter[2] - $sourcecenter[2];
			$dif[0]*=$dif[0];
			$dif[1]*=$dif[1];
			$dif[2]*=$dif[2];

			if( $dif[0] < 1e-2 && $dif[1] < 1e-2 && $dif[2] < 1e-2)
			{
				// fragments match!
				pdiTransferKeys($sourceObj, $targetObj, $thetimelapse);
				$j++;
				$numMatches++;
			}
			else
			{
//				print ($sourceObj + "," +  $targetObj + "," +" doenst match\n");				
				
				$sourceUncoupled[size($sourceUncoupled)]= $sourceObj;
				$targetUncoupled[size($targetUncoupled)]= $targetObj;

				if( $numTargetMeshes > $numSourceMeshes)
				{
					$j++;//skip source and target fragments
				}
				else
				if( $i < ($numSourceMeshes -1))
				{
					$i++;$j++;//skip source and target fragments and  next source fragment

					string $sourceTRSnx[]=`listRelatives -p $sourceMeshes[$i]`;        
					string $sourceObjnx=$sourceTRSnx[0];
					$sourceUncoupled[size($sourceUncoupled)]= $sourceObjnx;
				}
			}
			if($j >= $numTargetMeshes)break;
		}

		if( size($sourceUncoupled) > 0)
		{
			//include target fragments not checked if any
			int $unchecked;
			for($unchecked=$j; $unchecked < $numTargetMeshes; $unchecked++)
			{       
				string $targetTRS[] = `listRelatives -p $targetMeshes[$unchecked]`; 
				string $targetObj=$targetTRS[0];
	
				$targetUncoupled[size($targetUncoupled)]= $targetObj;
			}

			//match source to the nearest target
//			print ("\n" + "num uncoupled target objects "+  size($targetUncoupled) +"\n");

			$numSourceUncoupled = size($sourceUncoupled);
			for($targetObj in $targetUncoupled)
			{   
//				print ( "traying match " + $sourceObj  + "\n");				
			    
				float $targetcenter[] = `objectCenter -gl  $targetObj`;

				$targetcenter[0]-=$targetWcenter[0];
				$targetcenter[1]-=$targetWcenter[1];
				$targetcenter[2]-=$targetWcenter[2];

				float $minDiff = 1000000;
				string $nearestSourceObj = $sourceUncoupled[0];

				for($sourceObj in $sourceUncoupled)
				{
				float $sourcecenter[] = `objectCenter -gl  $sourceObj`;

				$sourcecenter[0]-=$sourceWcenter[0];
				$sourcecenter[1]-=$sourceWcenter[1];
				$sourcecenter[2]-=$sourceWcenter[2];

					float $dif[3];
					$dif[0] = $targetcenter[0] - $sourcecenter[0];
					$dif[1] = $targetcenter[1] - $sourcecenter[1];
					$dif[2] = $targetcenter[2] - $sourcecenter[2];
					$dif[0]*=$dif[0];
					$dif[1]*=$dif[1];
					$dif[2]*=$dif[2];
					float $diflenghtsq = $dif[0]+$dif[1]+$dif[2];
					if ( $diflenghtsq < $minDiff)
					{
						$minDiff =  $diflenghtsq;
						$nearestSourceObj = $sourceObj;
					}
				}

				if(1)// $bestj >= 0)
					{
						// fragments match!
//						print ($sourceObj + "," +  $targetObj + "," +" match found! \n");				

					pdiTransferKeys($nearestSourceObj, $targetObj, $thetimelapse);

					string $itemsGone[]; $itemsGone[0]=$nearestSourceObj;
					$sourceUncoupled = stringArrayRemove($itemsGone, $sourceUncoupled);
						$numMatches++;
				}
			}
		}
	}


	if( $numMatches == 0)
	{
		error -noContext ("Source and target meshes topology is very diferent, transfer keys fails\n");
	}
	else
	if( $numMatches < $numTargetMeshes)
	{
		warning -noContext ("Transfer keys done, although some fragments has been excluded due to cannot match source fragments\n");
	}
	else
	if( $numMatches == $numTargetMeshes)
	{
		print ("transfer keys done\n");
	}
}

global proc deleteAllPdiKeyswithoutConfirm()
{
    string $transform[];
    string $pdiSelection[];

    undoInfo -swf off;

	$pdiSelection = `ls -dag -leaf -type pdiRigidBody`;


    int $i=0;
    string $dynamicSelection[];
    for( $obj in $pdiSelection)
    {
        int $enabled = getAttr ($obj + ".enabled" );
		int $passive = getAttr ($obj + ".passive" );
	    if($enabled > 0 && $passive == 0 )
	    {
            $dynamicSelection[$i] = $obj;$i++;
            setAttr ($obj + ".hasPdiKeys" ) false;
        }
    }

    for( $obj in $dynamicSelection)
    {
        $transform = `listRelatives -parent $obj`;

        delete -channels -tac true $transform;
    }

    //connect pdi dynamics
    string $result = `pdiSolver -connectDyn`;

    undoInfo -swf on;

}
global proc deleteAllPdiKeys()
{    
    string $transform[];
    string $pdiSelection[];

	$pdiSelection = `ls -dag -leaf -type pdiRigidBody`;

	int $i=0;
    string $dynamicSelection[];
    for( $obj in $pdiSelection)
    {
        int $hasPdiKeys = getAttr ($obj + ".hasPdiKeys" );
		int $isPassive = getAttr ($obj + ".passive" );
		int $isFirstHitActive = getAttr ($obj + ".firstHitActive" );
		if( $hasPdiKeys > 0)
		{
			$dynamicSelection[$i] = $obj;$i++;
		}
    }

	if( size($dynamicSelection) == 0)
	{
	    print( "Pdi Info: No PDi bodies with baked keys found ");	    
		
		//connect PDI dynamics just in case
	    $result = `pdiSolver -connectDyn`;
		
		return;		
	}

    string $result = `confirmDialog -title "Confirm" -message "This action will remove all Pdi keys, are you sure?"
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`;

    if( $result == "No")
    {
        return;
    }

    undoInfo -swf off;   
    waitCursor -state on;
    
    for( $obj in $dynamicSelection)
    {
		setAttr ($obj + ".hasPdiKeys" ) false;

        $transform = `listRelatives -parent $obj`;

//        delete -channels -tac true $transform;
        cutKey -clear -s false $transform;
    }

//	string $allFbodies[] = `ls -exactType pdiFbodyNode`;
//	for( $obj in $allFbodies)
//	{
//		int $isCached = getAttr ($obj + ".cached" );
//		if( $isCached)
//		{
//			setAttr ($obj + ".cached" ) 0;
			//force update
//			getAttr -sl ($obj  + ".caca" );                               		
//		}
//	}


    //connect pdi dynamics
    $result = `pdiSolver -connectDyn`;

    waitCursor -state off;
//    flushUndo;
    undoInfo -swf on;

}
global proc setDefaultKeysTreshold()
{
    global string $fieldPdiKeysThr;
    global string $fieldPdiRotKeysThr;
    global string $butDefaultTreshold;
    global string $fieldPdiSampleBy;

    floatSliderGrp -edit -value 0.005 $fieldPdiKeysThr;
    floatSliderGrp -edit -value 0.12  $fieldPdiRotKeysThr;
    floatSliderGrp -edit -value 1.0  $fieldPdiSampleBy;
}
global proc cleanPdiData()
{
	showPDiManageRBDTab();
}
global proc updatePdiBakePanel()
{
    global string $pdiBakeSimWindow;
    global string $butDeleteAllPdiSim;
    global string $butDeleteAllPdiKeys;

//	string $time[];
//	$time = `ls -type time`;
//    string  $pdiSolver[]=`ls -type pdiSolverNode`;
//    int $isConnected = `isConnected ($time[0] + ".outTime") ($pdiSolver[0] + ".inTime")`;
//    if( $isConnected == 0)
//	{
		//solver is disconnected
//		button -edit -enable true $butDeleteAllPdiKeys;				
//	}
//	else
//	{
//		button -edit -enable false $butDeleteAllPdiKeys;				
//	}

    showWindow $pdiBakeSimWindow;
}
global proc createPdiBakePanel()
{
    global string $pdiBakeSimWindow;
    global string $butDeleteAllPdiSim;
    global string $butDeleteAllPdiKeys;
    global string $butBakePdiSim;
    global string $fieldPdiKeysThr;
    global string $fieldPdiRotKeysThr;
    global string $fieldPdiSampleBy;
    global string $butDefaultTreshold;

    //check if the window exists
    if ( `window -ex winPdiBakeSim` )
    {                
        updatePdiBakePanel();
        
        return;
    }

	$pdiBakeSimWindow = `window -rtf true -t "Bake Pdi Simulation" -width 50 -height 60 winPdiBakeSim`;
	columnLayout -adjustableColumn true -rowSpacing 10; 
//        $fieldPdiKeysThr = `floatSliderGrp -label "Linear Threshold" -field true
//	        -minValue 0.0 -maxValue 1.0 -pre 3 -step 0.001 -value 0.0 `;
//        $fieldPdiRotKeysThr = `floatSliderGrp -label "Angular Threshold" -field true
//	        -minValue 0.0 -maxValue 1.0 -pre 3 -step 0.001 -value 0.0 `;
        $fieldPdiSampleBy = `floatSliderGrp -label "Sample by" -field true
	        -minValue 0.0 -maxValue 2.0 -pre 2 -step 0.1 -value 1.0 `;        
//        $butDefaultTreshold =`button  -w 50 -h 25 -label "Default treshold for saving resources"
//            -ann "HINT:Recommended use these setting in big scenes (1000 objects or more) "
//            -command "setDefaultKeysTreshold"`;
        $butBakePdiSim =`button  -w 50 -h 40 -label "Bake Whole Pdi Simulation"
        -ann "bake keys for all PDI objects"
         -command "bakePdiSimulation"`;   
        $butBakePdiSelected =`button  -w 50 -h 40 -label "Bake Selected Objects"
        -ann "bake keys for all PDI objects"
         -command "bakePdiSelectedOnly"`;   
        $butDeleteAllPdiSim =`button  -w 50 -h 30 -label "Clean Pdi data"
            -ann "HINT:delete Pdi nodes after baking simulation for freeing resources"
            -command "cleanPdiData"`;
        $butDeleteAllPdiKeys =`button  -w 50 -h 25 -label "Delete All Pdi Keys"
        -ann "delete keys for all PDI objects"        
         -command "deleteAllPdiKeys"`;

   updatePdiBakePanel();
}
/////////////////////////////////////////////////
//  
//  Basic Fractures Panel
//
/////////////////////////////////////////////////
global proc SetUpPdiFbody()
{
    global string $PdiSelectionForFracture[];
    global string $pdiSetUpFracturesWindow;
    global string $pdiFBodiesList;
//    global string $pdiFbodySelectedBodiesList;
    global string $newPdiFbodyName;
    global string $fieldPdiAttachThr;
    global string $fieldPdiAttachNearest;
	global string $fieldPdiForceConvex;
    global string $fieldPdiBreakThr;
    global string $fieldPdiFMass;
    global string $fieldPdiClusterize;
    global string $chkPdiEnabledFbody;
    global string $chkPdiSet2Mass;    
    global string $selectedPdiFbody;
    global string $fieldPdiFBFriction;
    global string $fieldPdiFBounciness;
    global string $chkPdiMayaFieldsFbody;
    global string $chkPdiStaticFbody;     
   	global string $pdiFactivationCollection;  	
   	global string $pdiFA[3];
	global string $chkPdiBreakAfterFrame;
	global string $fieldPdiBreakAfterFrame;
    global string $pdiPropStyleCollection;
   	global string $pdiPS[2];
    
    string $name = `textFieldGrp -query -text $newPdiFbodyName`;

    float $attachThr = `floatSliderGrp -query -value $fieldPdiAttachThr`;
    int $bAttachNearest = `checkBox -q -value $fieldPdiAttachNearest`;	
    int $bForceConvex = `checkBox -q -value $fieldPdiForceConvex`;	

    waitCursor -state on;

    string $shapeObjectsNoRbd[];
    string $shapeObjectsValidRbd[];
    string $animatedNodes[];
    int $i=0;
    for($obj in $PdiSelectionForFracture)
    {
        string $transformNode[] =`listRelatives -p $obj`;
        string $pdiobject[] =`listRelatives -type pdiRigidBody $transformNode[0]`;

		if(`keyframe -query -keyframeCount $transformNode[0]` != 0)
		{
			//transform node is animated
			$animatedNodes[size($animatedNodes)]= $obj;
		}
		else
		{
			if( size($pdiobject) == 0)
			{
			   if( nodeIsVisible( $transformNode[0]))
				$shapeObjectsNoRbd[size($shapeObjectsNoRbd)] = $obj;
			}
			else
			{
    			string  $PDIShapes[];
	    		$PDIShapes = `listConnections -type pdiCollisionShape $pdiobject[0]`;
				if( size($PDIShapes) > 0)
				{	
					int $BVolume = getAttr ($PDIShapes[0] + ".type" );
					if( $bForceConvex)
					{
						if( $BVolume != 2 )
						{
							//only convex hull allowed
							$shapeObjectsNoRbd[size($shapeObjectsNoRbd)] = $obj;
						}
						else
						{
							$shapeObjectsValidRbd[size( $shapeObjectsValidRbd)]=$obj;
						}
					}
					else
					{
						if( $BVolume != 3 )
						{
							$shapeObjectsNoRbd[size($shapeObjectsNoRbd)] = $obj;
						}
						else
						{
							$shapeObjectsValidRbd[size( $shapeObjectsValidRbd)]=$obj;
						}

					}
				}
			}
		}
    }

    if( size($animatedNodes) > 0)
	{		
		warning -noContext (" nodes excluded from fracture because has animation keys: ");
		for($obj in $animatedNodes)
		{
			print ($obj +" ");
		}
	}
    if( size($PdiSelectionForFracture) == size($animatedNodes) )
	{		
		//no shapes found in selection
	    error  -noContext ("\n all selected nodes has animation keys, can not do operation \n");

	    layoutDialog -dismiss "ERROR";
		return;	
	}

    string $thePDISolver = `pdiSolver`;//create it if necessary

    string $ShatterGroup[];
    string $SourceNode[];
	{
		string $transformNode[] =`listRelatives -p $PdiSelectionForFracture[0]`;
		$ShatterGroup=`listRelatives -p $transformNode[0]`;
		if(size( $ShatterGroup) > 0 )
			$SourceNode = `listRelatives -p $ShatterGroup[0]`;
    }
 
    int $mustResetTime=0;
	int $startTime = `playbackOptions -query -minTime`;
	int $currentTime =`currentTime -query`;	
	if( size( $SourceNode) > 0)
	{
		//check if source node is animated
		if(`keyframe -query -keyframeCount $SourceNode[0]` != 0)
		{
		   // source node has transform keys		
			$mustResetTime=1;	
		}
		else
		{
			string $motionPath[] =`listConnections -type addDoubleLinear $SourceNode[0]`;
			if( size( $motionPath) > 0)
			{
				//source node is linked to a motion path
				$mustResetTime=1;	
			}
		}
		if( $mustResetTime)
		{
			currentTime -edit $startTime;
			warning -noContext " time set to start frame becouse animated object selected";
		}
	}

	if( size($shapeObjectsNoRbd) > 0)
	{
		for($obj in $shapeObjectsNoRbd)
	{
		string $parentobject[] =`listRelatives -p $obj`;
	    string $pdiRigidBody[] =`listRelatives -type pdiRigidBody $parentobject[0]`;
		if( size($pdiRigidBody) > 0)delete $pdiRigidBody[0];
	}

		//create rigid bodies from fragments
	if( $bForceConvex)
	{
			new_PDIBody -a 0 -st 2 $shapeObjectsNoRbd;
	}
	else
		{
			new_PDIBody -a 0 -st 4 $shapeObjectsNoRbd;
	}
	}

    string $pdiobjects[];
    for($obj in $shapeObjectsNoRbd)
    {
        string $transformNode[] =`listRelatives -p $obj`;

        string $pdiRigidBody[] =`listRelatives -type pdiRigidBody $transformNode[0]`;
        if( size($pdiRigidBody) > 0)
        {
            $pdiobjects[size($pdiobjects)] = $pdiRigidBody[0];
        }
    }
    for($obj in $shapeObjectsValidRbd)
    {
        string $transformNode[] =`listRelatives -p $obj`;

        string $pdiRigidBody[] =`listRelatives -type pdiRigidBody $transformNode[0]`;
        if( size($pdiRigidBody) > 0)
        {
            $pdiobjects[size($pdiobjects)] = $pdiRigidBody[0];
        }
    }

    //remove first hit attr for rigid bodies
    string $fractureBodyNode;

    if( $bAttachNearest > 0)
    {
       $fractureBodyNode = `pdiFractureBody -n $name -dTh $attachThr -nearest $pdiobjects`;
    }
    else
    {
       $fractureBodyNode = `pdiFractureBody -n $name -dTh $attachThr $pdiobjects`;
    }

    waitCursor -state off;

    if( $fractureBodyNode==$name)
    {

    // group objects
    // note if grouping needed remove group when delete fbody
    //    group -name $name $SelectObjects;

        int $indexFbodies = getAttr ($thePDISolver + ".caif" );
        $indexFbodies++;
        setAttr ($thePDISolver + ".caif" ) $indexFbodies;

        textScrollList -edit -append $fractureBodyNode $pdiFBodiesList;
        textScrollList -edit -selectItem $fractureBodyNode $pdiFBodiesList;
        $selectedPdiFbody = $fractureBodyNode;//select the last created by default

		if( size($ShatterGroup) > 0)
		{
			//disable Shatter it drawing
			$voronoiNode=`listRelatives -ad -typ "pdiVoronoiNode" $ShatterGroup[0]`;
			if( size($voronoiNode) > 0)
			{
				int $isDrawEnabled= getAttr ($voronoiNode[0] + ".draw" );
				if( $isDrawEnabled==1)
				{
					setAttr ($voronoiNode[0] + ".draw" ) 0;
					//force update
					getAttr -sl ($voronoiNode[0] + ".cadraw" );                               
				}
			}

			//do not show vertex color
			$vertexColorState = `polyOptions -q -cs $ShatterGroup[0]`;
			//	print  ($shiPreviewObject + " vc state = " + $vertexColorState[0]);
			if($vertexColorState[0] > 0) polyOptions -cs false $ShatterGroup[0];
		}
    }

	setPdiFbodyParamsToDefaults();
    updatePdiSolverPanel(); 
//	updatePdiFbodyUIParams();              

	if( $mustResetTime)
	{
		currentTime -edit $currentTime;
		$mustResetTime=0;	
		warning -noContext " current time recovered after creating rigid bodies";
	}	    

//    deleteUI -window setUpFractures;
    layoutDialog -dismiss "OK";

}

global proc CheckFractureSelection()
{
    global string $pdiCkeckText;
//    global string $pdiFbodySelectedBodiesList;
    global string $PdiSelectionForFracture[];

    scrollField -edit -text "" $pdiCkeckText;

    //string $selection[];
    //$selection = `textScrollList -query -allItems $pdiFbodySelectedBodiesList`;

    string $shapeObjects[];
    int $i=0;
    for($obj in $PdiSelectionForFracture)
    {
        string $parentobject[] =`listRelatives -p $obj`;

        string $pdiobject[] =`listRelatives -type pdiRigidBody $parentobject[0]`;
        if( size($pdiobject) == 0)
        {
            $shapeObjects[size($shapeObjects)] = $obj;
        }
    }

    if( size($shapeObjects) > 0)
    {
        new_PDIBody -a 0 -st 4 $shapeObjects;
    }

    string $pdiobjects[];
    for($obj in $PdiSelectionForFracture)
    {
        string $parentobject[] =`listRelatives -p $obj`;

        string $pdiobject[] =`listRelatives -type pdiRigidBody $parentobject[0]`;
        if( size($pdiobject) > 0)
        {
            $pdiobjects[size($pdiobjects)] = $pdiobject[0];
        }
    }
    
    waitCursor -state on;

    string $result[];
    $result = `pdiFractureBody -check true $pdiobjects`;

    waitCursor -state off;

    if( size($result) > 0)
    {
        for( $str in $result)
        {
            scrollField -edit -it $str $pdiCkeckText;
        }
        
        string $endTxt = size($result) + " objects with issues\n";
        if( size($result) >= 15)
        {
            $endTxt += " abort checking..";
        }
        scrollField -edit -it $endTxt $pdiCkeckText;
    }
    else
    {
        scrollField -edit -it "selection seems correct\n" $pdiCkeckText;

    }

}
global proc cancelSetUpPdiFbody()
{
    layoutDialog -dismiss "CANCEL";
}
global proc createPdiSetUpFbodyWindow()
{
    global string $PdiSelectionForFracture[];
    global string $pdiSetUpFracturesWindow;
    global string $newPdiFbodyName;
    global string $fieldPdiAttachThr;
    global string $fieldPdiAttachNearest;
	global string $fieldPdiForceConvex;
    global string $pdiFBodiesList;
    global string $pdiCkeckText;
    string $pdiFbodySelectedBodiesList;


    //int $nFbodies = `textScrollList -query -numberOfItems $pdiFBodiesList`;

	int $indexFbodies = 0;
    string $PDISolver[]=`ls -type pdiSolverNode`;
	if( size( $PDISolver) > 0)
	{
		 $indexFbodies = getAttr ($PDISolver[0]+ ".caif" );
	}

    string $name = "Fbody" + $indexFbodies;

    string $form = `setParent -q`;

    // layoutDialog's are not resizable, so hard code a size here,
    // to make sure all UI elements are visible.
    //

    formLayout -e -width 300 $form;

	string $txt1= `text -label "Selected: "  -font "boldLabelFont"`;
    $pdiFbodySelectedBodiesList = `textScrollList -w 150 -numberOfRows 15 -allowMultiSelection false` ;
	$newPdiFbodyName =`textFieldGrp -label "Name" -text  $name`;
    $fieldPdiAttachThr = `floatSliderGrp -label "Attach Threshold" -field true
	        -minValue 0.0 -maxValue 10.0 -value 0.05 -pre 4` ;
    $fieldPdiAttachNearest = `checkBox -label "attach nearest"`;
    $fieldPdiForceConvex = `checkBox -label "force convex shapes" -value true`;
    string $butCheck = `button  -w 120 -h 30 -label "Check selection" -command "CheckFractureSelection"`;
    string $butOKFBody = `button  -w 60  -h 30 -label "Accept" -command "SetUpPdiFbody"`;
    string $butCancelFBody = `button  -w 60 -h 30 -label "Cancel" -command "cancelSetUpPdiFbody"`;
    $pdiCkeckText = `scrollField -h 150 -wordWrap true -text "" -editable false`;

    int $spacer = 15;
    int $top = 5;
    int $edge = 5;

    formLayout -edit
    -attachForm            $txt1  "left"   $edge
        -attachControl         $pdiFbodySelectedBodiesList "top" $edge $txt1
    -attachForm            $pdiFbodySelectedBodiesList  "left"   $edge
    -attachForm            $pdiFbodySelectedBodiesList  "right"  $edge
    -attachForm            $newPdiFbodyName  "left" $edge
        -attachControl     $newPdiFbodyName "top"    $spacer  $pdiFbodySelectedBodiesList
	-attachForm           $fieldPdiAttachThr "left"   $edge
        -attachControl         $fieldPdiAttachThr  "top"  $spacer $newPdiFbodyName
	-attachForm           $fieldPdiAttachNearest "left"   $edge
        -attachControl         $fieldPdiAttachNearest  "top"  $spacer $fieldPdiAttachThr
	-attachForm           $fieldPdiForceConvex "left"   $edge
        -attachControl         $fieldPdiForceConvex  "top"  $spacer $fieldPdiAttachNearest
	-attachForm           $butCheck "left"   $edge
        -attachControl         $butCheck  "top" $spacer $fieldPdiForceConvex
        -attachControl         $butOKFBody  "left" $edge $butCheck
        -attachControl         $butOKFBody  "top" $spacer $fieldPdiForceConvex
//	-attachForm           $butCancelFBody "right"   $edge
        -attachControl         $butCancelFBody  "left" $edge $butOKFBody
        -attachControl         $butCancelFBody  "top" $spacer $fieldPdiForceConvex
	-attachForm           $pdiCkeckText "left"   $edge
	-attachForm           $pdiCkeckText "right"   $edge
        -attachControl         $pdiCkeckText "top"   $spacer  $butCheck
   $form;


    for ( $obj in $PdiSelectionForFracture)
	{
//        if( `nodeType $obj`== "pdiRigidBody")
//        {
            textScrollList -edit -append $obj $pdiFbodySelectedBodiesList;
//        }
    }
}
global proc createPdiFbody()
{
    global string $selectedPdiFbody;
    global string $PdiSelectionForFracture[];
	
	string  $selection[] = `ls -selection -dag -leaf -visible -ni -type "mesh"`;
	if( size($selection) == 0)
	{
		//maybe selection is a voronoi node
		$selection = `ls -selection -dag -type "pdiVoronoiNode"`;
		if( size($selection) > 0)
		{
			string $transformNode[]=`listRelatives -p $selection[0]`;
			$ShatterGroup=`listRelatives -p $transformNode[0]`;
			$selection=`listRelatives -path -ni -ad -typ "mesh" $ShatterGroup[0]`;
		}
	}

    if( size($selection)==0)
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select at least one pdi fragment"
        -button "OK" 
        -defaultButton "OK" ;

        return;
    }

	if( `objExists $selectedPdiFbody`)
	{
		//switch off stresses viewfor teh current selected fbody
		//turn off display stresses for previous selected fboby
	    int $PdiDisplayStresses = getAttr ($selectedPdiFbody + ".displayStressses" );
		if( $PdiDisplayStresses==1)
		{
			setAttr( $selectedPdiFbody  + ".displayStressses" ) 0;

			//force update
			getAttr ($selectedPdiFbody  + ".cdst" );
			update_Fbody -dst false $selectedPdiFbody;
		}
	}
    if( size($selection)==1)
    {
		//select all meshes in the shatter group
		string $transformNode[] =`listRelatives -p  $selection[0] `;
		string $shatterGroup[] =`listRelatives -p  $transformNode[0] `;
		if( size($shatterGroup)==0)
		{
		   error -noContext "This fragment isnt generated with  Shatter it tool";        
		}
		else
		{
			$selection=`listRelatives -path -ni -ad -typ "mesh" $shatterGroup[0]`;
		}
	}

   //this last check maybe not needed
    clear($PdiSelectionForFracture);
    for ( $obj in $selection)
	{
        if( `nodeType -api $obj`== "kMesh")
        {
            $PdiSelectionForFracture[size($PdiSelectionForFracture)] = $obj;
        }
    }

	string $allFbodies[] = `ls -exactType pdiFbodyNode`;

	if( size($allFbodies) > 0)
	{
		    warning -noContext "PDI Info: reached fracture bodies limit for Pdi free version";					
	}
	else
	{
		string $result = `layoutDialog -t "Set up Fracture Body" -ui "createPdiSetUpFbodyWindow"`;	
	}

}

global proc deletePDIFractureBody()
{
    global string $pdiFBodiesList;
    global string $chkPdiTransFbody;
    global string $chkPdiEnabledFbody;
    global string $selectedPdiFbody;

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;

    if( size( $selected) > 0)
    {
		string $result = `confirmDialog -title "Confirm" -message "are you sure you want to delete this fbody?"
		-button "Yes" -button "No" -defaultButton "Yes"
		-cancelButton "No" -dismissString "No"`;

		if( $result == "No")
		{
			return;
		}
 		
        waitCursor -state on;

		setDefaultsPdiFbodyParams( $selected[0]);    

		//switch off stresses view before deleting it
		int $PdiDisplayStresses = getAttr ($selected[0]+ ".displayStressses" );
		if( $PdiDisplayStresses==1)
		{
			update_Fbody -dst  false $selected[0];
		}

		string $rbdlist[] = `listConnections -d on -s off  ($selected[0] + ".rigidBodies")`;

        textScrollList -edit -removeItem $selected[0] $pdiFBodiesList;    

       $result = `deletePdiFBody -db $selected[0]`;

	   if( $result == $selected[0])
	   {
		    if( $selectedPdiFbody == $result)$selectedPdiFbody="";

	   		//Enable Shatter it drawing
			string $transformNode[] =`listRelatives -p $rbdlist[0]`;
			$voronoiNode=`listRelatives -ad -typ "pdiVoronoiNode" $transformNode[0]`;
			if( size($voronoiNode) > 0)
			{
				setAttr ($voronoiNode[0] + ".draw" ) 1;
				//force update
				getAttr -sl ($voronoiNode[0] + ".cadraw" );                               

				select $voronoiNode[0];
			}
	   }

	   //connect solver if no other rigid bodies in scene
	    string $time[];
	    $time = `ls -type time`;
    	string  $pdiSolver[]=`ls -type pdiSolverNode`;

        int $isConnected = `isConnected ($time[0] + ".outTime") ($pdiSolver[0] + ".inTime")`;
        if( $isConnected == 0)
		{
			string  $pdibodies[] = `ls -dag -leaf -type pdiRigidBody`;
			
			if( size($pdibodies) == 0)
			{
				string $result = `pdiSolver -connectDyn`;
			}
			else
			{
				string $allFbodies[] = `ls -exactType pdiFbodyNode`;

				int $anyFbodyEnabled=0;
				for( $obj in $allFbodies)
				{
					$anyFbodyEnabled = getAttr ($obj + ".enabled" );
					if($anyFbodyEnabled>0)break;
				}
				if( $anyFbodyEnabled==0)
				{
					string $result = `pdiSolver -connectDyn`;
				}
			}
		}

	   updatePdiFracturesPanel();
	   updatePdiAdvancedFracturesPanel();

		if ( `window -ex winCreatePdiBodies` )
		{                
			updatePdiManagePanel();
		}


        waitCursor -state off;
    }    
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a fracture body from the list"
        -button "OK" 
        -defaultButton "OK" ;

        checkBox -edit -value 0 $chkPdiEnabledFbody;
    }    
}
global proc deleteAllPdiFbodies()
{
    global string $pdiFBodiesList;
    global string $selectedPdiFbody;

    string $PDIFbodies[];
    $PDIFbodies = `textScrollList -query -allItems $pdiFBodiesList`;

    if( size( $PDIFbodies) > 0)
    {
		string $result = `confirmDialog -title "Confirm" -message "are you sure you want to delete all PDI Fbodies in scene?"
		-button "Yes" -button "No" -defaultButton "Yes"
		-cancelButton "No" -dismissString "No"`;

		if( $result == "No")
		{
			return;
		}

		//switch off stresses view before deleting it		
		string $selected[] = `textScrollList -query -selectItem $pdiFBodiesList`;

		if( size( $selected) > 0)
		{
			int $PdiDisplayStresses = getAttr ($selected[0]+ ".displayStressses" );
			if( $PdiDisplayStresses==1)
			{
				update_Fbody -dst  false $selected[0];
			}
		}

        textScrollList -edit -removeAll $pdiFBodiesList;

        waitCursor -state on;

        for( $obj in $PDIFbodies )
        {
            string $result = `deletePdiFBody -db $obj`;
        }

	   	//Enable Shatter it drawing
		string $voronoiNodes[]= `ls -dag -type "pdiVoronoiNode"`;
		for($obj in $voronoiNodes)
		{
			setAttr ($obj + ".draw" ) 1;
			//force update
			getAttr -sl ($obj + ".cadraw" );                               
		}

		$selectedPdiFbody="";

		if ( `window -ex winCreatePdiBodies` )
		{                
			updatePdiManagePanel();
		}

		setDefaultsPdiFbodyParams("");

        waitCursor -state off;

    }    
}
global proc setStatePdiFBody()
{
    global string $pdiFBodiesList;
    global string $chkPdiEnabledFbody;

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;

    if( size( $selected) > 0)
    {
	    int $bEnabled = `checkBox -q -value $chkPdiEnabledFbody`;	

        if( $bEnabled > 0)
        {
    	    setAttr ($selected[0] + ".enabled" ) false;
        }
        else
        {
    	    setAttr ($selected[0] + ".enabled" ) true;
        }
         //force update
	     getAttr ($selected[0] + ".ca_enabled" );
    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a fracture body from the list"
        -button "OK" 
        -defaultButton "OK" ;

        checkBox -edit -value 0 $chkPdiEnabledFbody;
    }
}
global proc setPptyPdiBreakTreshold()
{
    global string $pdiFBodiesList;
    global string $fieldPdiBreakThr;

    string $pdiSolver[]=`ls -type pdiSolverNode`;
	if( size( $pdiSolver)>0)
	{
		string $connections[];
		$connections =`listConnections -d off -s on ($pdiSolver[0] + ".inTime")`;
		if( size( $connections)==0)
		{
			warning -noContext "Pdi dynamics has been disabled, delete all Pdi keys will enable it again ";
		}
	}

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;

    if( size( $selected) > 0)
    {
	    float $breakThr = `floatSliderGrp -q -value $fieldPdiBreakThr`;	

         waitCursor -state on;

    	 setAttr ($selected[0] + ".stressThreshold" ) $breakThr;
         setAttr ($selected[0] + ".usercommand" ) true;
         //force update
	     getAttr ($selected[0] + ".ca_stressThreshold" );


         waitCursor -state off;

    }
    else
    {
        ///this make maya hold when clicking on the slider 
        //confirmDialog
        //-title "Pdi Info"
        //-message "Select a fracture body from the list"
        //-button "OK" 
        //-defaultButton "OK" ;
        floatSliderGrp -edit -value 0.0 $fieldPdiBreakThr;

		warning -noContext "no fracture body selected in list";  
    }

}
global proc setPptyPdiClusterize()
{
    global string $pdiFBodiesList;
    global string $fieldPdiClusterize;

    string $pdiSolver[]=`ls -type pdiSolverNode`;
	if( size( $pdiSolver)>0)
	{
		string $connections[];
		$connections =`listConnections -d off -s on ($pdiSolver[0] + ".inTime")`;
		if( size( $connections)==0)
		{
			warning -noContext "Pdi dynamics has been disabled, delete all Pdi keys will enable it again ";
		}
	}

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;

    if( size( $selected) > 0)
    {
	    int $value = `intSliderGrp -q -value $fieldPdiClusterize`;	

         waitCursor -state on;

    	 setAttr ($selected[0] + ".randomThreshold" ) $value;
         setAttr ($selected[0] + ".usercommand" ) true;
         //force update
	     getAttr ($selected[0] + ".ca_randomThreshold" );


         waitCursor -state off;
    }
    else
    {
        ///warning: this make maya hold when clicking on the slider 
        //confirmDialog
        //-title "Pdi Info"
        //-message "Select a fracture body from the list"
        //-button "OK" 
        //-defaultButton "OK" ;
        intSliderGrp -edit -value 0 $fieldPdiClusterize;

		warning -noContext "no fracture body selected in list";  

    }

}
global proc setPptyPdiFMass()
{
    global string $pdiFBodiesList;
    global string $fieldPdiFMass;

    string $pdiSolver[]=`ls -type pdiSolverNode`;
	if( size( $pdiSolver)>0)
	{
		string $connections[];
		$connections =`listConnections -d off -s on ($pdiSolver[0] + ".inTime")`;
		if( size( $connections)==0)
		{
			warning -noContext "Pdi dynamics has been disabled, delete all Pdi keys will enable it again ";
		}
	}

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;
    if( size( $selected) > 0)
    {
        float $mass = `floatFieldGrp -query -value1 $fieldPdiFMass`;

        setAttr ($selected[0] + ".mass" ) $mass;
         //force update
	    getAttr ($selected[0] + ".ca_mass" );

    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a fracture body from the list"
        -button "OK" 
        -defaultButton "OK" ;

        floatFieldGrp -edit -value 1 $fieldPdiFMass;
    }
}

global proc setPptyPdiFBFriction()
{
    global string $pdiFBodiesList;
    global string $fieldPdiFBFriction;

    string $pdiSolver[]=`ls -type pdiSolverNode`;
	if( size( $pdiSolver)>0)
	{
		string $connections[];
		$connections =`listConnections -d off -s on ($pdiSolver[0] + ".inTime")`;
		if( size( $connections)==0)
		{
			warning -noContext "Pdi dynamics has been disabled, delete all Pdi keys will enable it again ";
		}
	}

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;
    if( size( $selected) > 0)
    {
        float $friction = `floatSliderGrp -query -value $fieldPdiFBFriction`;

        setAttr ($selected[0] + ".friction" ) $friction;
         //force update
	    getAttr ($selected[0] + ".ca_friction" );

    }
    else
    {
        floatSliderGrp -edit -value 0 $fieldPdiFBFriction;
		warning -noContext "no fracture body selected in list";  
    }

}

global proc setPptyPdiFBounciness()
{
    global string $pdiFBodiesList;
    global string $fieldPdiFBounciness;

    string $pdiSolver[]=`ls -type pdiSolverNode`;
	if( size( $pdiSolver)>0)
	{
		string $connections[];
		$connections =`listConnections -d off -s on ($pdiSolver[0] + ".inTime")`;
		if( size( $connections)==0)
		{
			warning -noContext "Pdi dynamics has been disabled, delete all Pdi keys will enable it again ";
		}
	}

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;
    if( size( $selected) > 0)
    {
        float $bounciness = `floatSliderGrp -query -value $fieldPdiFBounciness`;

        setAttr ($selected[0] + ".bounciness" ) $bounciness;
         //force update
	    getAttr ($selected[0] + ".ca_bounciness" );

    }
    else
    {
        floatSliderGrp -edit -value 0 $fieldPdiFBounciness;
		warning -noContext "no fracture body selected in list";  
    }
}
global proc setPptyPdiFAirdamping()
{
    global string $pdiFBodiesList;
    global string $fieldPdiFairdamping;

    string $pdiSolver[]=`ls -type pdiSolverNode`;
	if( size( $pdiSolver)>0)
	{
		string $connections[];
		$connections =`listConnections -d off -s on ($pdiSolver[0] + ".inTime")`;
		if( size( $connections)==0)
		{
			warning -noContext "Pdi dynamics has been disabled, delete all Pdi keys will enable it again ";
		}
	}

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;
    if( size( $selected) > 0)
    {
        float $airDamping = `floatSliderGrp -query -value $fieldPdiFairdamping`;

        setAttr ($selected[0] + ".linearDamping" ) $airDamping;
         //force update
	    getAttr ($selected[0] + ".ca_airdamping" );

    }
    else
    {
        floatSliderGrp -edit -value 0 $fieldPdiFairdamping;
		warning -noContext "no fracture body selected in list";  
    }
}
global proc setPptyPdiFAngulardamping()
{
    global string $pdiFBodiesList;
    global string $fieldPdiFairdamping2;

    string $pdiSolver[]=`ls -type pdiSolverNode`;
	if( size( $pdiSolver)>0)
	{
		string $connections[];
		$connections =`listConnections -d off -s on ($pdiSolver[0] + ".inTime")`;
		if( size( $connections)==0)
		{
			warning -noContext "Pdi dynamics has been disabled, delete all Pdi keys will enable it again ";
		}
	}

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;
    if( size( $selected) > 0)
    {
        float $angularDamping = `floatSliderGrp -query -value $fieldPdiFairdamping2`;

        setAttr ($selected[0] + ".angularDamping" ) $angularDamping;
         //force update
	    getAttr ($selected[0] + ".ca_angdamping" );

    }
    else
    {
        floatSliderGrp -edit -value 0 $fieldPdiFairdamping2;
		warning -noContext "no fracture body selected in list";  
    }
}


global proc setPptyFVelocity()
{
    global string $pdiFBodiesList;
    global string $fieldPdiFVelocity;

    string $pdiSolver[]=`ls -type pdiSolverNode`;
	if( size( $pdiSolver)>0)
	{
		string $connections[];
		$connections =`listConnections -d off -s on ($pdiSolver[0] + ".inTime")`;
		if( size( $connections)==0)
		{
			warning -noContext "Pdi dynamics has been disabled, delete all Pdi keys will enable it again ";
		}
	}

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;

    if( size( $selected) > 0)
    {
        float $vx = `floatFieldGrp -query -value1 $fieldPdiFVelocity`;
        float $vy = `floatFieldGrp -query -value2 $fieldPdiFVelocity`;
        float $vz = `floatFieldGrp -query -value3 $fieldPdiFVelocity`;

        setAttr ($selected[0] + ".initialVelocity" ) -type "float3" $vx $vy $vz;
         //force update
	    getAttr ($selected[0] + ".ca_initialVelocity" );

    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a fracture body from the list"
        -button "OK" 
        -defaultButton "OK" ;

        floatFieldGrp -edit -value1 0.0 $fieldPdiFVelocity;
        floatFieldGrp -edit -value2 0.0 $fieldPdiFVelocity;
        floatFieldGrp -edit -value3 0.0 $fieldPdiFVelocity;
    }
}
global proc setPptyFWelocity()
{
    global string $pdiFBodiesList;
    global string $fieldPdiFWelocity;

    string $pdiSolver[]=`ls -type pdiSolverNode`;
	if( size( $pdiSolver)>0)
	{
		string $connections[];
		$connections =`listConnections -d off -s on ($pdiSolver[0] + ".inTime")`;
		if( size( $connections)==0)
		{
			warning -noContext "Pdi dynamics has been disabled, delete all Pdi keys will enable it again ";
		}
	}


    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;

    if( size( $selected) > 0)
    {
        float $vx = `floatFieldGrp -query -value1 $fieldPdiFWelocity`;
        float $vy = `floatFieldGrp -query -value2 $fieldPdiFWelocity`;
        float $vz = `floatFieldGrp -query -value3 $fieldPdiFWelocity`;

        setAttr ($selected[0] + ".initialSpin" ) -type "float3" $vx $vy $vz;
         //force update
	    getAttr ($selected[0] + ".ca_initialSpin" );

    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a fracture body from the list"
        -button "OK" 
        -defaultButton "OK" ;

        floatFieldGrp -edit -value1 0.0 $fieldPdiFWelocity;
        floatFieldGrp -edit -value2 0.0 $fieldPdiFWelocity;
        floatFieldGrp -edit -value3 0.0 $fieldPdiFWelocity;
    }

}
global proc setStatePdiMayaFieldsFbody()
{
    global string $chkPdiMayaFieldsFbody;
    global string $pdiFBodiesList;
	global string $PdiFbodyFieldList;
    global string $butPdiFbodyFieldList;

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;

    if( size( $selected) > 0)
    {
	    int $value = `checkBox -q -value $chkPdiMayaFieldsFbody`;	

        if( $value > 0)
        {
    	    setAttr ($selected[0] + ".affectForceFields" ) true;
        }
        else
        {
    	    setAttr ($selected[0] + ".affectForceFields" ) false;
        }
         //force update
        getAttr ($selected[0] + ".ca_forceFields" );

        string  $forceFields[];
        if( $value > 0) 
        {
            $forceFields = `ls -tr -dag -leaf`;//note this includes all transform nodes in scene
        }
        pdiConnectForceFields -fbodyName $selected[0] -connect $forceFields ;

        //fill  field list
		textScrollList -edit -removeAll  $PdiFbodyFieldList;
        for ( $obj in $forceFields)
	    {
            textScrollList -edit -append $obj  $PdiFbodyFieldList;
        }

        button -e -enable false $butPdiFbodyFieldList;

    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a fracture body from the list"
        -button "OK" 
        -defaultButton "OK" ;

        checkBox -edit -value 0 $chkPdiMayaFieldsFbody;
    }
}


global proc updateTransformFbdody()
{
    global string $pdiFBodiesList;
    global string $chkPdiMayaFieldsFbody;
	global string $selectedPdiFbody;

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;
//	$selected = `ls -selection`;

    if( size( $selected) > 0)
    {
        update_Fbody -trs  $selected[0];
		updatePdiFbodyUIParams();
		select  $selectedPdiFbody;
    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a fracture body from the list"
        -button "OK" 
        -defaultButton "OK" ;

        checkBox -edit -value 0 $chkPdiMayaFieldsFbody;
    }
}
global proc setDisplayStresses()
{
    global string $chkPdiMayaFieldsFbody;
    global string $pdiFBodiesList;
    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;

    if( size( $selected) > 0)
    {
		waitCursor -state on;

        int $PdiDisplayStresses = getAttr ($selected[0] + ".displayStressses" );

        if( $PdiDisplayStresses==0)
        {
            setAttr ($selected[0] + ".displayStressses" ) 1;
            //force update
            getAttr ($selected[0] + ".cdst" );

			update_Fbody -map $selected[0];
			update_Fbody -dst  true $selected[0];

			SelectTool;// set select tool to prevent moving fragments accidentally
		}
        else
        {
            setAttr ($selected[0] + ".displayStressses" ) 0;

            //force update
            getAttr ($selected[0] + ".cdst" );

			update_Fbody -dst false $selected[0];
        }   

		waitCursor -state off;
    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a fracture body from the list"
        -button "OK" 
        -defaultButton "OK" ;

        checkBox -edit -value 0 $chkPdiMayaFieldsFbody;
    }

}

global proc pdiExcludeFbodyField()
{
    global string $pdiExludedFbodyFieldsList;
    global string $pdiIncludedFbodyFieldsList;

    string $selection[];
    $selection = `textScrollList -query -selectItem $pdiIncludedFbodyFieldsList`;

    for ( $obj in $selection)
	{
        textScrollList -edit -removeItem $obj $pdiIncludedFbodyFieldsList;
        textScrollList -edit -append $obj $pdiExludedFbodyFieldsList;
    }
}
global proc pdiIncludeFbodyField()
{
    global string $pdiExludedFbodyFieldsList;
    global string $pdiIncludedFbodyFieldsList;

    string $selection[];
    $selection = `textScrollList -query -selectItem $pdiExludedFbodyFieldsList`;

    for ( $obj in $selection)
	{
        textScrollList -edit -append $obj $pdiIncludedFbodyFieldsList;
        textScrollList -edit -removeItem $obj $pdiExludedFbodyFieldsList;
    }
}
global proc pdiAcceptFbodyFields()
{
    global string $pdiFBodiesList;
    global string $pdiIncludedFbodyFieldsList;

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;

    if( size( $selected) > 0)
    {
        string  $forceFields[];
        $forceFields = `textScrollList -query -allItems $pdiIncludedFbodyFieldsList`;

        pdiConnectForceFields -fbodyName $selected[0] -connect $forceFields ;
    }
    layoutDialog -dismiss "OK";
}
global proc pdiExcludeIncludeFbodyFields()
{
    warning -noContext "PDI Info: This feature is not included in demo version\n";
}
global proc updatePdiPropStyle()
{
    global string $pdiPropStyleCollection;
   	global string $pdiPS[2];
    global string $pdiFBodiesList;
    
    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;

    if( size( $selected) > 0)
    {
        if( `radioButton -query -select $pdiPS[1]`)
        {
            setAttr ($selected[0] + ".propStyle" ) 1;
        }
        else
        {
            setAttr ($selected[0] + ".propStyle" ) 0;
        }
         setAttr ($selected[0] + ".usercommand" ) true;

        //force update
        getAttr ($selected[0] + ".caps" );
    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a fracture body from the list"
        -button "OK" 
        -defaultButton "OK" ;
    }
}

global proc setStatePdiFBodyStatic()
{    
	global string $pdiFBodiesList;	
    global string $chkPdiStaticFbody;     
   	global string $framePdiFactivation; 
   	global string $pdiFactivationCollection;
   	global string $pdiFA[3];

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;
    if( size( $selected) > 0)
    {
	     $state = `checkBox -q -value $chkPdiStaticFbody`;	
		if( $state == true)
        {
    	    setAttr ($selected[0] + ".passive" ) true;
    		setAttr ($selected[0] + ".firstHitActive" ) 1;
			radioCollection -edit -select $pdiFA[1] $pdiFactivationCollection;	    		
        }
        else
        {
    	    setAttr ($selected[0] + ".passive" ) false;
    	    setAttr ($selected[0] + ".firstHitActive" ) 0;
			radioCollection -edit -select $pdiFA[0] $pdiFactivationCollection;	    		
        }
     
		//force update
	     getAttr ($selected[0] + ".ca_passive" );
		 getAttr ($selected[0] + ".ca_firstHit" );    	    

		 //cahnging static param affect other controls
		//frameLayout -edit -enable $state $framePdiFactivation;

		 updatePdiFbodyUIParams();
    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a fracture body from the list"
        -button "OK" 
        -defaultButton "OK" ;

        checkBox -edit -value 0 $chkPdiStaticFbody;       
    }
}
global proc setStatePdiFBodyFirstHit()
{
    global string $pdiFBodiesList;
    global string $chkPdiStaticFbody;     
   	global string $pdiFA[3];
   	global string $fieldPdiFAFrame;

    string $pdiSolver[]=`ls -type pdiSolverNode`;
	if( size( $pdiSolver)>0)
	{
		string $connections[];
		$connections =`listConnections -d off -s on ($pdiSolver[0] + ".inTime")`;
		if( size( $connections)==0)
		{
			warning -noContext "Pdi dynamics has been disabled, delete all Pdi keys will enable it again ";
		}
	}

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;
    if( size( $selected) > 0)
    {
        if( `radioButton -query -select $pdiFA[1]`)
        {
    	    setAttr ($selected[0] + ".firstHitActive" ) 1;
		    intField -edit -enable false $fieldPdiFAFrame;	    	    
        }
        else
        if( `radioButton -query -select $pdiFA[2]`)
        {
    	    setAttr ($selected[0] + ".firstHitActive" ) 2;
		    intField -edit -enable true $fieldPdiFAFrame;	    	    
        }
        else
        {
    	    setAttr ($selected[0] + ".firstHitActive" ) 0;
		    intField -edit -enable false $fieldPdiFAFrame;	    	    
        }
         //force update
	     getAttr ($selected[0] + ".ca_firstHit" );
    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a fracture body from the list"
        -button "OK" 
        -defaultButton "OK" ;
    }
}
global proc SetPdiStresses2Mass()
{
    global string $pdiFBodiesList;
    global string $chkPdiSet2Mass;
    global string $selectedPdiFbody;

    string $pdiSolver[]=`ls -type pdiSolverNode`;
	if( size( $pdiSolver)>0)
	{
		string $connections[];
		$connections =`listConnections -d off -s on ($pdiSolver[0] + ".inTime")`;
		if( size( $connections)==0)
		{
			warning -noContext "Pdi dynamics has been disabled, delete all Pdi keys will enable it again ";
		}
	}

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;
    if( size( $selected) > 0)
    {
	    int $state = `checkBox -q -value $chkPdiSet2Mass`;	
		if( $state == true)
        {
    	    setAttr ($selected[0] + ".stress2mass" ) true;
        }
        else
        {
    	    setAttr ($selected[0] + ".stress2mass" ) false;
        }
         //force update
	     getAttr ($selected[0] + ".ca_stress2mass" );	    

	}
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a fracture body from the list"
        -button "OK" 
        -defaultButton "OK" ;

        checkBox -edit -value 0 $chkPdiSet2Mass;       
    }
}

global proc setDefaultsPdiFbodyParams( string $fbody)
{
	global int $defaultFBodyStaticState;
	global int $defaultPDiFirstHitFbody;
	global int $defaultFbodyActFrame;
    global float $defaultPdiBreakThr;
    global int $defaultPdiClusterize;
    global int $defaultchkPdiSet2Mass;    
	global int $defaultPdiUnbreakable;
	global int $defaultPdiBreakFrame;
	global int $defaultPdiPropStyle;
	global int $defaultPdiPropChange;
	global int $defaultPdiPropFrame;
    global float $defaultFBodyMass;
    global float $defaultPdiFBFriction;
    global float $defaultPdiFBounciness;
    global float $defaultFBodyLdamping;    
    global float $defaultFBodyWdamping;    
	global vector $defaultFBodyVelocity;
	global vector $defaultFBodySpin;
    global int $defaultPdiMayaFieldsFbody;
    global int $defaultFbodySecCracksState;
    global int $defaultFBodySecCracksPercent;    


	if( $fbody!="" && `nodeType $fbody`=="pdiFbodyNode")
	{
		print ("\nPDI fracture defaults set as " + $fbody +"\n");

		$defaultFBodyStaticState = getAttr ($fbody + ".passive" );
	    $defaultPDiFirstHitFbody = getAttr ($fbody + ".firstHitActive" );
        $defaultFbodyActFrame = getAttr ($fbody + ".actFrame" );  
	    $defaultPdiBreakThr = getAttr ($fbody + ".stressThreshold" );
	    $defaultPdiClusterize = getAttr ($fbody + ".randomThreshold" );
	    $defaultchkPdiSet2Mass = getAttr ($fbody + ".stress2mass" );
	    $defaultPdiUnbreakable = getAttr ($fbody + ".unbreakable" );
        $defaultPdiBreakFrame = getAttr ($fbody + ".breakFrame" );  
	    $defaultPdiPropStyle = getAttr ($fbody + ".propStyle" );
		$defaultPdiPropChange = getAttr ($fbody + ".prStyleChange" );
		$defaultPdiPropFrame = getAttr ($fbody + ".prStyleChFrame" );
	    $defaultFBodyMass = getAttr ($fbody + ".mass" );
		$defaultPdiFBFriction = getAttr ($fbody + ".friction" );
	    $defaultPdiFBounciness = getAttr ($fbody + ".bounciness" );
		$defaultFBodyLdamping = getAttr ($fbody + ".linearDamping" );
		$defaultFBodyWdamping = getAttr ($fbody + ".angularDamping" );
		$defaultFBodyVelocity = getAttr ($fbody + ".initialVelocity" );
		$defaultFBodySpin = getAttr ($fbody + ".initialSpin" );
		$defaultPdiMayaFieldsFbody = getAttr ($fbody  + ".affectForceFields" );
		$defaultFbodySecCracksState = getAttr ($fbody  + ".secCracks" ); 
		$defaultFBodySecCracksPercent = getAttr ($fbody  + ".percentSecCracks" );
	}
	else
	{
//		print ("resetting PDI fracture defaults\n");

		$defaultFBodyStaticState=0;
		$defaultPDiFirstHitFbody = 1;
		$defaultFbodyActFrame = 1;
		$defaultPdiBreakThr = 50.0;
		$defaultPdiClusterize = 40;
		$defaultchkPdiSet2Mass = 1;
		$defaultPdiUnbreakable = 0;
		$defaultPdiBreakFrame = 1;
		$defaultPdiPropStyle = 0;
		$defaultPdiPropChange = 0;
		$defaultPdiPropFrame = 1;
		$defaultPdiFBFriction = 0.7;
		$defaultPdiFBounciness = 0.3;
		$defaultFBodyLdamping=0.010;
		$defaultFBodyWdamping=0.010;
		$defaultFBodyVelocity = <<0,0,0>>;
		$defaultFBodySpin = <<0,0,0>>;
		$defaultPdiMayaFieldsFbody = 0;
		$defaultFBodyMass = -1.0;//flag as invalid default
		$defaultFbodySecCracksState = 1;
		$defaultFBodySecCracksPercent = 5;
	}
}

global proc setPdiFbodyParamsToDefaults()
{
    global string $pdiFBodiesList;
    global string $butPdiFbodyFieldList;
	global int $defaultFBodyStaticState;
	global int $defaultPDiFirstHitFbody;
	global int $defaultFbodyActFrame;
    global float $defaultPdiBreakThr;
    global int $defaultPdiClusterize;
    global int $defaultchkPdiSet2Mass;
	global int $defaultPdiUnbreakable;	   
	global int $defaultPdiBreakFrame;
	global int $defaultPdiPropStyle;
	global int $defaultPdiPropChange;
	global int $defaultPdiPropFrame;
    global float $defaultFBodyMass;
    global float $defaultPdiFBFriction;
    global float $defaultPdiFBounciness;
    global float $defaultFBodyLdamping;    
    global float $defaultFBodyWdamping;    	 
	global vector $defaultFBodyVelocity;
	global vector $defaultFBodySpin;
    global int $defaultPdiMayaFieldsFbody;
    global int $defaultFbodySecCracksState;
    global int $defaultFBodySecCracksPercent;    

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;
    if( size( $selected) > 0)
    {
         waitCursor -state on;

		 string $pdiSolver = `pdiSolver`;
	     //int $startTime= getAttr ($pdiSolver + ".startFrame" );
		 //currentTime -edit $startTime;


		 int $animState = `queryPdiFBody -isAnim $selected[0]`;
		 if( $animState == 0)
		 {
			if( $defaultFBodyStaticState >=1)
			{
			  setAttr ($selected[0] + ".passive" ) true;
	    	  setAttr ($selected[0] + ".firstHitActive" ) $defaultPDiFirstHitFbody;
			}
			else
			{
			  setAttr ($selected[0] + ".passive" ) false;
	    	  setAttr ($selected[0] + ".firstHitActive" ) 0;
			}
			  setAttr ($selected[0] + ".actFrame" ) $defaultFbodyActFrame;
	         //force update
		     getAttr ($selected[0] + ".ca_passive" );
  		     getAttr ($selected[0] + ".ca_firstHit" );    	    
		 }
		 else
		 {
			if( $defaultFBodyStaticState == 0)
			{					
				print ( $selected[0] +" cannot be dynamic because has animation keys\n");			
			}
			setAttr ($selected[0] + ".actFrame" ) $defaultFbodyActFrame;
	    	setAttr ($selected[0] + ".firstHitActive" ) $defaultPDiFirstHitFbody;
  		    getAttr ($selected[0] + ".ca_firstHit" );    	    
		 }

    	 setAttr ($selected[0] + ".stressThreshold" ) $defaultPdiBreakThr;
//         setAttr ($selected[0] + ".usercommand" ) true;
         //force update
	     getAttr ($selected[0] + ".ca_stressThreshold" );

    	 setAttr ($selected[0] + ".randomThreshold" ) $defaultPdiClusterize;
//         setAttr ($selected[0] + ".usercommand" ) true;
         //force update
	     getAttr ($selected[0] + ".ca_randomThreshold" );

		if( $defaultchkPdiSet2Mass >= 1)
        {
    	    setAttr ($selected[0] + ".stress2mass" ) true;
        }
        else
        {
    	    setAttr ($selected[0] + ".stress2mass" ) false;
        }
         //force update
	     getAttr ($selected[0] + ".ca_stress2mass" );	    

		 if( $defaultPdiUnbreakable >= 1)
         {
    		setAttr ($selected[0] + ".unbreakable" ) true;  
		 }
		 else
		 {
    		setAttr ($selected[0] + ".unbreakable" ) false;  
		 }
		 setAttr ($selected[0] + ".breakFrame" ) $defaultPdiBreakFrame;  
         //force update
	     getAttr ($selected[0] + ".ca_unbreakable" );		  


	     setAttr ($selected[0] + ".propStyle" ) $defaultPdiPropStyle;
	     setAttr ($selected[0] + ".prStyleChange" ) $defaultPdiPropChange;
	     setAttr ($selected[0] + ".prStyleChFrame" ) $defaultPdiPropFrame;
         getAttr ($selected[0] + ".caps" );

		 if( $defaultFBodyMass > 0)
		 {
	        setAttr ($selected[0] + ".mass" ) $defaultFBodyMass;
		     //force update
			getAttr ($selected[0] + ".ca_mass" );
		 }
		 else
		 {
			//compute pdi mass
			update_Fbody -setmass $selected[0];
		 }

         setAttr ($selected[0] + ".bounciness" ) $defaultPdiFBounciness;
         //force update
	     getAttr ($selected[0] + ".ca_bounciness" );
         setAttr ($selected[0] + ".friction" ) $defaultPdiFBFriction;
         //force update
	     getAttr ($selected[0] + ".ca_friction" );

		 setAttr ($selected[0] + ".linearDamping" ) $defaultFBodyLdamping;
	     getAttr ($selected[0] + ".ca_airdamping" );
         setAttr ($selected[0] + ".angularDamping" ) $defaultFBodyWdamping;
    	 getAttr ($selected[0] + ".ca_angdamping" );

		 float $fvx,$fvy, $fvz;
		 $fvx = ($defaultFBodyVelocity.x);
		 $fvy = ($defaultFBodyVelocity.y);
		 $fvz = ($defaultFBodyVelocity.z);
    	 setAttr ($selected[0] + ".initialVelocity" ) -type "float3" $fvx $fvy $fvz;
         //force update
	     getAttr ($selected[0] + ".ca_initialVelocity" );

		 $fvx = ($defaultFBodySpin.x);
		 $fvy = ($defaultFBodySpin.y);
		 $fvz = ($defaultFBodySpin.z);
         setAttr ($selected[0] + ".initialSpin" ) -type "float3" $fvx $fvy $fvz;
         //force update
	     getAttr ($selected[0] + ".ca_initialSpin" );

		 if( $defaultPdiMayaFieldsFbody == 1)
         {
    	    setAttr ($selected[0] + ".affectForceFields" ) true;
         }
         else
         {
    	    setAttr ($selected[0] + ".affectForceFields" ) false;
         }
         //force update
         getAttr ($selected[0] + ".ca_forceFields" );

		 setAttr ($selected[0] + ".percentSecCracks" ) $defaultFBodySecCracksPercent ;

		 if( $defaultFbodySecCracksState == 1)
         {
    	    setAttr ($selected[0] + ".secCracks" ) true;
         }
         else
         {
    	    setAttr ($selected[0] + ".secCracks" ) false;
         }
         //force update
         getAttr ($selected[0] + ".ca_secCracks" );

		 string  $forceFields[];
         if( $defaultPdiMayaFieldsFbody > 0) 
         {
             $forceFields = `ls -tr -dag -leaf`;//note this includes all transform nodes in scene
         }
         pdiConnectForceFields -fbodyName $selected[0] -connect $forceFields ;

         button -e -enable $defaultPdiMayaFieldsFbody $butPdiFbodyFieldList;

		 updatePdiFbodyUIParams();

         waitCursor -state off;
	}
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a fracture body from the list"
        -button "OK" 
        -defaultButton "OK" ;
    }	
}
global proc updatePdiFbodyUIParams()
{
    global string $pdiFracturesWindow;
    global string $pdiFBodiesList;
    global string $fieldPdiBreakThr;
    global string $fieldPdiClusterize;
    global string $chkPdiEnabledFbody;
    global string $chkPdiSet2Mass;    
    global string $fieldPdiFMass;
    global string $fieldPdiFBFriction;
    global string $fieldPdiFBounciness;
    global string $fieldPdiFairdamping;    
    global string $fieldPdiFairdamping2;    
    global string $fieldPdiFVelocity;
    global string $fieldPdiFWelocity;
    global string $chkPdiMayaFieldsFbody;
    global string $selectedPdiFbody;
	global string $pdiLabelCurrentFbodyDyn;
	global string $pdiLabelCurrentFbodyAv;
	global string $namePdiFbody;
    global string $chkPdiTransFbody;
    global string $butPdiTransSourceObject;
    global string $chkPdiStaticFbody;     
   	global string $framePdiFactivation;  
   	global string $pdiFactivationCollection;  	
   	global string $pdiFA[3];
   	global string $fieldPdiFAFrame;
	global string $chkPdiBreakAfterFrame;
	global string $fieldPdiBreakAfterFrame;
    global string $pdiPropStyleCollection;
	global string $chkPdiPropStyleChange;
	global string $fieldPdiPropStyleFrame;
	global string $PdiFbodyFieldList;
    global string $butPdiFbodyFieldList;

   	global string $pdiPS[2];

	global string $pdiClustersList;
    global int $pdiUpdate;
       
    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;

    if( size( $selected) > 0)
    {
		if( `objExists $selectedPdiFbody`)
		{	   
			//turn off display stresses for previous selected fboby
	        int $PdiDisplayStresses = getAttr ($selectedPdiFbody + ".displayStressses" );
		    if( $PdiDisplayStresses==1)
			{
				setAttr( $selectedPdiFbody  + ".displayStressses" ) 0;

				//force update
				getAttr ($selectedPdiFbody  + ".cdst" );
				update_Fbody -dst false $selectedPdiFbody;
			}
			//deselect all clusters
			string $clusters[] = `listConnections -d true -type "ClusterPdiNode" $selectedPdiFbody`;
			if( size( $clusters) > 0)
			{
				for ( $obj in  $clusters )
				{
					setAttr(  $obj + ".selected" ) false;
					//force update
					getAttr ( $obj + ".ca_selected" );
				}
			}
		}

        $selectedPdiFbody = $selected[0];
		nameField -edit -object $selectedPdiFbody $namePdiFbody;
		string $labelNameFbody = ("Selected Fracture Body: " + $selectedPdiFbody);
		text -edit -label $labelNameFbody  $pdiLabelCurrentFbodyDyn;
		text -edit -label $labelNameFbody  $pdiLabelCurrentFbodyAv;

        $pdiUpdate = 0;//enable update			

	    float $breakThr = getAttr ($selected[0] + ".stressThreshold" );
	    float $fmass = getAttr ($selected[0] + ".mass" );
	    float $friction = getAttr ($selected[0] + ".friction" );
	    float $bounciness = getAttr ($selected[0] + ".bounciness" );
	    float $airdamping = getAttr ($selected[0] + ".linearDamping" );
	    float $angdamping = getAttr ($selected[0] + ".angularDamping" );
	    int $clusterize = getAttr ($selected[0] + ".randomThreshold" );
	    int $bEnabled = getAttr ($selected[0] + ".enabled" );
	    int $isFirstHit = getAttr ($selected[0] + ".firstHitActive" );
	    int $isStatic = getAttr ($selected[0] + ".passive" );
	    int $isUnbreakable = getAttr ($selected[0] + ".unbreakable" );
        int $breakFrame = getAttr ($selected[0] + ".breakFrame" );  
	    int $bEnabledS2M = getAttr ($selected[0] + ".stress2mass" );
        vector $velocity = getAttr ($selected[0] + ".initialVelocity" );
        vector $welocity = getAttr ($selected[0] + ".initialSpin" );
	    int $bForceFields = getAttr ($selected[0] + ".affectForceFields" );
	    int $propStyle = getAttr ($selected[0] + ".propStyle" );
        int $propStyleChange = getAttr ($selected[0] + ".prStyleChange" );
        int $actFrame = getAttr ($selected[0] + ".actFrame" );  
        int $propChangeFrame = getAttr ($selected[0] + ".prStyleChFrame" );  

		frameLayout -edit -enable $isStatic $framePdiFactivation;
		radioCollection -edit -select $pdiFA[$isFirstHit] $pdiFactivationCollection;	
	    checkBox -edit -value $isStatic $chkPdiStaticFbody;	    
	    intField -edit -value $actFrame $fieldPdiFAFrame;	
		intField -edit -value $breakFrame $fieldPdiBreakAfterFrame;
		
	    if( $isFirstHit==2)
		{
		    intField -edit -enable true $fieldPdiFAFrame;	
		}		
		else
		{
		    intField -edit -enable false $fieldPdiFAFrame;	
		}		
	        
        floatSliderGrp -edit -value $breakThr $fieldPdiBreakThr;
        floatSliderGrp -edit -value $friction $fieldPdiFBFriction;
        floatSliderGrp -edit -value $bounciness $fieldPdiFBounciness;
        floatSliderGrp -edit -value $airdamping $fieldPdiFairdamping;        
        floatSliderGrp -edit -value $angdamping $fieldPdiFairdamping2;        
        floatFieldGrp -edit -value1 $fmass $fieldPdiFMass;
        intSliderGrp -edit -value $clusterize $fieldPdiClusterize;
//	    checkBox -edit -value $bEnabledTor $chkPdiEnabledTorsion;
	    checkBox -edit -value $bEnabledS2M $chkPdiSet2Mass;
	    checkBox -edit -value $isUnbreakable $chkPdiBreakAfterFrame;	
		if( `radioCollection -ex $pdiPropStyleCollection` && $propStyle >= 0 && $propStyle < 2)
		{
			radioCollection -edit -select $pdiPS[$propStyle] $pdiPropStyleCollection;	
        }
	    checkBox -edit -value $propStyleChange  $chkPdiPropStyleChange;	    
	    if( $propStyleChange>0)
		{	
			intField -edit -enable true $fieldPdiPropStyleFrame;	
		}
		else
		{
			intField -edit -enable false $fieldPdiPropStyleFrame;	
		}
		intField -edit -value $propChangeFrame  $fieldPdiPropStyleFrame;

        if( $bEnabled > 0)
        {
	        checkBox -edit -value false $chkPdiEnabledFbody;	
        }
        else
        {
	        checkBox -edit -value true $chkPdiEnabledFbody;	
        }

	    if( $isUnbreakable )
		{
		    intField -edit -enable true $fieldPdiBreakAfterFrame;	
		}		
		else
		{
		    intField -edit -enable false $fieldPdiBreakAfterFrame;	
		}		

        string $forceFields[];
        $forceFields =`listConnections ($selectedPdiFbody +".fieldList")`;

        //fill  field list
		textScrollList -edit -removeAll  $PdiFbodyFieldList;
        for ( $obj in $forceFields)
	    {
            textScrollList -edit -append $obj  $PdiFbodyFieldList;
        }

	    checkBox -edit -value $bForceFields $chkPdiMayaFieldsFbody;

        floatFieldGrp  -edit
            -value1 ($velocity.x)
            -value2 ($velocity.y)
            -value3 ($velocity.z)
            $fieldPdiFVelocity;

        floatFieldGrp  -edit
            -value1 ($welocity.x)
            -value2 ($welocity.y)
            -value3 ($welocity.z)
            $fieldPdiFWelocity;

        
		int $isDynamic  = !$isStatic;
        floatFieldGrp  -edit -enable $isDynamic $fieldPdiFVelocity;
        floatFieldGrp  -edit -enable $isDynamic $fieldPdiFWelocity;

        floatSliderGrp -edit -enable $isDynamic $fieldPdiFairdamping;        
        floatSliderGrp -edit -enable $isDynamic $fieldPdiFairdamping2;        

//		print("fbody " + $selectedPdiFbody + " selected\n");			

        $pdiUpdate = 1;//enable update			

        string $allFbodies[];
        $allFbodies = `textScrollList -query -allItems $pdiFBodiesList`;

        for( $obj in $allFbodies)
        {
            setAttr( $obj + ".selected" ) false;

        }
        setAttr( $selectedPdiFbody + ".selected" ) true;

        //force update
	    getAttr ($selectedPdiFbody + ".ca_selected" );

// in the current implementation stresses view is always off  for unselected fracture bodies
//        int $PdiDisplayStresses = getAttr ($selectedPdiFbody + ".displayStressses" );
//        if( $PdiDisplayStresses==0)
//        {
//			update_Fbody -dst false $selectedPdiFbody;
//		}
//		else
//		{
//			update_Fbody -dst  true $selectedPdiFbody;
//		}

        //select fbody in maya viewport
		string $rbdlist[] = `listConnections -d on -s off  ($selectedPdiFbody + ".rigidBodies")`;
		if( size($rbdlist)>0)
		{
			select  $rbdlist[0];
	        refresh -force;
			select  -d $rbdlist[0];
		}

	    updatePdiAdvancedFracturesPanel();

//		setFocus MayaWindow;
//		evalDeferred -lp "setFocus MayaWindow";	 				
    }

}
global proc resetPdiFbodyParams()
{
	setDefaultsPdiFbodyParams("");
	setPdiFbodyParamsToDefaults();
}
global proc updatePdiFactivation()
{
    global int $pdiUpdate;
	if( $pdiUpdate==0)
	{
		return;	
	}	
//	print ("updatePdiFactivation\n");

	setStatePdiFBodyFirstHit();
}
global proc updatePdiFAframe()
{
    global string $pdiFBodiesList;
   	global string $fieldPdiFAFrame;

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;
    if( size( $selected) > 0)
    {
		int $actFrame = `intField -q -value $fieldPdiFAFrame`;	
    
		setAttr ($selected[0] + ".actFrame" ) $actFrame;
	}
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a fracture body from the list"
        -button "OK" 
        -defaultButton "OK" ;
    }	
}
global proc updatePDiBreakAfter()
{
	global string $pdiFBodiesList;
	global string $chkPdiBreakAfterFrame;
	global string $fieldPdiBreakAfterFrame;
   	  	
    string $pdiSolver[]=`ls -type pdiSolverNode`;
	if( size( $pdiSolver)>0)
	{
		string $connections[];
		$connections =`listConnections -d off -s on ($pdiSolver[0] + ".inTime")`;
		if( size( $connections)==0)
		{
			warning -noContext "Pdi dynamics has been disabled, delete all Pdi keys will enable it again ";
		}
	}
   	  	
    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;
    if( size( $selected) > 0)
    {
	    $state = `checkBox -q -value $chkPdiBreakAfterFrame`;	

		if( $state == true)
        {
    	    setAttr ($selected[0] + ".unbreakable" ) true;  
		    intField -edit -enable true $fieldPdiBreakAfterFrame;	
		    $frame = `intField -q -value $fieldPdiBreakAfterFrame`;	
			setAttr ($selected[0] + ".breakFrame" ) $frame;  
        }
        else
        {
    	    setAttr ($selected[0] + ".unbreakable" ) false;  
		    intField -edit -enable false $fieldPdiBreakAfterFrame;	
        }
         //force update
	     getAttr ($selected[0] + ".ca_unbreakable" );		  
    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a fracture body from the list"
        -button "OK" 
        -defaultButton "OK" ;

        checkBox -edit -value 0 $chkPdiBreakAfterFrame;       
    }
}
global proc updatePDiPropagationChange()
{
	global string $pdiFBodiesList;
	global string $chkPdiPropStyleChange;
	global string $fieldPdiPropStyleFrame;
   	  	
    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiFBodiesList`;
    if( size( $selected) > 0)
    {
	    $state = `checkBox -q -value  $chkPdiPropStyleChange`;	

		if( $state == true)
        {
    	    setAttr ($selected[0] + ".prStyleChange" ) true;  
		    intField -edit -enable true $fieldPdiPropStyleFrame;	
		    $frame = `intField -q -value $fieldPdiPropStyleFrame`;	
			setAttr ($selected[0] + ".prStyleChFrame" ) $frame;  
        }
        else
        {
    	    setAttr ($selected[0] + ".prStyleChange" ) false;  
		    intField -edit -enable false $fieldPdiPropStyleFrame;	
        }
         //force update
	     getAttr ($selected[0] + ".ca_propStyle" );		  
    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a fracture body from the list"
        -button "OK" 
        -defaultButton "OK" ;

        checkBox -edit -value 0 $chkPdiPropStyleChange;       
    }
}

global proc updateSelectedPdiFractureBody()
{
    global string $pdiFBodiesList;
    global string $selectedPdiFbody;

    int $bWExist = `window -ex winPdiBasicFractures`;
    if( $bWExist == false )
    {
        return;
    }

	string  $PDISelected[];
    $PDISelected = `ls -selection -dag -leaf -type pdiRigidBody`;

	string $orphanFragments[];
	string $properFragments[];
	//update current selected fbody from fragments 
    for ( $obj in $PDISelected )
    {
    	string  $connections[];
	    $connections = `listConnections -type pdiFbodyNode $obj`;

        if( size($connections) > 0 )
        {
			if( $connections[0] == $selectedPdiFbody)
			{
				$properFragments[size($properFragments)]= $obj;
			}
			else
			{
				$orphanFragments[size($orphanFragments)]= $obj;
			}
		}
	}

	if( size($properFragments)==0 && size($orphanFragments) > 0)
	{
		//update selected fbody in list
    	string  $connections[];
	    $connections = `listConnections -type pdiFbodyNode $orphanFragments[0]`;

	    if( size( $connections) > 0)
		{
			if($selectedPdiFbody!=$connections[0])
			{
//				$selectedPdiFbody = $connections[0];

					textScrollList -edit -selectItem $connections[0] $pdiFBodiesList;	
					updatePdiFbodyUIParams();              					
				}
			}
		}

//	updatePdiFragments();

	setFocus MayaWindow;    
}

global proc updatePdiFracturesPanel()
{
    global string $pdiFracturesWindow;
    global string $pdiFBodiesList;
    global string $selectedPdiFbody;

    int $bWExist = `window -ex winPdiBasicFractures`;
    int $bLstExist  = `textScrollList -ex $pdiFBodiesList`;//the window ex flag seem doesnt work
    if( $bWExist == false || $bLstExist == false)
    {
        return;
    }

    textScrollList -edit -removeAll $pdiFBodiesList;    
	string  $PDIFbodies[];
	$PDIFbodies = `ls -exactType pdiFbodyNode`;
	if(size($PDIFbodies) != 0)
	{
		$pdiUpdate = 0;//disable update		

    	for ( $obj in $PDIFbodies )
	    {
            textScrollList -edit -append $obj $pdiFBodiesList;
        }
		
	    if( `objExists $selectedPdiFbody` )
		{		
			textScrollList -edit -selectItem $selectedPdiFbody $pdiFBodiesList;		
			updatePdiFbodyUIParams();              
		}
		else
		{
			updateSelectedPdiFractureBody();
		}
    }

    showWindow $pdiFracturesWindow;
}

global proc showPdiAdvancedFracturesTab()
{
	global string $pdiFracturesWindowTabs;
	global string $pdiFracturesWindow;

    if ( !(`window -ex winPdiBasicFractures`) )
    {                
		createPdiFracturesPanel();
	}

	tabLayout -e -st pdiAdvFracturesTab $pdiFracturesWindowTabs;

	showWindow $pdiFracturesWindow;
	evalDeferred -lp "setFocus MayaWindow";
}
global proc showPdiShatteritTab()
{
	global string $pdiFracturesWindowTabs;
	global string $pdiFracturesWindow;

    if ( !(`window -ex winPdiBasicFractures`) )
    {                
		createPdiFracturesPanel();
	}

	tabLayout -e -st shatterItTab $pdiFracturesWindowTabs;

	//enable Shatter it drawing
	string $voronoiNodes[]= `ls -dag -type "pdiVoronoiNode"`;
	for($obj in $voronoiNodes)
	{
		string $transformNode[]=`listRelatives -p $obj`;
		showHidden $transformNode[0];
	}

	updatePdiShatterPanel();

	showWindow $pdiFracturesWindow;
	evalDeferred -lp "setFocus MayaWindow";
}

global proc showPdiBasicFracturesTab()
{
	global string $pdiFracturesWindowTabs;
	global string $pdiFracturesWindow;

    if ( !(`window -ex winPdiBasicFractures`) )
    {                
		createPdiFracturesPanel();
	}

	tabLayout -e -st pdiBasicFracturesTab $pdiFracturesWindowTabs;

	showWindow $pdiFracturesWindow;
	evalDeferred -lp "setFocus MayaWindow";
}

global proc updateSelectionPdiFractureWindow()
{
	global string $pdiFracturesWindowTabs;
	global string $pdiFracturesWindow;

	$selectedTab = `tabLayout -q -st $pdiFracturesWindowTabs`;
	if( $selectedTab == "pdiBasicFracturesTab")
	{
		updateSelectedPdiFractureBody();
	}
	else
	if( $selectedTab == "pdiAdvFracturesTab")
	{
	   updatePdiFragmentsJob();
	}
	else
	if( $selectedTab == "shatterItTab")
	{
	   updatePdiShatterPanel();
	}
//	else
//	if( $selectedTab == "pdiFbodyDynamicsTab")
//	{
//	}
}

global proc onSelectPdiFracturesTab()
{
	global string $pdiFracturesWindowTabs;

	$selectedTab = `tabLayout -q -st $pdiFracturesWindowTabs`;
	if( $selectedTab == "shatterItTab")
	{
		//enable Shatter it drawing
		string $voronoiNodes[]= `ls -dag -type "pdiVoronoiNode"`;
		for($obj in $voronoiNodes)
		{
			string $transformNode[]=`listRelatives -p $obj`;
			showHidden $transformNode[0];
		}
		updatePdiShatterPanel();
	}
	else
	{
		string $selectVoronode[] = `ls -selection -dag -type "pdiVoronoiNode"`;
		if(size($selectVoronode)>0)
		{
			//select shatter group when closing shatter window
			select -clear;
			$transformNode=`listRelatives -p  $selectVoronode[0]`;
			$ShatterGroup=`listRelatives -p $transformNode[0]`;
			select $ShatterGroup[0];
		}
		else
		{			
			if( $selectedTab == "pdiBasicFracturesTab")
			{
			updateSelectedPdiFractureBody();
		}
			else
			if( $selectedTab == "pdiAdvFracturesTab")
			{
			   updatePdiFragmentsJob();
			}
		}

		//disable Shatter it drawing
		string $voronoiNodes[]= `ls -dag -type "pdiVoronoiNode"`;
		for($obj in $voronoiNodes)
		{
			string $transformNode[]=`listRelatives -p $obj`;
			hide $transformNode[0];
		}

	}
	
//	print ($selectedTab +"\n");
}
global proc createPdiFracturesPanel()
{
    global string $pdiFracturesWindow;
	global string $pdiFracturesWindowTabs;
    global string $pdiFBodiesList;
	global string $namePdiFbody;
    global string $chkPdiEnabledFbody;
    global string $chkPdiStaticFbody;    
    global string $fieldPdiBreakThr;
    global string $fieldPdiClusterize;
    global string $chkPdiSet2Mass;
    global string $fieldPdiFMass;
    global string $fieldPdiFBFriction;
    global string $fieldPdiFBounciness;
    global string $fieldPdiFairdamping;
    global string $fieldPdiFairdamping2;
    global string $fieldPdiFVelocity;
    global string $fieldPdiFWelocity;
    global string $chkPdiMayaFieldsFbody;
    global string $butPdiFbodyFieldList;
    global string $bttPdiUpdateFbody;
    global string $framePdiPropStyle;
    global string $pdiPropStyleCollection;
   	global string $pdiPS[2];
   	global string $framePdiFactivation; 
   	global string $pdiFactivationCollection;  	
   	global string $pdiFA[3];
   	global string $fieldPdiFAFrame;
	global string $chkPdiBreakAfterFrame;
	global string $fieldPdiBreakAfterFrame;
	global string $chkPdiPropStyleChange;
	global string $fieldPdiPropStyleFrame;
    global string $selectedPdiFbody;
	global string $pdiLabelCurrentFbodyDyn;
	global string $PdiFbodyFieldList;

	global string $pdiLabelCurrentFbodyAv;
	global string $namePdiCluster;
    global string $chkPdiEnableSecCracks;    
    global string $fieldPdiPercentSecCracks;    
    global string $pdiFragmentsList;
    global string $pdiClustersList;
    global string $fieldPdiBreakForce;
	global string $chkPdiBreakableAtFrame;
    global string $fieldPdiBreakFrame;
    global string $fieldPdiBreakEnergy;

    global string $fieldPdiShatterItNumShards;
    global string $lblPdiCurrentShards;
    global string $fieldPdiShardsSeed;
    global string $pdiRadialAxisFrame;
    global string $pdiRadialAxiscollection;
	global string $pdiRAXIS[3];
	global int $pdimatcounter;
    global string $chkShItCreatePdiBodies;
	global string $chkShItDetectMeshGroups;
    global string $butPdiSelectPath;
    global string $chkShItAssignNewMat;
    global string $fieldPdiNumberOfCenters;
    global string $fieldPdiNumberOfRings;
    global string $fieldPdiRingsNoise;
    global string $fieldPdiShatterWidth;
    global string $comboShatterStyle;
//    global string $butPdiCustomMapping;
    global string $ShItCutMatName;    
	global string $butPdiUndoShatter;
	global string $butPdiResetShatter;
	global string $butPdiPreviewPoints;
    global string $chkShItUseVolumeShape;


    global int $UpdateSelectedPdiFractureWinJobId;
	//global int $disableStressesViewJobId;
    global int $pdiUpdate;

    //check if the window exists
    if ( `window -ex winPdiBasicFractures` )
    {                
        updatePdiFracturesPanel();
        
        return;
    }
    $pdiUpdate = 1;//enable update			

	string $baseName="pdiCutMat";
	string $cutMatName=$baseName+$pdimatcounter;    

	$pdiFracturesWindow = `window -rtf true -t "Pdi Fractures Window" -width 120 -height 210 winPdiBasicFractures`;
    $pdiFracturesWindowTabs = `tabLayout -innerMarginWidth 5 -innerMarginHeight 5 -cc "onSelectPdiFracturesTab"`;
// SHATTER IT TAB
	string $child0 = `columnLayout -adjustableColumn true -rs 10 shatterItTab`; 
	$fieldPdiShardsSeed = `intSliderGrp -cw 3 30 -label "Seed "-field true
								 -minValue -0 -maxValue 16 -value 0
                    			-ann " seed value diferent than 0 allows shatter repeteability"
								 -cc "updateShatterLocatorParams"
								 -dc "updateShatterLocatorParams"
								 pdiShardsSeed`;
    $fieldPdiShatterItNumShards = `intSliderGrp  -cw 3 80 -label "Num Shards" -field true
	            -minValue 2 -maxValue 64 -fieldMinValue 2 -fieldMaxValue 64
	            -ann " aprox. number of fragments"
				-value 64 -step 8
				 -cc "updateShatterLocatorParams"
				 -dc "updateShatterLocatorParams"
				 pdiNumShards`;

	$lblPdiCurrentShards = `text -label " "  -align "center"`;
	$butPdiPreviewPoints=`button  -w 100 -h 30 -label "Preview" -aop false
    	-ann " preview shatter points" -command "setShatteritPreviewMode"`;

	$comboShatterStyle = `optionMenu -width 30 -label "Shatter Style"
	            -ann " select style of the fragments generated" -cc "updateShatterStyle"`;
        menuItem -label "Uniform";
        menuItem -label "Local";
        menuItem -label "Radial";
        menuItem -label "Wood splinters";
        menuItem -label "Path Based";
        menuItem -label "Vertex Color";
        menuItem -label "Acquire";

//local shatter parameters   
    $fieldPdiNumberOfCenters = `intSliderGrp  -cw 3 80 -label "Num Centers" -field true
	-ann " set number of centers for local fragments"
    -minValue 1 -maxValue 5 -value 1 -step 1 -enable false
	-cc "updateShatteritPreview"
	-dc  "updateShatterLocatorParams"
	  pdiNumberOfCenters` ;	

    $fieldPdiShatterWidth = `floatSliderGrp -cw 3 80 -label "Width" -field true
	-ann " set average size of fragments"                
	-minValue 0.005 -maxValue 1.0 -pre 3 -value 0.2 -step 0.05 -enable false
	-cc "updateShatterLocatorParams"
	 -dc  "updateShatterLocatorParams"
	  pdiShatterWidth`;

//radial parameters
    $fieldPdiNumberOfRings = `intSliderGrp  -cw 3 80 -label "Num Rings" -field true
				-ann " set number of concentric rings afte shattering"                           
	            -minValue 1 -maxValue 20 -value 3 -step 1 -enable false
				-cc "updateShatterLocatorParams"
				-dc "updateShatterLocatorParams"
				pdiNumberOfRings`;

    $fieldPdiRingsNoise = `floatSliderGrp -cw 3 80  -label "Noise" -field true   
			-ann " add noise in radial fragments distance"                                
	        -minValue 0.0 -maxValue 2.0 -value 0.3 -pre 2 -step 0.1 -enable false
			-cc "updateShatterLocatorParams"
			 -dc "updateShatterLocatorParams"
			 pdiRingsNoise`;

    $pdiRadialAxisFrame = `frameLayout -label "Main Axis" -enable false
    			-ann " fragments will be generated around main axis" `;
    	rowLayout -numberOfColumns 3;
        	$pdiRadialAxiscollection = `radioCollection `;
	        $pdiRAXIS[0]=`radioButton -label "S (shortest)" -select -onc "updateShatteritPreview"`;
            $pdiRAXIS[1]=`radioButton -label "M (medium)" -onc "updateShatteritPreview"`;
	        $pdiRAXIS[2]=`radioButton -label "L (longest)" -onc "updateShatteritPreview"`;
	    setParent..;	
	    setParent..;	

	$chkShItUseVolumeShape = `checkBox -label "Use Volume Shape" -align "left"
        			-ann "use another shape as volume for shattering"
					-changeCommand "setUseVolumeShape"`;	           

    $butPdiSelectPath = `button  -w 100 -h 30 -label "Select Source Object" -aop true -bgc 0.4 0.4 0.4
    	-ann " select spline for path-based shatter" -command "pdiPickObject"`;

    frameLayout -width 100 -height 70 -label "Cut Material"
    			-ann " assign diferent material to cut faces" layOutCutMat;
        columnLayout -adjustableColumn false; 
		$chkShItAssignNewMat = `checkBox -label "apply" -align "left" -value true
            			-ann " cut faces will be mapped with this new material"`;	
			rowLayout -numberOfColumns 3;     
				text -label "Name:";			       			
				$ShItCutMatName = `textField -w 100 -h 20 -tx $cutMatName`;
		        $butShItNewMat = `button  -w 50 -h 20 -label "New"
            			-ann " create a new material"	              	              
						-command "pdiNewMaterialName"`;				           			 
				setParent..;
		    setParent..;
	    setParent..;

    $chkShItCreatePdiBodies = `checkBox -label "Create Rigid bodies from fragments" -align "left"
        			-ann " auto create rigid bodies from fragments"`;	              
    $chkShItDetectMeshGroups = `checkBox -label "Detach sub-meshes" -align "left"
        			-ann "detach mesh groups after shattering"`;	              


    string $butPdiShatterIt = `button  -w 80 -h 40 -label "Shatter It!"
            			-ann " trigger the shatter process"	              	              
						-command "pdiShatterIt"`;
	rowLayout -numberOfColumns 2 -columnWidth2 230 120 -adj 1
	    -columnAlign  1 "right"
		-columnAttach 1 "both"  0
		-columnAttach 2 "both"  0;

		$butPdiUndoShatter = `button  -w 230 -h 20 -label "Undo Last"
            			-ann " undo last shatter"	              	              
						-command "undoLastShatter"`;

		$butPdiResetShatter = `button  -w 120 -h 20 -label "Undo All"
            			-ann " reset all shattering"	              	              
						-command "pdiPrepareUndoAllShatter"`;
		setParent..;

    setParent..;

//BASIC FRACTURES TAB
    string $child1 = `formLayout -numberOfDivisions 200 pdiBasicFracturesTab`;
    $pdiLabelFbodies = `text -w 100 -font "boldLabelFont" -align "left" -label "Fracture Bodies"`;
    $pdiFBodiesList = `textScrollList -w 100 -numberOfRows 6 -allowMultiSelection false -selectCommand "updatePdiFbodyUIParams"` ;
    string $butCreate = `button  -w 100 -label "Create"
    -ann " Create a fracture body from selected"-command "createPdiFbody"`;
    string $butDelete =`button  -w 100 -label "Delete"
    -ann " Delete selected fracture body"    -command "deletePDIFractureBody"`;
    string $butDeleteAll =`button  -w 80 -label "Delete All"
    -ann " Delete all fracture bodies in scene"        -command "deleteAllPdiFbodies"`;
	$namePdiFbody =`nameField -object "" -ncc OnChangeNameFbody`;

    $chkPdiEnabledFbody = `checkBox -label "Disabled"  -enable 1
    -ann " enable/disable selected fracture body from computing" -changeCommand "setStatePdiFBody"`;
    $chkPdiStaticFbody = `checkBox -label "Static" -enable 1 -v false
    -ann "static fracture bodies can break but doesnt move" -changeCommand "setStatePdiFBodyStatic"`;
	          
    $framePdiFactivation = `frameLayout -width 100 -height 50 -label "Activation"`;
		rowLayout -columnWidth4 90 90 80 60 -numberOfColumns 4;
		$pdiFactivationCollection=`radioCollection`;
		$pdiFA[0]=`radioButton -label "Only Breaks"  -ann "object doenst move but breaks upon impact" -onc "updatePdiFactivation"`;
		$pdiFA[1]=`radioButton -label "At First Hit" -select -ann " becomes dynamics at first collision with other object" -onc "updatePdiFactivation"`;
		$pdiFA[2]=`radioButton -label "At Frame" -ann " becomes dynamics at specified frame" -onc "updatePdiFactivation"`;
		$fieldPdiFAFrame = `intField -w 50 -value 1 -ann " set activation frame" -changeCommand "updatePdiFAframe"`;  
		setParent..;
    setParent..;

    string $butDisplayStresses =`button  -w 120 -h 40 -label "Switch On/Off stresses view"
	-ann "turn on stresses view to check distribution of brittleness"            	        	        	        	        	            	                            
     -command "setDisplayStresses"`;

    string $butSetFractureDefaults =`button  -w 120 -h 30 -label "Set All Values to Defaults"
	-ann "set all values to defaults for selected fracture body"            	        	        	        	        	            	                            
     -command "resetPdiFbodyParams"`;
          
    $fieldPdiBreakThr = `floatSliderGrp -label "Hardness" -field true -v 100.0
	        -minValue 0.0 -maxValue 1000.0 -fieldMaxValue 1000000.0
	        -ann "set overall brittleness for the object"
            -changeCommand "setPptyPdiBreakTreshold"` ;
    $fieldPdiClusterize = `intSliderGrp -label "Clusterize(%)" -field true -v 40
	        -minValue 0 -maxValue 100 
	        -ann "forces object to break in clusters of fragments"
            -changeCommand "setPptyPdiClusterize"` ;	
                  
    $chkPdiSet2Mass = `checkBox -label "relative to mass" -enable true
	-ann "enable/disable stresses values relative to fragments mass"            	        	        	        	        	            	            
     -changeCommand "SetPdiStresses2Mass"`;	              
	      
    $chkPdiBreakAfterFrame = `checkBox -label "Unbreakable Until Frame" 
			-value false -enable 1 -ann "keep object unbreakable until this frame"
			-changeCommand "updatePDiBreakAfter"`;	              
    $fieldPdiBreakAfterFrame = `intField -w 40 -enable 0
			-value 1 -changeCommand "updatePDiBreakAfter" 
			-ann "frame at which object is allow to break" `;            

    $framePdiPropStyle = `frameLayout -width 100 -height 50 -label "Propagation scheme"`;
//    rowLayout -columnWidth2 100 100 -numberOfColumns 2;
	  rowLayout -columnWidth4 90 70 120 60 -numberOfColumns 4;
        $pdiPropStyleCollection=`radioCollection`;
        $pdiPS[0]=`radioButton -label "Continuous" -select -ann "cracks propagate across the object" -onc "updatePdiPropStyle"`;
        $pdiPS[1]=`radioButton -label "Local" -ann "break only on colision areas" -onc "updatePdiPropStyle"`;
	    $chkPdiPropStyleChange = `checkBox -label "Change at Frame" 
			-value false -enable 1 -ann "change propagation after choosed frame"
			-changeCommand "updatePDiPropagationChange"`;	              
	    $fieldPdiPropStyleFrame = `intField -w 40 -enable 0
			-value 1 -changeCommand "updatePDiPropagationChange" 
			-ann "frame at which propagation style changes" `;            

        setParent..;
        setParent..;

    $bttPdiUpdateFbody = `button  -w 120 -h 30 -label "Update Transform"
	-ann " update transform after rotating/scaling/trasnlating fracture body in viewport"            	        	        	        	        	            	                                
     -command "updateTransformFbdody"`;
     
	setParent..;
    
    formLayout -edit
        -attachForm     $pdiLabelFbodies      "top"    10
        -attachForm     $pdiLabelFbodies      "left"    5
        -attachControl     $pdiFBodiesList    "top"   0 $pdiLabelFbodies
        -attachForm     $pdiFBodiesList      "left"    5
        -attachForm     $pdiFBodiesList      "right" 5
        -attachForm     $pdiFBodiesList			"bottom" 500
        -attachControl     $butCreate      "top"    0 $pdiFBodiesList
        -attachForm     $butCreate      "left"   5
        -attachControl      $butDelete      "top"    0 $pdiFBodiesList
        -attachControl     $butDelete     "left" 0 $butCreate
        -attachControl      $butDeleteAll      "top"    0 $pdiFBodiesList
        -attachControl     $butDeleteAll     "left" 0 $butDelete      
        -attachForm        $butDeleteAll     "right" 5  
        -attachControl  $namePdiFbody			"top"		10  $butDeleteAll 
        -attachForm     $namePdiFbody			"left"    5
        -attachForm     $namePdiFbody			"right"   5		
        -attachForm     $butDisplayStresses      "left" 5   
        -attachForm     $butDisplayStresses      "right" 5   
        -attachControl  $butDisplayStresses    "top" 20 $namePdiFbody          
        -attachControl  $chkPdiStaticFbody     "top" 5 $butDisplayStresses
        -attachForm		$chkPdiStaticFbody      "left" 30 
        -attachControl  $chkPdiEnabledFbody      "top" 5 $butDisplayStresses
        -attachControl	$chkPdiEnabledFbody      "left" 10  $chkPdiStaticFbody 
        -attachForm   $framePdiFactivation      "left" 5   
        -attachForm   $framePdiFactivation     "right" 5   
        -attachControl  $framePdiFactivation    "top" 5 $chkPdiStaticFbody        
        -attachControl  $fieldPdiBreakThr     "top" 10 $framePdiFactivation
        -attachForm     $fieldPdiBreakThr       "left" 0 
        -attachControl  $fieldPdiClusterize     "top" 10 $fieldPdiBreakThr
        -attachForm     $fieldPdiClusterize       "left" 0 
        -attachForm		$chkPdiSet2Mass			"left" 150
        -attachControl  $chkPdiSet2Mass			"top" 5 $fieldPdiClusterize
        -attachForm		$chkPdiBreakAfterFrame  "left" 150 
        -attachControl  $chkPdiBreakAfterFrame	"top" 5 $chkPdiSet2Mass
        -attachControl  $fieldPdiBreakAfterFrame "top" 5 $chkPdiSet2Mass
        -attachControl  $fieldPdiBreakAfterFrame "left" 5 $chkPdiBreakAfterFrame	
        -attachForm   $framePdiPropStyle      "left" 5   
        -attachForm   $framePdiPropStyle      "right" 5   
        -attachControl  $framePdiPropStyle    "top" 5 $chkPdiBreakAfterFrame
        -attachForm     $butSetFractureDefaults  "left" 0   
        -attachForm     $butSetFractureDefaults  "right" 0   
        -attachControl  $butSetFractureDefaults   "top" 10  $framePdiPropStyle                   		          
        -attachControl  $bttPdiUpdateFbody  "top" 10   $butSetFractureDefaults
        -attachForm   $bttPdiUpdateFbody   "left" 0                 
        -attachForm   $bttPdiUpdateFbody   "right" 0                         

    $child1;

//FBODIES DYNAMICS TAB
	string $child2 = `formLayout -numberOfDivisions 200 pdiFbodyDynamicsTab`;
		$pdiLabelCurrentFbodyDyn = `text -w 380 -font "smallBoldLabelFont" -bgc 0.7 0.7 0.7 -align "left" -label "Non Selected Fracture Body!"`;
		$fieldPdiFMass = `floatFieldGrp -numberOfFields 1 -label "Mass" 
			-value1 1.0  -pre 2
			-ann " set mass for the fracture body"            
			-changeCommand "setPptyPdiFMass"` ;
		$fieldPdiFBFriction = `floatSliderGrp -label "Friction" -field true
			-minValue 0.0 -maxValue 1.0 -v 0.7 -pre 3
			-ann " set friction coefficient for the fracture body"                    
			-changeCommand "setPptyPdiFBFriction"` ;
		$fieldPdiFBounciness = `floatSliderGrp -label "Bounciness" -field true
			-minValue 0.0 -maxValue 1.0 -v 0.3 -pre 3
			-ann " set bounciness for the fracture body"                    
			-changeCommand "setPptyPdiFBounciness"` ;
		$fieldPdiFairdamping = `floatSliderGrp -label "Linear Damping" -field true
			-minValue 0.0 -maxValue 1.0 -v 0.01 -pre 3
			-ann "set linear damping value"            	        
			-changeCommand "setPptyPdiFAirdamping"` ;
		$fieldPdiFairdamping2 = `floatSliderGrp -label "Angular Damping" -field true
			-minValue 0.0 -maxValue 1.0 -v 0.01 -pre 3
			-ann "set angular damping value"            	        
			-changeCommand "setPptyPdiFAngulardamping"` ;        
		$fieldPdiFVelocity = `floatFieldGrp -numberOfFields 3 -label "Initial Velocity" 
					-value1 0.0 -value2 0.0 -value3 0.0 
					-ann " set initial linear velocity for the fracture body"                    	             
					-changeCommand "setPptyFVelocity"` ;
		$fieldPdiFWelocity = `floatFieldGrp -numberOfFields 3 -label "Initial Spin" 
					-value1 0.0 -value2 0.0 -value3 0.0  
					-ann " set initial angular velocity for the fracture body"                    	             	            
					-changeCommand "setPptyFWelocity"` ;
    $chkPdiMayaFieldsFbody = `checkBox -label "affected by Force Fields" -enable 1
	-ann "enable/disable force fields affecting the motion of the fracture body"            	        	        	        	        	            	            
     -changeCommand "setStatePdiMayaFieldsFbody"`;	              
    $pdiLabelFbodiesFields = `text -w 100 -font "boldLabelFont" -align "left" -label "Affecting Fields"`;
    $PdiFbodyFieldList = `textScrollList -w 100 -numberOfRows 5 -allowMultiSelection false ` ;	             
    $butPdiFbodyFieldList =`button  -enable false -w 10 -label "Include/Exclude"
	-ann "select the fields affecting the motion of the fracture body"            	        	        	        	        	            	                        
     -command "pdiExcludeIncludeFbodyFields"`;

	setParent..;

    formLayout -edit
        -attachForm     $pdiLabelCurrentFbodyDyn    "top"    10   
        -attachForm     $pdiLabelCurrentFbodyDyn    "left"    5
        -attachControl  $fieldPdiFMass				"top"    10 $pdiLabelCurrentFbodyDyn
        -attachForm		$fieldPdiFMass				"left" 0 
        -attachControl     $fieldPdiFBFriction     "top" 10 $fieldPdiFMass
        -attachForm  $fieldPdiFBFriction			"left" 0 
        -attachControl     $fieldPdiFBounciness     "top" 10 $fieldPdiFBFriction
        -attachForm  $fieldPdiFBounciness			"left" 0      
        -attachControl     $fieldPdiFairdamping     "top" 10 $fieldPdiFBounciness
        -attachForm  $fieldPdiFairdamping			"left" 0              
        -attachControl     $fieldPdiFairdamping2     "top" 10 $fieldPdiFairdamping 
        -attachForm  $fieldPdiFairdamping2			"left" 0              
        -attachControl      $fieldPdiFVelocity		"top" 10 $fieldPdiFairdamping2
        -attachForm   $fieldPdiFVelocity			"left" 0 
        -attachControl      $fieldPdiFWelocity		"top" 10 $fieldPdiFVelocity
        -attachForm   $fieldPdiFWelocity			"left" 0     
        -attachControl  $chkPdiMayaFieldsFbody		"top" 5 $fieldPdiFWelocity 
        -attachForm   $chkPdiMayaFieldsFbody		"left" 150   
        -attachControl     $pdiLabelFbodiesFields		"top"   5  $chkPdiMayaFieldsFbody
        -attachForm     $pdiLabelFbodiesFields      "left"    5
        -attachForm     $pdiLabelFbodiesFields      "right"    5  		  
        -attachControl     $PdiFbodyFieldList    "top"   0 $pdiLabelFbodiesFields
        -attachForm     $PdiFbodyFieldList      "left"    5
        -attachForm     $PdiFbodyFieldList      "right" 5
        -attachControl   $butPdiFbodyFieldList		"top" 5 $PdiFbodyFieldList  
        -attachForm   $butPdiFbodyFieldList			"left" 5  
        -attachForm   $butPdiFbodyFieldList			"right" 5  

    $child2;

//ADVANCED FRACTURES TAB

    string $child3 = `formLayout -numberOfDivisions 200 pdiAdvFracturesTab`;
		$pdiLabelCurrentFbodyAv = `text -w 380 -font "smallBoldLabelFont" -bgc 0.7 0.7 0.7 -align "left" -label "Non Selected Fracture Body!"`;
	    string $framePdiSecCracks = `frameLayout -width 100 -height 50 -label "Secundary Cracks"`; 
        rowColumnLayout -numberOfRows 1 -co 1 "left" 14;
			$chkPdiEnableSecCracks = `checkBox -label "enabled" -align "left" -value true -enable 1 -changeCommand "updatePidSecCracks"`;	              
			text -label "% Volume"  -align "left";   
			$fieldPdiPercentSecCracks = `intField -w 30 -value 5 -changeCommand "updatePidSecCracks" -ann "min volume of the fragment to be cracked" `;            
			setParent..;
		setParent..;
		string $pdiLabelFragments = `text -w 120 -font "smallBoldLabelFont" -align "left" -label "Fragments"`;
	    $pdiFragmentsList = `textScrollList -w 100 -numberOfRows 8 -allowMultiSelection true `;
	    string $butSelectSimilar =`button  -w 100 -label "Increase Selection" -command "selectSimilarPdiFragments"`;
		string $butSetStatic =`button  -w 100 -label "Set Static" -command "setStaticPdiFragments"`;
		string $butSetDynamic =`button  -w 100 -label "Set Dynamic" -command "setDynamicPdiFragments"`;
		string $butDetach =`button  -w 100 -label "Detach" -command "detachPdiFragments"`;
	    string $butCreateCluster =`button  -w 100 -label "Create Cluster" -command "createPdiCluster"`;
	    string $pdiLabelClusters = `text -w 120 -font "smallBoldLabelFont" -align "left" -label "Clusters"`;
		$pdiClustersList = `textScrollList -w 100 -numberOfRows 5 -allowMultiSelection false -selectCommand "updatePdiClusters"` ;
		string $butDeleteCluster = `button  -w 100 -label "delete" -command "deletePdiCluster"`;
		string $butDeleteAllClusters = `button  -w 80 -label "delete all" -command "deleteAllPdiCluster"`;
		$namePdiCluster =`nameField -object "" -ncc updatePdiAdvancedFracturesPanel`;
		$fieldPdiBreakForce = `floatSliderGrp -cw 3 80 -label "hardness" -field true
	        -minValue 0.0 -maxValue 1000.0  -fieldMaxValue 1000000.0
            -changeCommand "setHardnessPdiCluster"` ;
	    $chkPdiBreakableAtFrame = `checkBox -label "Unbreakable until Frame" -enable 1 -value 0 -changeCommand "setBreakableAtFramePdiCluster"`;
		$fieldPdiBreakFrame = `intSliderGrp -cw 3 80 -enable false -label "Break Frame" -field true
	        -minValue 0 -maxValue 1000 
            -changeCommand "setBreakFramePdiCluster"` ;
		$fieldPdiBreakEnergy = `floatSliderGrp -cw 3 80 -label "Break Energy" -field true
	        -minValue 0.0 -maxValue 100.0 -fieldMaxValue 1000.0
            -changeCommand "setBreakEnergyPdiCluster"` ;

    setParent ..;
    
    formLayout -edit
        -attachForm     $pdiLabelCurrentFbodyAv      "top"    10   
        -attachForm     $pdiLabelCurrentFbodyAv      "left"    5
        -attachForm     $framePdiSecCracks			"left" 5   
        -attachForm     $framePdiSecCracks			"right" 5   
        -attachControl  $framePdiSecCracks			"top" 10 $pdiLabelCurrentFbodyAv        
        -attachControl     $pdiLabelFragments      "top"    10 $framePdiSecCracks 
        -attachForm     $pdiLabelFragments			"left"    0
        -attachControl     $pdiFragmentsList		"top"   0 $pdiLabelFragments
        -attachForm     $pdiFragmentsList			"left"    0
        -attachForm     $pdiFragmentsList			"right" 0
        -attachForm     $pdiFragmentsList			"bottom" 440
        -attachControl  $butSelectSimilar			"top"    0 $pdiFragmentsList
        -attachForm         $butSelectSimilar			"left" 0 
        -attachForm       $butSelectSimilar				"right" 0 		
        -attachControl      $butSetStatic			"top"    20 $butSelectSimilar
        -attachForm         $butSetStatic			"left" 0 
        -attachForm       $butSetStatic				"right" 0 
        -attachControl      $butSetDynamic			"top"    0 $butSetStatic
        -attachForm        $butSetDynamic			"left" 0 
        -attachForm       $butSetDynamic			"right" 0 
        -attachControl    $butDetach				"top"    0 $butSetDynamic
        -attachForm       $butDetach				"left" 0 
        -attachForm       $butDetach				"right" 0   
        -attachControl      $butCreateCluster      "top"    0 $butDetach
        -attachForm        $butCreateCluster		"left" 0 
        -attachForm       $butCreateCluster		"right" 0 		      
		-attachControl    $pdiLabelClusters		"top"    10 $butCreateCluster
        -attachForm		$pdiLabelClusters			"left"    0
        -attachControl     $pdiClustersList		"top"   0 $pdiLabelClusters
        -attachForm     $pdiClustersList			"left"    0
        -attachForm     $pdiClustersList			"right" 0
        -attachControl  $butDeleteCluster			"top"    0 $pdiClustersList
        -attachForm		$butDeleteCluster			"left"   0 
        -attachControl  $butDeleteAllClusters      "top"    0 $pdiClustersList
        -attachControl  $butDeleteAllClusters      "left"   0 $butDeleteCluster
        -attachForm     $butDeleteAllClusters      "right" 0
        -attachControl  $namePdiCluster				"top"		10  $butDeleteAllClusters 
        -attachForm     $namePdiCluster				"left"    0
        -attachForm     $namePdiCluster				"right"   0		
        -attachControl  $fieldPdiBreakForce			"top" 10 $namePdiCluster 
        -attachForm		$fieldPdiBreakForce			"left" 10 
        -attachControl  $fieldPdiBreakEnergy		"top" 10 $fieldPdiBreakForce
        -attachForm     $fieldPdiBreakEnergy		"left" 10 
        -attachControl  $chkPdiBreakableAtFrame		"top" 10 $fieldPdiBreakEnergy
        -attachForm		$chkPdiBreakableAtFrame		"left" 10 		
        -attachControl  $fieldPdiBreakFrame			"top" 10 $chkPdiBreakableAtFrame 
        -attachForm		$fieldPdiBreakFrame			"left" 10 
    
    $child3;

    tabLayout -edit
    	-tabLabel $child0 "Shatter it"
    	-tabLabel $child1 "Basic Fractures"
    	-tabLabel $child2 "Dynamic Properties"
		-tabLabel $child3 "Advanced Fractures"
    $pdiFracturesWindowTabs;


    $UpdateSelectedPdiFractureWinJobId = `scriptJob -event SelectionChanged updateSelectionPdiFractureWindow`;
//    $disableStressesViewJobId = `scriptJob -event modelEditorChanged disableStressesViewVp20`;

    scriptJob -uiDeleted $pdiFracturesWindow killPdiFractureWindowJobId;

    updatePdiFracturesPanel();
}

/////////////////////////////////////////////////
//  
//  Advanced Fractures Panel
//
/////////////////////////////////////////////////
global proc setBreakEnergyPdiCluster()
{
    global string $pdiClustersList;
    global string $fieldPdiBreakEnergy;
    global string $pdiFBodiesList;

    global int $pdiUpdate;
	if( $pdiUpdate==0)
	{
		return;	
	}	

    string $selectedCluster[] = `textScrollList -query -selectItem $pdiClustersList`;

    if( size( $selectedCluster) > 0)
    {
        float $value = `floatSliderGrp -q -value $fieldPdiBreakEnergy`;	

        setAttr( $selectedCluster[0] + ".breakEnergy" ) $value;
        //force update
	    getAttr ( $selectedCluster[0] + ".ca_breakEnergy" );

		$selectedFbody = `textScrollList -query -selectItem $pdiFBodiesList`;
        int $PdiDisplayStresses = getAttr ($selectedFbody[0] + ".displayStressses" );
        if( $PdiDisplayStresses==1)
        {
			update_Fbody -map $selectedFbody[0];
		}
    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a cluster from the list"
        -button "OK" 
        -defaultButton "OK" ;
    }

}
global proc setHardnessPdiCluster()
{
    global string $pdiClustersList;
    global string $fieldPdiBreakForce;
    global string $pdiFBodiesList;

    global int $pdiUpdate;
	if( $pdiUpdate==0)
	{
		return;	
	}	

    string $selectedCluster[] = `textScrollList -query -selectItem $pdiClustersList`;
    if( size( $selectedCluster) > 0)
	{
        float $value = `floatSliderGrp -q -value $fieldPdiBreakForce`;	

        setAttr( $selectedCluster[0] + ".stressThreshold" ) $value;
        //force update
	    getAttr ($selectedCluster[0] + ".ca_stressThreshold" );

		$selectedFbody = `textScrollList -query -selectItem $pdiFBodiesList`;
        int $PdiDisplayStresses = getAttr ($selectedFbody[0] + ".displayStressses" );
        if( $PdiDisplayStresses==1)
        {
			update_Fbody -map $selectedFbody[0];
		}
    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a cluster from the list"
        -button "OK" 
        -defaultButton "OK" ;
    }

}
global proc setBreakableByForcePdiStress()
{
    global string $pdiClustersList;
    global string $fieldPdiBreakForce;

    global int $pdiUpdate;
	if( $pdiUpdate==0)
	{
		return;	
	}	

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiClustersList`;
    if( size( $selected) > 0)
    {
        int $value = 1;	

        for( $obj in $selected)
        {

            if( $value > 0)
            {
    	        setAttr( $obj + ".breakByForce" ) true;
            }
            else
            {
    	        setAttr( $obj + ".breakByForce" ) false;
            }
             //force update
	         getAttr ($obj + ".ca_breakByForce" );
        }
		//update window
		if( $value > 0)
		{
			floatSliderGrp -edit -enable true $fieldPdiBreakForce;
		}
		else
		{
			floatSliderGrp -edit -enable false $fieldPdiBreakForce;
		}                        
    }

}
global proc setBreakFramePdiCluster()
{
    global string $pdiClustersList;
    global string $fieldPdiBreakFrame;

    global int $pdiUpdate;
	if( $pdiUpdate==0)
	{
		return;	
	}	

    string $selectedCluster[] = `textScrollList -query -selectItem $pdiClustersList`;
    if( size( $selectedCluster) > 0)
    {
        int $value = `intSliderGrp -q -value $fieldPdiBreakFrame`;	

        setAttr( $selectedCluster[0] + ".breakFrame" ) $value;
        //force update
	    getAttr ($selectedCluster[0] + ".ca_breakFrame" );

    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a cluster from the list"
        -button "OK" 
        -defaultButton "OK" ;
    }
}
global proc setBreakableAtFramePdiCluster()
{
    global string $pdiClustersList;
    global string $fieldPdiBreakFrame;
	global string $chkPdiBreakableAtFrame;

    global int $pdiUpdate;
	if( $pdiUpdate==0)
	{
		return;	
	}	

    string $selectedCluster[] = `textScrollList -query -selectItem $pdiClustersList`;
    if( size( $selectedCluster) > 0)
    {
	    $bBreakableAtFrame = `checkBox -query -value $chkPdiBreakableAtFrame`;

        setAttr( $selectedCluster[0] + ".breakByFrame" ) $bBreakableAtFrame;
        //force update
	    getAttr ($selectedCluster[0] + ".ca_breakByFrame" );

        
        //update window
		if( $bBreakableAtFrame > 0)
		{
			intSliderGrp -edit -enable true $fieldPdiBreakFrame;
		}
		else
		{
			intSliderGrp -edit -enable false $fieldPdiBreakFrame;
		}           
    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a cluster from the list"
        -button "OK" 
        -defaultButton "OK" ;
    }
}


global proc detachPdiFragments()
{
    global string $pdiFragmentsList;
    global string $selectedPdiFbody;

	string $result = `confirmDialog -title "Confirm"
	 -message "This action will detach selected fragments permanently, consider using create cluster instead , proceed?"
	-button "Yes" -button "No" -defaultButton "Yes"
	-cancelButton "No" -dismissString "No"`;

	if( $result == "Yes")
	{
		string $selection[];
		$selection = `textScrollList -query -selectItem $pdiFragmentsList`;

		if( size($selection) == 0)
		{
			$selection = `textScrollList -query -allItems $pdiFragmentsList`;	
		}

		if( size($selection) > 0)
		{
			waitCursor -state on;

			if( `objExists $selectedPdiFbody`)
			{	   
				//turn off display stresses for previous selected fboby
				int $PdiDisplayStresses = getAttr ($selectedPdiFbody + ".displayStressses" );
				if( $PdiDisplayStresses==1)
				{
					setAttr( $selectedPdiFbody  + ".displayStressses" ) 0;

					//force update
					getAttr ($selectedPdiFbody  + ".cdst" );
					update_Fbody -dst false $selectedPdiFbody;
				}
			}
			
			Detach_FBody $selection;

			for( $obj in $selection)
			{
				textScrollList -edit -ri $obj $pdiFragmentsList;
			}

//			polyOptions -cs false;

			waitCursor -state off;
		}
		else
		{
			error -noContext "selected fragments doesnt belong to  a cluster or diferent fracture body";
		}
	}

}
global proc updatePdiClusters()
{
    global string $pdiFracturesWindow;
	global string $pdiFracturesWindowTabs;
    global string $pdiClustersList;
    global string $fieldPdiBreakFrame;
    global string $fieldPdiBreakForce;
    global string $fieldPdiBreakEnergy;
	global string $fieldPdiBreakForce;
    global string $fieldPdiBreakEnergy;
	global string $chkPdiBreakableAtFrame;
	global string $namePdiCluster;
    global int $pdiUpdate;    

    $pdiUpdate = 0;//disable update		

    int $bWExist = `window -ex winPdiBasicFractures`;
    int $bListExist  = `textScrollList -ex $pdiClustersList`;//the window ex flag seem doesnt work
    if( $bWExist == false || $bListExist == false)
    {
        return;
    }

	//deselect all clusters
    string $sel_iTems_list[] = `textScrollList -q -allItems $pdiClustersList`;
	for ( $obj in $sel_iTems_list )
	{
	   int $isSelected = getAttr ($obj + ".selected" );
	   if($isSelected>0)
		{
			setAttr( $obj + ".selected" ) false;
			//force update
			getAttr ($obj + ".ca_selected" );
		}
	}

	clear($sel_iTems_list);
    $sel_iTems_list = `textScrollList -q -si $pdiClustersList`;
	if( size($sel_iTems_list) > 0)
	{		
		select -clear;//clear any previusly selected fragment

		string $selectedCluster = $sel_iTems_list[0];
//		clear($connections);
//	    $connections = `listConnections -type pdiRigidBody $selectedCluster`;
//		for ( $obj in $connections )
//      {
//			setAttr ($obj + ".selected" ) 1;
			//force update 
//			getAttr ($obj + ".ca_selected" );            
//		}
        setAttr( $selectedCluster + ".selected" ) true;
        //force update
	    getAttr ($selectedCluster + ".ca_selected" );

		//show cluster properties in the ui
        float $breakForce = getAttr ($selectedCluster + ".stressThreshold" );
        float $breakEnergy = getAttr ($selectedCluster + ".breakEnergy" );
        int $breakFrame = getAttr ($selectedCluster + ".breakFrame" );
        int $breakablebyFrame = getAttr ($sel_iTems_list[0] + ".breakByFrame" );

		nameField -edit -object $selectedCluster $namePdiCluster;
	    floatSliderGrp -edit -enable true $fieldPdiBreakForce;
        floatSliderGrp -edit -value $breakForce $fieldPdiBreakForce;
        floatSliderGrp -edit -enable true  $fieldPdiBreakEnergy;
        floatSliderGrp -edit -value $breakEnergy  $fieldPdiBreakEnergy;
        checkBox -edit  -enable true $chkPdiBreakableAtFrame;		
        checkBox -edit -value $breakablebyFrame $chkPdiBreakableAtFrame;		
        intSliderGrp -edit -enable $breakablebyFrame $fieldPdiBreakFrame;        
        intSliderGrp -edit -value $breakFrame $fieldPdiBreakFrame;        
	}
	else
	{
		nameField -edit -object "" $namePdiCluster;
	    floatSliderGrp -edit -enable false $fieldPdiBreakForce;
        floatSliderGrp -edit -enable false  $fieldPdiBreakEnergy;
        intSliderGrp -edit -enable false $fieldPdiBreakFrame;        
        checkBox -edit  -enable false $chkPdiBreakableAtFrame;		
	}

    $pdiUpdate = 1;//enable update
	
	evalDeferred -lp "setFocus MayaWindow;";	 				
}

global proc updatePdiFragmentsJob()
{
//	print("updatePdiFragments\n");	

	 updatePdiFragments();
}

global proc updatePdiFragments()
{
	global string $pdiFracturesWindowTabs;
    global string $pdiFragmentsList;
    global string $pdiClustersList;
    global string $selectedPdiFbody;

    int $bListFragmentsExist  = `textScrollList -ex $pdiFragmentsList`;//the window ex flag seem doesnt work

    if( $bListFragmentsExist == false)
    {
//		print("pdiAdvancedFracturesWindow iconified, abort\n");			
        return;
    }

	string $pdiCurrentSelectedFragments[] = `textScrollList -query -allItems $pdiFragmentsList`;
    textScrollList -edit -removeAll $pdiFragmentsList;

    //remove select color for last selected
    for ( $obj in $pdiCurrentSelectedFragments )
    {
	    setAttr ($obj + ".selected" ) 0;
        //force update 
        getAttr ($obj + ".ca_selected" );            
    }
    
    //remove last selected
    clear( $pdiCurrentSelectedFragments);

	$selectedTab = `tabLayout -q -st $pdiFracturesWindowTabs`;
	if( $selectedTab == "pdiAdvFracturesTab")
	{
	if( !`objExists $selectedPdiFbody`)
	{	 
		error -noContext "advanced fractures cannot select fragments,  select a fracture body first";		  
		return;
	}
	}

	string  $PDISelected[];
    $PDISelected = `ls -selection -dag -leaf -type pdiRigidBody`;

    if( size($PDISelected) > 0)
    {
        for ( $obj in $PDISelected )
        {
    		string  $connections[]=`listConnections -type pdiFbodyNode $obj`;

            if( size($connections) > 0 )
            {
				if( $connections[0]== $selectedPdiFbody)
				{
					textScrollList -edit -append $obj $pdiFragmentsList;

					setAttr ($obj + ".selected" ) 1;
					//force update 
					getAttr ($obj + ".ca_selected" );            
				}
            }
//    		print("pdiFragmentsList updated\n");			
        }

        
        $pdiCurrentSelectedFragments = `textScrollList -query -allItems $pdiFragmentsList`;
		int $nClusterSelect=0;
        for ( $obj in $pdiCurrentSelectedFragments )
        {
			$connections = `listConnections -type ClusterPdiNode $obj`;
			if( size($connections) > 0 )
			{
				$nClusterSelect++;
			}
		}
		if( $nClusterSelect > 0)
		{
		    warning -noContext "PDI Info: some of the fragments selected belong to a cluster";			
		}

		//deselect all clusters
		string $clusters[] = `listConnections -d true -type "ClusterPdiNode" $selectedPdiFbody`;
		if( size( $clusters) > 0)
		{
//			string  $connections[] = `listConnections -type pdiRigidBody $selectedPdiCluster`;
//			for ( $obj in $connections )
//			{
//				setAttr ($obj + ".selected" ) 0;
				//force update 
//				getAttr ($obj + ".ca_selected" );            
//			}

			for ( $obj in  $clusters )
			{
				setAttr(  $obj + ".selected" ) false;
				//force update
				getAttr ( $obj + ".ca_selected" );
			}
			textScrollList -edit -deselectAll $pdiClustersList;		
		}
    }

	setFocus MayaWindow;    
}
global proc updatePidSecCracks()
{
    global string $selectedPdiFbody;
    global string $framePdiSecCracks;
    global string $chkPdiEnableSecCracks;
    global string $fieldPdiPercentSecCracks;

	if($selectedPdiFbody=="")
	{
		error -noContext "no fracture body selected ";

		return;
	}

	int $bSecCracks = `checkBox -q -value $chkPdiEnableSecCracks`;	
    if( $bSecCracks > 0)
    {
	    setAttr ($selectedPdiFbody + ".secCracks" ) true;
    }
    else
    {
	    setAttr ($selectedPdiFbody + ".secCracks" ) false;
    }
	int $percentSecCracks = `intField -q -value $fieldPdiPercentSecCracks`;	

	setAttr ($selectedPdiFbody + ".percentSecCracks" ) $percentSecCracks;
    
    //force update
    getAttr ($selectedPdiFbody + ".ca_secCracks" );
    
}
global proc selectSimilarPdiFragments()
{
    global string $pdiFragmentsList;

    string $selection[];
    $selection = `textScrollList -query -selectItem $pdiFragmentsList`;
	if( size($selection) == 0)
	{
	    $selection = `textScrollList -query -allItems $pdiFragmentsList`;	
	}

	if( size($selection) > 0)
	{
	    string $transformnodes[];

		int $numSelected = size($selection);

		$result = `pdiCluster -ss $selection`;

		//print $result;

		for ( $obj in $result )
		{
			string $parent[]=`listRelatives -p $obj`;
			$transformnodes[size( $transformnodes)] = $parent[0];
		}
		if( size($transformnodes) > 0)
		{
			select $transformnodes;

			$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;

//			print (  "new selection " + size($PDIObjects) + " last selection " + $numSelected +"\n");
			if( size($PDIObjects) <= $numSelected)
			{
				warning -noContext "no more similar neighborgs found\n";
			}

		}
		else
		{
			error -noContext "wrong selection of fragments\n";
		}
	}
	else
	{
		error -noContext "no neighborgs found";
	}			
}

global proc setStaticPdiFragments()
{
    global string $pdiFragmentsList;

    string $selection[];
    $selection = `textScrollList -query -selectItem $pdiFragmentsList`;
	if( size($selection) == 0)
	{
	    $selection = `textScrollList -query -allItems $pdiFragmentsList`;	
	}
	
	if( size($selection) > 0)
	{
	    update_Fbody -staticFrags true $selection;
			
		//remove select color for last selected
		for ( $obj in $selection )
		{
			setAttr ($obj + ".selected" ) 0;
			//force update 
			getAttr ($obj + ".ca_selected" );            
		}
	}
	else
	{
		error -noContext "selected fragments doesnt belong to a cluster or diferent fracture body";
	}			
}
global proc setDynamicPdiFragments()
{
    global string $pdiFragmentsList;

    string $selection[];
    $selection = `textScrollList -query -selectItem $pdiFragmentsList`;
	if( size($selection) == 0)
	{
	    $selection = `textScrollList -query -allItems $pdiFragmentsList`;	
	}
    
	if( size($selection) > 0)
	{
	    update_Fbody -staticFrags false $selection;		

		//remove select color for last selected
		for ( $obj in $selection )
		{
			setAttr ($obj + ".selected" ) 0;
			//force update 
			getAttr ($obj + ".ca_selected" );            
		}

	}
	else
	{
		error -noContext "selected fragments doesnt belong to  a cluster or diferent fracture body";
	}			

}

global proc createPdiCluster()
{
    global string $pdiFragmentsList;
    global string $pdiClustersList;

	string $pdiCurrentSelectedFragments[] = `textScrollList -query -allItems $pdiFragmentsList`;	
	if( size($pdiCurrentSelectedFragments) > 0)
	{
	    waitCursor -state on;

		string $clusterNode=`pdiCluster -assign $pdiCurrentSelectedFragments`;

		if( `objExists $clusterNode`)
		{
			for ( $obj in $pdiCurrentSelectedFragments )
			{
				setAttr ($obj + ".selected" ) 0;
				//force update 
				getAttr ($obj + ".ca_selected" );            
			}

		    clear($pdiCurrentSelectedFragments);
			select -clear;

//			updatePdiAdvancedFracturesPanel();

			textScrollList -edit -deselectAll $pdiClustersList;		
			textScrollList -edit -append $clusterNode $pdiClustersList;
			textScrollList -edit -selectItem $clusterNode $pdiClustersList;				     

			updatePdiClusters();
		}
		waitCursor -state off;

	}
	else
	{
		error -noContext "selected fragments doesnt belong to a cluster or diferent fracture body";
	}
}

global proc deletePdiCluster()
{
    global string $pdiClustersList;
    string $selection[] = `textScrollList -query -selectItem $pdiClustersList`;
	if( size($selection) > 0)
	{
		pdiCluster -remove $selection;

		updatePdiAdvancedFracturesPanel();
	}
	else
	{
		error -noContext "no cluster selected in list";
	}
}
global proc deleteAllPdiCluster()
{
    global string $selectedPdiFbody;
    global string $pdiClustersList;

    string $result = `confirmDialog -title "Confirm" -message " this action will reset all stresses to default, are you sure?"
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`;

    if( $result == "Yes")
    {
		string $selection[];
		$selection = `textScrollList -query -allItems $pdiClustersList`;
		if( size($selection) > 0)
		{
			pdiCluster -remove $selection;
		}

		clear($selection);
        $selection[0]=$selectedPdiFbody;

        string $result[];
        $result = `fBody_selStresses -resetAll $selection`;

		updatePdiAdvancedFracturesPanel();
    }
}

global proc OnChangeNameFbody()
{
    global string $pdiFBodiesList;
    global string $selectedPdiFbody;
	global string $namePdiFbody;

	$selectedPdiFbody = `nameField -query -object $namePdiFbody`;

	updatePdiFracturesPanel();	
}
global proc updatePdiAdvancedFracturesPanel()
{
    global string $pdiFracturesWindow;
	global string $pdiFracturesWindowTabs;
    global string $selectedPdiFbody;
    global string $chkPdiEnabledFbody;
    global string $chkPdiEnableSecCracks;    
    global string $fieldPdiPercentSecCracks;    
    global string $namePdiFbody;
    global string $pdiFragmentsList;
    global string $pdiClustersList;
    global string $fieldPdiBreakForce;
    global string $fieldPdiBreakFrame;

	$winExist=`window -ex winPdiBasicFractures`;
	if( $winExist==false)
    {
		return;
    }

	if( $selectedPdiFbody == "")
	{
		updateSelectedPdiFractureBody();
	}
   
    if( `objExists $selectedPdiFbody` )
    {
//		print $selectedPdiFbody;
		nameField -edit -object $selectedPdiFbody $namePdiFbody;

		int $bSecCracks = getAttr ($selectedPdiFbody + ".secCracks" );

		checkBox -edit -value $bSecCracks $chkPdiEnableSecCracks;
		
		int $percentSecCracks = getAttr ($selectedPdiFbody + ".percentSecCracks" );
		
	    intField -edit -value $percentSecCracks $fieldPdiPercentSecCracks;			
    }
			
	    updatePdiFragments();
    
    textScrollList -edit -removeAll $pdiClustersList;
	string  $PDIClusters[];
	$PDIClusters = `ls -exactType ClusterPdiNode`;
	if(size($PDIClusters) != 0)
	{
    	for ( $obj in $PDIClusters )
	    {
    		string  $connections[];
			$connections = `listConnections -type pdiFbodyNode $obj`;

			if( size($connections) > 0 && $connections[0]== $selectedPdiFbody)
			{
				textScrollList -edit -append $obj $pdiClustersList;
			}
        }
		textScrollList -edit -deselectAll $pdiClustersList;		
        
	updatePdiClusters();
	}
       
}

//////////////////////////////////////////////////
global proc undoLastShatter()
{
    global string $chkShItCreatePdiBodies;
    global string $shiRefObject;
    global string $chkShItUseVolumeShape;

	deletePdiLocators();

	undoInfo -swf off;
	
	global string $shatterGroupsToUndo[];//need to be global bacouse of eval defered bellow
	clear($shatterGroupsToUndo);
	string $selection[] = `ls -selection -dag -type "mesh"`;
	if( size($selection) == 0)
	{
		//maybe selection is a voronoi node
		$selection = `ls -selection -dag -type "pdiVoronoiNode"`;
		if( size($selection) > 0)
		{
			string $transformNode[]=`listRelatives -p $selection[0]`;
			$ShatterGroup=`listRelatives -p $transformNode[0]`;
			$selection=`listRelatives -path -ni -ad -typ "mesh" $ShatterGroup[0]`;
		}
	}

//	print( size($selection));
	while( size( $selection) > 0)
    {	
		$transformNode=`listRelatives -p $selection[0]`;
		$parent=`listRelatives -p $transformNode`;
		if( size($parent) > 0)
		{
			$voronoiNodes=`listRelatives -ad -typ "pdiVoronoiNode" $parent[0]`;
			if(size($voronoiNodes)>0)
			{	
				$voronoiTransform=`listRelatives -p $voronoiNodes[0]`;
				$ShatterGroup=`listRelatives -p $voronoiTransform`;
				if( $parent[0]==$ShatterGroup[0])
				{
					$shatterGroupsToUndo[size($shatterGroupsToUndo)]=$ShatterGroup[0];
					$fragments=`listRelatives -c $ShatterGroup[0]`;				
					select -d  $ShatterGroup[0];	
					select -d  $fragments;		
				}
				else
				{
					//a group contains both solid and shatter objects
					select -d  $transformNode[0];	
		//			print( "solid object ignored\n");						             
				}							 
			}	
			else
			{
				$childs=`listRelatives -c $parent[0]`;				
				select -d  $parent[0];	
				select -d  $childs;		
//				print( "non-shatter group ignored\n");						             
			}
		}
		else
		{
			select -d  $transformNode[0];	
//			print( "solid object ignored\n");						             
		}							 
		$selection = `ls -selection -dag -type "mesh"`;				
//        print (size($selection) +"\n");
        
     }				
//     print 	$shatterGroupsToUndo;

	int $result=0;
	int $nothingToUndo=1;
	int $bHasTransferkeys=0;
	string $shatterGroupIssue;

	//abort if fragments has animation keys
	for ( $obj in $shatterGroupsToUndo )
	{
		string $sourceMeshes[] = `listRelatives -path -ni -ad  -typ "mesh" $obj`;
		if( size( $sourceMeshes) > 0)
		{
			string $sourceTRS[]=`listRelatives -p $sourceMeshes[0]`;        
			clear($sourceMeshes);

			if(`keyframe -query -keyframeCount $sourceTRS[0]` != 0)
			{
				$shatterGroupIssue = $obj;
				$bHasTransferkeys = 1;
				break;
			}
		}
	}

	if($bHasTransferkeys)
	{
		//shatter group has keys
		string $msg = ($shatterGroupIssue + " has animation keys," + " remove all animation keys before reshatering the model");
		confirmDialog
		-title "Pdi Info"
		-message $msg
		-button "OK" 
		-defaultButton "OK" ;
			
		return;			 	

	}

	//delete pdi bodies if any
	for ( $obj in $shatterGroupsToUndo )
	{
		$PDIObjects =`listRelatives -ad -type pdiRigidBody $obj`;
		if( size($PDIObjects) > 0)
		{
	        $fracturebody = `listConnections -type pdiFbodyNode  $PDIObjects[0]`;
            if( size($fracturebody) > 0 )
            {
                deletePdiFBody -deleteBodies $fracturebody[0];
            }	
            else
            {			
	    	for ( $pdiBody in $PDIObjects )
		    {
					deleteUserNode $pdiBody;
				}
	        }
		}

		$fragments=`listRelatives -c $obj`;

		$result = `pdiShatter -udl $fragments[0]`;	
		if( $result > 0) $nothingToUndo=0;			    				
//		print ("\n" + $obj + " " + $result);

		if ( `window -ex winPdiBasicFractures` )
		{                
			updatePdiFracturesPanel();
		}
		if ( `window -ex winCreatePdiBodies` )
		{                
			updatePdiManagePanel();
		}
    }		    

	if( $shiRefObject!="")
	{
		//show volume shape in case it is hidden
		$bUseVolumeShape = `checkBox -query -value $chkShItUseVolumeShape`;
		if( $bUseVolumeShape > 0)
		{
            string $shiRefNode[]=`listRelatives -p $shiRefObject`;			    
			showHidden  $shiRefNode[0];
		}
	}

	//seems doesnt make sense when undoing last shatter
    //$bcreaterigidbodies = `checkBox -query -value $chkShItCreatePdiBodies`;
	//if( $bcreaterigidbodies==true)
    //{
		//	deferred creation because groups are built on idle time
		//evalDeferred -lp "createRigidbodiesAfterShatter($shatterGroupsToUndo)";
    //}

	undoInfo -swf on;

	if( $nothingToUndo )		
	{
		print( "nothing to undo");	
		//recover original selection by user
		string $selectedVoronodes[];
		for ( $obj in $shatterGroupsToUndo )
		{
			string $voronode[] =`listRelatives -ad -type "pdiVoronoiNode" $obj`;
			if(size($voronode)>0)
			{
				$selectedVoronodes[size( $selectedVoronodes)]= $voronode[0];   
			}      		
		}
		select $selectedVoronodes;						
	//    evalDeferred -lp ("select $selectedVoronodes");
	}
	else
	{
		print ( "undo last shatter done\n");
	}


//optional: recovering locator
//	string $shatterLocator[] = `ls -dag -type "ShatterLocator"`;
//	if( size($shatterLocator) > 0)
//	{
//		hide $shatterLocator[0];
		//locators selected, show it 
//		print("recovering locator\n");
//		$transform = `listRelatives -parent $shatterLocator[0]`;
//		string $selection[] = `listRelatives -s $transform[0]`;					
//		$shiPreviewObject = $selection[0];
//		select $selection[0];
//		setShatteritPreviewMode();
//	}
}

global proc pdiPrepareUndoAllShatter()
{
	global string $pdiSelectionForUndoShatter[];
	string $ShatterGroup[];

	$pdiSelectionForUndoShatter = `ls -selection -dag -type "mesh"`;
	if( size($pdiSelectionForUndoShatter) == 0)
	{
		//maybe selection is a voronoi node
		$pdiSelectionForUndoShatter = `ls -selection -dag -type "pdiVoronoiNode"`;
		if( size($pdiSelectionForUndoShatter) > 0)
		{
			string $transformNode[]=`listRelatives -p $pdiSelectionForUndoShatter[0]`;
			$ShatterGroup=`listRelatives -p $transformNode[0]`;
			$pdiSelectionForUndoShatter=`listRelatives -path -ni -ad -typ "mesh" $ShatterGroup[0]`;
		}
	}

	if( size($pdiSelectionForUndoShatter) == 0)
	{
		print("PDI Info: select a shard to undo its shatter group\n");		
		return;
	}

	string $transformNode[];
	string $voronoiNodes[];
	$transformNode=`listRelatives -p $pdiSelectionForUndoShatter[0]`;
	$ShatterGroup=`listRelatives -p $transformNode[0]`;
	if( size($ShatterGroup) > 0)	
		$voronoiNodes=`listRelatives -ad -typ "pdiVoronoiNode" $ShatterGroup[0]`;

	if( size($ShatterGroup)==0 || size($voronoiNodes) == 0)
		{		    
		clear( $pdiSelectionForUndoShatter);
			
		error -noContext ("no PDI shatter data found on selection\n");		
			return;			 	
		}

	select $ShatterGroup;//hilight shatter group to be removed

	evalDeferred -lp "pdiUndoAllShatter";
	}

global proc pdiUndoAllShatter()
{
	global string $pdiSelectionForUndoShatter[];
	global string $shiPreviewObject;
	global int $shiPreviewModeOn;	
    global string $shiRefObject;
    global string $chkShItUseVolumeShape;
	string $selection[]	;

	int $nothingToUndo=1;
	global string $transformNodesToUndo[];
	clear($transformNodesToUndo);
	string $voronoiNodes[];
	 
    string $result = `confirmDialog -title "Confirm" -message "This action will remove all shards in selected groups, are you sure?"
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`;

    if( $result == "Yes")
    {
	    undoInfo -swf off;

		$selection = $pdiSelectionForUndoShatter;
		select $selection;

		deletePdiLocators();
		//assumes selection is made of shapes only
		while( size( $selection) > 0)
		{
			print( "undoing: " + $selection[0] + "\n");

			$transformNode=`listRelatives -p $selection[0]`;
			$groupNode=`listRelatives -p $transformNode[0]`;

			print( "selected: " +  $transformNode[0] + " " +$groupNode[0]+ "\n");
			if( size($groupNode) > 0)
			{
				$voronoiNodes=`listRelatives -ad -typ "pdiVoronoiNode" $groupNode[0]`;
				if( size($voronoiNodes) == 1)
				{
					//find the correct shatter group
					string $transformVoro[]=`listRelatives -p $voronoiNodes[0]`;
					string $ShatterGroup[]=`listRelatives -p $transformVoro[0]`;
					if( $ShatterGroup[0] == $groupNode[0])//selection is a shard
					{
					//select the original node
					string $connect[]=`listConnections -type "mesh" -sh true ($voronoiNodes[0]+ ".inShape")`;
					if( size($connect)>0)
					{
							string $originalNode[]=`listRelatives -p $connect[0]`;
							$transformNodesToUndo[size($transformNodesToUndo)]=$originalNode[0];

							showHidden $originalNode[0];
					}

						//delete pdi bodies if any
						$PDIObjects =`listRelatives -ad -type pdiRigidBody $ShatterGroup[0]`;
						if( size($PDIObjects) > 0)
						{
							$fracturebody = `listConnections -type pdiFbodyNode  $PDIObjects[0]`;
							if( size($fracturebody) > 0 )
							{
								deletePdiFBody -deleteBodies $fracturebody[0];
							}	
							else
							{			
	    						for ( $pdiBody in $PDIObjects )
								{
									deleteUserNode $pdiBody;
								}
							}												
						}

					delete $ShatterGroup;
					$nothingToUndo=0;
				}
				else
					{
						//selection isnt a shard
						select -d  $selection[0];
						print( "deselect: " +  $selection[0]+ "\n");
					}
				}
				else
				if( size($voronoiNodes) > 1)
				{
					//user must has selected a group of nodes
					for($obj in $voronoiNodes)
					{
						//find the correct shatter group
						$transformNode=`listRelatives -p $obj`;
						string $ShatterGroup[]=`listRelatives -p $transformNode`;

						//select the original node
						string $connect[]=`listConnections -type "mesh" -sh true ($obj+ ".inShape")`;
						if( size($connect)>0)
						{
							$transformNode=`listRelatives -p $connect[0]`;
							$transformNodesToUndo[size($transformNodesToUndo)]=$transformNode[0];
							showHidden $transformNode[0];
						}

						//delete pdi bodies if any
						$PDIObjects =`listRelatives -ad -type pdiRigidBody $ShatterGroup[0]`;
						if( size($PDIObjects) > 0)
						{
							$fracturebody = `listConnections -type pdiFbodyNode  $PDIObjects[0]`;
							if( size($fracturebody) > 0 )
							{
								deletePdiFBody -deleteBodies $fracturebody[0];
							}	
							else
							{			
	    						for ( $pdiBody in $PDIObjects )
								{
									deleteUserNode $pdiBody;
								}
							}												
						}

						delete $ShatterGroup;
						$nothingToUndo=0;
					}
				}
				else
				{
					//no voronoi nodes found, wrong selection
					select -d  $selection[0];
					print( "deselect: " +  $selection[0]+ "\n");
				}
			}
			else
			{
				//no shatter group found, wrong selection
				select -d  $selection[0];
				print( "deselect: " +  $selection[0]+ "\n");
			}
			$selection = `ls -selection -dag -type "mesh"`;
		}

		if( $nothingToUndo )		
		{
			print( "nothing to undo");	    					
		}
		else
		{

			if ( `window -ex winPdiBasicFractures` )
			{                
				updatePdiFracturesPanel();
			}

			if( $shiRefObject!="")
			{
				//show volume shape in case it is hidden
				$bUseVolumeShape = `checkBox -query -value $chkShItUseVolumeShape`;
				if( $bUseVolumeShape > 0)
				{
					string $shiRefNode[]=`listRelatives -p $shiRefObject`;			    
					showHidden  $shiRefNode[0];
				}
			}

			//delete also ground grid if no pdi objects in scene
			string $pdiSolver[]=`ls -type pdiSolverNode`;
			if( size($pdiSolver) >0)
			{
				int $gridAsGround = getAttr ($pdiSolver[0] + ".useGroundGrid" );

				if( $gridAsGround==0)
				{
    				string  $connections[] = `listConnections -d true -s false $pdiSolver[0]`;
    				if( size( $connections) == 0)
					{
						//there arent any pdi object in scene
						deleteUserNode $pdiSolver[0];
					}
				}
			}
		}

		//select original nodes
		if( size($transformNodesToUndo) >0) 
		{
		    select -cl;
			//otherwise cmd fails
			evalDeferred -lp ("select $transformNodesToUndo");
		}


//		$shiPreviewObject="";
//		$shiPreviewModeOn=0;
	    undoInfo -swf on;
	}

	clear($pdiSelectionForUndoShatter);
}


global proc int nodeIsVisible( string $node )
{
  // If user is asking about a bogus node, return FALSE.
  if ( !`objExists $node` ) return false;

  // Object must be a DAG node, or it's not visible.
  if ( !`attributeQuery -node $node -exists "visibility"` ) return false;

  int $visible = `getAttr ( $node + ".visibility" )`;

  // If this is an intermediate mesh, it's not visible.
  if ( `attributeQuery -node $node -exists "intermediateObject"` )
  {
    $visible = $visible && !`getAttr ( $node + ".intermediateObject" )`;
  }

  // If the object is in a displayLayer, and the displayLayer is hidden,
  // then the object is hidden.
  if ( `attributeQuery -node $node -exists "overrideEnabled"` &&
       `getAttr ( $node + ".overrideEnabled" )` )
  {
    $visible = $visible && `getAttr ( $node + ".overrideVisibility" )`;
  }

  // Ascend the hierarchy and check all of the parent nodes.
  if ( $visible )
  {
    string $parents[] = `listRelatives -parent $node`;
    if ( `size $parents` > 0 )
    {
      $visible = $visible && nodeIsVisible( $parents[0] );
    }
  }

  return $visible;
}

global proc int hasVoroNode(string $shapeObj)
{
	$transformNode=`listRelatives -p $shapeObj`;
	$ShatterGroup=`listRelatives -p $transformNode[0]`;
	if( size($ShatterGroup) > 0)
	{
		$voronoiNode=`listRelatives -ad -typ "pdiVoronoiNode" $ShatterGroup[0]`;
		if( size($voronoiNode) > 0)
		{
			//check if voronoi group is the same than PreviewObject group
    		$transformVoroNode=`listRelatives -p $voronoiNode[0]`;
	    	$ShatterVoroGroup=`listRelatives -p $transformVoroNode`;
	    			
			if($ShatterVoroGroup[0]==$ShatterGroup[0])
			{ 				       
				return 1;
			}
		}							    
	}							    
	return 0;
}

global proc createRigidbodiesAfterShatter(string $listOfFragments[])
{
    //create pdiSolver node if necessary
    pdiSolver;
	string $affectedNodes[];
	string $result[];

	for($obj in $listOfFragments)
	{
		string $childobjects[] =`listRelatives -c  $obj`;
//		print $childobjects;

	   $result = `new_PDIBody -a 0 -st 4 $childobjects`;
//        appendStringArray($affectedNodes, $result, size($result));//causes maya crash, why?
	}

	$affectedNodes = `listRelatives -parent $result`;
	select $affectedNodes;
}

global proc pdiShatterIt()
{
//    global string $gMainProgressBar;  // This is defined on maya startup
    global string $fieldPdiShatterItNumShards;
    global string $fieldPdiShardsSeed;
   	global string $pdiRAXIS[3];
    global string $chkShItCreatePdiBodies;
	global string $chkShItDetectMeshGroups;
    global string $shiRefObject;
    global string $chkShItAssignNewMat;
    global string $fieldPdiNumberOfRings;
    global string $fieldPdiNumberOfCenters;    
    global string $fieldPdiRingsNoise;
    global string $pdiExclusionObject;
    global string $pdiBodiesList;
    global string $fieldPdiShatterWidth;
    global string $comboShatterStyle;
    global string $ShItCutMatName;    
	global string $shiPreviewObject;
	global int $shiPreviewModeOn;	  	 
    global string $butPdiCustomMapping;
	global string $butPdiUndoShatter;
    global string $chkShItUseVolumeShape;
    global int $pdiUpdate;
        
	$pdiUpdate = 0;//disable update					

    //make sure a transform node is selected( to can remove pdi bodies)
	string $selection[] = `ls -selection`;
	
	if( size($selection) > 1)
	{	    
		//select all shapes down the cherarchy
		$selection = `ls -selection -dag -type "mesh"`;
	}
	else
	if( size($selection) == 1)
	{
		string $PDICrackers[] = `ls -selection -dag -leaf -type pdiCracker`;

		if( size($PDICrackers) > 0)
		{
			warning -noContext "PDI Info: crackers objects cannot be shattered\n";
			return;
		}
		else
		if( `nodeType $selection[0]`!="transform")
		{
			$transform = `listRelatives -parent $selection[0]`;
			// select the shapes just bellow
			$selection = `listRelatives -path -ni -type "mesh" $transform`;		
		}
		else
		{	    
			//select all shapes down the cherarchy
			$selection = `ls -selection -dag -type "mesh"`;
		}
	}

	if( size($selection) == 0)
	{
		//look for a shatter locator
		string $shatterLocator[] = `ls  -dag -type "ShatterLocator"`;
		if( size($shatterLocator) > 0)
		{
			$transform = `listRelatives -parent $shatterLocator[0]`;
			$selection = `listRelatives -path -ni -type "mesh" $transform`;
		}
		else
		{
			warning -noContext "PDI Info: no poly object selected\n";
			return;
		}
	}		

	int $shatterStyle = `optionMenu -query -select $comboShatterStyle`;

	for ( $obj in $selection )
	{
		if( hasVoroNode( $obj))
		{
			// abort if selected node is already shattered
			string $msg;
			if( $shatterStyle==7)
			{
				$msg = ("Adquire shatter doesnt work on objects already shattered");
				confirmDialog
				-title "Pdi Info"
				-message $msg
				-button "OK" 
				-defaultButton "OK" ;				    

				$pdiUpdate = 1;//enable update					

				return;			 	
			}					
			else
			if( !$shiPreviewModeOn)
			{
				$msg = ("Set Preview Mode for reshattering an object");
			confirmDialog
			-title "Pdi Info"
			-message $msg
			-button "OK" 
			-defaultButton "OK" ;				    

			$pdiUpdate = 1;//enable update					

			return;			 	
		}	    
		}	    
		if( $shatterStyle==6)
		{
			//vertex color shatter
			if( $shiRefObject!="" && !$shiPreviewModeOn)
			{
				// abort if source node selected and  no preview mode on
				string $msg = ("Set Preview Mode for shattering with these settings");
				confirmDialog
				-title "Pdi Info"
				-message $msg
				-button "OK" 
				-defaultButton "OK" ;				    

				$pdiUpdate = 1;//enable update					

				return;			 	
			}
		}
     }

	//abort if fragments belong to a fracture body
    string  $PDIObjects[];
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;

	for ( $obj in $PDIObjects )
	{
    	string  $connections[];
		$connections = `listConnections -type pdiFbodyNode $obj`;
		if( size($connections) > 0)
		{		    
			$transform = `listRelatives -p $obj`;  
			string $msg = ($transform[0] + " belong to a fracture body." + " Delete fracture body " + $connections[0] + " for reshattering");
			confirmDialog
			-title "Pdi Info"
			-message $msg
			-button "OK" 
			-defaultButton "OK" ;
			
			$pdiUpdate = 1;//enable update					

			return;			 	
		}
	}

    //delete all existing pdi objects
    if ( `textScrollList -ex $pdiBodiesList` )
    {
	    for ( $obj in $PDIObjects )
        {
            textScrollList -edit -removeItem $obj $pdiBodiesList;
        }
    }
	for ( $obj in $PDIObjects )
    {
//            deleteUserNode $obj;
        delete $obj;
    }

    string $result[];
    int $radialAxis;
    int $numShards = `intSliderGrp -query -value $fieldPdiShatterItNumShards`;
    int $shardsSeed = `intSliderGrp -query -value $fieldPdiShardsSeed`;
    int $minShards = $numShards;
    int $maxShards = $numShards;
    $bUseVol = false;
           
    int $dtm =`checkBox -query -value $chkShItDetectMeshGroups`;
//	if( $dtm==0)
//	{
		//enable detect mesh groups if model is combined
//		string $connection[] = `listConnections -type groupParts $selection[0]`;
//		if( size($connection)>0)
//		{
//			string $connection2[] = `listConnections -type polyUnite $connection[0]`;
//			if( size($connection2)>0)
//			{
//			   $dtm=1;
//			}
//		}
//	}							
   
    $newmat = `checkBox -query -value $chkShItAssignNewMat`;
    string $cutmatname =`textField -query -tx $ShItCutMatName`;
    float $shatterWidth = `floatSliderGrp -query -value $fieldPdiShatterWidth`;

	undoInfo -swf off;
    waitCursor -state on;

	if( $shiPreviewModeOn == 1)
	{
		//disable preview mode
		string $shatterLocator[] = `ls  -dag -type "ShatterLocator"`;
		if( size($shatterLocator) > 0)
		{
			hide $shatterLocator[0];
		}	
		disableShatteritPreviewMode();
	}

    if( `radioButton -query -select $pdiRAXIS[0]`)
    {
        $radialAxis=0;
    }
    else
    if( `radioButton -query -select $pdiRAXIS[1]`)
    {
        $radialAxis=1;
    }
    else
    {
        $radialAxis=2;
    }

	$bUseVolumeShape = `checkBox -query -value $chkShItUseVolumeShape`;
	if( $shatterStyle==5)
	{
		//path-based needs always a reference curve for shattering
		$bUseVolumeShape = 1;
	}

	int $isRefObject=`objExists $shiRefObject`;

	if( $shatterStyle==7)
	{
	    waitCursor -state off;

		//adquire shatter
		if( $isRefObject)
		{
			global string $PdiSourceShatterGroup;
			global string $PdiTargetShatterGroup;

			int $bTransferkeys=0;

			string $vorotransformNode[]=`listRelatives -p $shiRefObject`;
			if( size($vorotransformNode) >0)
			{
				//select the original node
				string $sourceNode[];
				string $targetNode[];
				string $connect[]=`listConnections -type "mesh" -sh true ($shiRefObject+ ".inShape")`;
				if( size($connect)>0)
				{
					$sourceNode=`listRelatives -p $connect[0]`;
					$targetNode=`listRelatives -p $selection[0]`;
				}

				if( size($sourceNode) > 0 && size($targetNode) > 0)
				{
					//check pivots match
					
					float $pivotHi[3] = `xform -q -rotatePivot -os $targetNode`;
					float $pivotLow[3] = `xform -q -rotatePivot -os $sourceNode`;

					float $dif[3];
					$dif[0] = $pivotHi[0] - $pivotLow[0];
					$dif[1] = $pivotHi[1] - $pivotLow[1];
					$dif[2] = $pivotHi[2] - $pivotLow[2];

					if( $dif[0] > 1e-2 || $dif[1] > 1e-2 || $dif[2] > 1e-2)
					{
						error -noContext ("original objects local pivots doesnt match!\n");

						return;
					}

					// check scale transform match

					float $scaleTHi[3] = `xform -q -scale -os $targetNode`;
					float $scaleTLow[3] = `xform -q -scale -os $sourceNode`;

					$dif[0] = $scaleTHi[0] - $scaleTLow[0];
					$dif[1] = $scaleTHi[1] - $scaleTLow[1];
					$dif[2] = $scaleTHi[2] - $scaleTLow[2];

					if( $dif[0] > 1e-2 || $dif[1] > 1e-2 || $dif[2] > 1e-2)
					{
						error -noContext ("original objects scale transform doesnt match!\n");

						return;
					}
				}

				string $voroTRS[]=`listRelatives -p $vorotransformNode[0]`;
				$PdiSourceShatterGroup=$voroTRS[0];

				string $sourceMeshes[] = `listRelatives  -path -ni -ad  -typ "mesh" $PdiSourceShatterGroup`;
				if( size( $sourceMeshes) >0)
				{
					string $sourceTRS[]=`listRelatives -p $sourceMeshes[0]`;        

					if(`keyframe -query -keyframeCount $sourceTRS[0]` != 0)
					{
						//shatter group has keys
						string $result = `confirmDialog -title "Confirm" -message "Source fragments have animation keys, do you want to transfer them to new group?"
						-button "Yes" -button "No" -defaultButton "Yes"
						-cancelButton "No" -dismissString "No"`;
						if( $result == "Yes")
						{
							$bTransferkeys = 1;
						}
					}
					clear($sourceMeshes);
				}
			}

		    waitCursor -state on;

			$result = `pdiAdqShatter -dmg $dtm -refObject $shiRefObject  $selection[0]`;

			if( $bTransferkeys)
			{
				$PdiTargetShatterGroup = $result[0];

				//	deferred execution because shatter group is built on idle time
				evalDeferred -lp "pdiTransferKeysGroups($PdiSourceShatterGroup, $PdiTargetShatterGroup)";
			}
		}
		else
		{
			error -noContext "no shatter group selected for this operation";        

			return;
		}
	}
	else
	if( $bUseVolumeShape && $isRefObject)
    {
        if( $shatterStyle==3)//radial
        {
            int $numRings = `intSliderGrp -query -value $fieldPdiNumberOfRings`;
            float $noiseRings = `floatSliderGrp -query -value $fieldPdiRingsNoise`;

            $result = `pdiShatter -ns $numShards -seed $shardsSeed -st $shatterStyle
                -nr $numRings  -no $noiseRings -wid $shatterWidth
                -ra $radialAxis -nm $newmat -cmn $cutmatname -dmg $dtm -reo $shiRefObject $selection`;
        }
        else
        if( $shatterStyle==4)//wood splinters
        {
            $result = `pdiShatter -ns $numShards -seed $shardsSeed -st $shatterStyle
                    -nm $newmat -cmn $cutmatname -dmg $dtm -ra $radialAxis
					 -wid $shatterWidth -reo $shiRefObject $selection`;
		}        
        else
        {
		    int $numCenters = `intSliderGrp -query -value $fieldPdiNumberOfCenters`;
			
	        $result = `pdiShatter -ns $numShards -seed $shardsSeed -st $shatterStyle
		        -nm $newmat -cmn $cutmatname -dmg $dtm
		        -wid $shatterWidth -reo $shiRefObject $selection`;            
        }

		//hide volume shape after shattering
//		hide $shiRefObject;
    }
	else
    {
		//shatter with no ref object

        if( $shatterStyle==3)//radial
        {
            int $numRings = `intSliderGrp -query -value $fieldPdiNumberOfRings`;
            float $noiseRings = `floatSliderGrp -query -value $fieldPdiRingsNoise`;

            $result = `pdiShatter -ns $numShards -seed $shardsSeed -st $shatterStyle
                -nr $numRings  -no $noiseRings -wid $shatterWidth
                -ra $radialAxis -nm $newmat -cmn $cutmatname -dmg $dtm $selection`;
        }
        else
        if( $shatterStyle==4)//wood splinters
        {
            $result = `pdiShatter -ns $numShards -seed $shardsSeed -st $shatterStyle
                    -nm $newmat -cmn $cutmatname -dmg $dtm -ra $radialAxis -wid $shatterWidth $selection`;
		}        
        else
        {
		    int $numCenters = `intSliderGrp -query -value $fieldPdiNumberOfCenters`;
			
			$result = `pdiShatter -ns $numShards -seed $shardsSeed -st $shatterStyle
                    -nm $newmat -cmn $cutmatname -dmg $dtm -wid $shatterWidth
                     -noc $numCenters  $selection`;
        }
    }

//	print  $result;	
//		xform -cp $result;//center pivots not needed
	 
    if( size($result) > 0)
	{
		int $nExcluded = size($selection) - size($result);
		if( $nExcluded > 0)
			print ( "shatter done, warning " + $nExcluded + " objects excluded\n");
		else
		print ( "shatter done\n");
	}
	else
	{
		print ( "shatter cancelled, see errors in script editor output\n");	
	}
    
    $bcreaterigidbodies = `checkBox -query -value $chkShItCreatePdiBodies`;

	if( $bcreaterigidbodies==true)
    {
		//	deferred creation because groups are built on idle time
	    global string $PdiShatterResult[];
		$PdiShatterResult = $result;
		evalDeferred -lp "createRigidbodiesAfterShatter($PdiShatterResult)";
    }

//	string $voronodes[] = `ls -selection -dag -type "pdiVoronoiNode"`;

	//setLayerTo all".visibility";
	string $currentLayer= `editDisplayLayerGlobals -q -cdl`;
	//string $Layer=`objectLayer ShatterLocator1`;
	int $layerVisible= getAttr ($currentLayer + ".visibility" );
	if( $layerVisible==false)
	{
		warning -noContext "active display layer is hidden"; 
	}

//	button -edit -enable true $butPdiUndoShatter;		

	deletePdiLocators();

	$pdiUpdate = 1;//enable update		
									
    waitCursor -state off;
	undoInfo -swf on;
}
global proc pdiUpdateNumCenters()
{
    global string $fieldPdiNumberOfCenters;
	global int $shiPreviewModeOn;	  	 
    
	int $numCenters = `intSliderGrp -query -value $fieldPdiNumberOfCenters`;	
	string $shatterLocator[] = `ls  -dag -type "ShatterLocator"`;
	if( size($shatterLocator) > 0)
	{
		//locator exist already, update it
		$transform = `listRelatives -parent $shatterLocator[0]`;
		select $transform;//select parent node
//		delete $shatterLocator[0];		
		setAttr ($shatterLocator[0] + ".numLoc" ) $numCenters;
	    getAttr($shatterLocator[0] + ".ca_numloc" );
		if( $shiPreviewModeOn) updateShatteritPreview();
	}		
}

global proc pdiPickObject()
{
    global string $comboShatterStyle;   
    global string $shiRefObject;
    global string $butPdiSelectPath;
	global int $shiPreviewModeOn;	  	 
	global string $shiPreviewObject;	

	int $shatterStyle = `optionMenu -query -select $comboShatterStyle`;

	if( $shatterStyle==5)
    {
		//path-based
	    string $selection[] = `ls -selection -dag -type "nurbsCurve"`;

		if(  size($selection) > 0)
		{
			$shiRefObject = $selection[0];
			string $selected = "Shatter Path: " +  $shiRefObject;
			button -edit -label $selected -bgc 0.7 0.7 0.7 $butPdiSelectPath;

			if( $shiPreviewModeOn) updateShatteritPreview();
		}
		else
		{
			button -edit -label "Select path" -bgc 0.4 0.4 0.4 $butPdiSelectPath;
			$shiRefObject = "";
			warning -noContext "No curve object selected";
			if( $shiPreviewModeOn == 1)
			{
				if( `objExists $shiRefObject`)
				{
					$refTransfom=`listRelatives -p $shiRefObject`;
					$refObjUIState=`toggle -template -q $refTransfom[0]`;
					if( $refObjUIState==1)toggle -template $refTransfom[0];
				}

				//disable preview mode
				string $shatterLocator[] = `ls  -dag -type "ShatterLocator"`;
				if( size($shatterLocator) > 0)
				{
					hide $shatterLocator[0];
				}	
				disableShatteritPreviewMode();
			}
			$shiRefObject = "";
		}
	}
	else
	if( $shatterStyle==7)
    {
		//adquire
	    string $selection[] = `ls -selection -dag -type "pdiVoronoiNode"`;

		if(  size($selection) == 0)
		{
			//maybe selected is a fragment
			string $transformNode[]= `ls -selection -dag -type "transform"`;
			if( size($transformNode) > 0)
			{
				string $shatterGroup[]=`listRelatives -p$transformNode[0]`;
				if( size($shatterGroup) > 0)
					$selection = `listRelatives -ad -typ "pdiVoronoiNode" $shatterGroup[0]`;
			}
		}

		if(  size($selection) > 0)
		{
			$shiRefObject = $selection[0];
			string $transformNode[]=`listRelatives -p $shiRefObject`;
			string $shatterGroup[]=`listRelatives -p $transformNode[0]`;

			string $selected = "Source: " +  $shatterGroup[0];
			button -edit -label $selected -bgc 0.7 0.7 0.7 $butPdiSelectPath;

			if( $shiPreviewModeOn) updateShatteritPreview();
		}
		else
		{
			button -edit -label "Select Source Object" -bgc 0.4 0.4 0.4 $butPdiSelectPath;
			warning -noContext "No shatter group selected";
			if( $shiPreviewModeOn == 1)
			{
				if( `objExists $shiRefObject`)
				{
					$refTransfom=`listRelatives -p $shiRefObject`;
					$refObjUIState=`toggle -template -q $refTransfom[0]`;
					if( $refObjUIState==1)toggle -template $refTransfom[0];
				}

				//disable preview mode
				string $shatterLocator[] = `ls  -dag -type "ShatterLocator"`;
				if( size($shatterLocator) > 0)
				{
					hide $shatterLocator[0];
				}	
				disableShatteritPreviewMode();
			}
			$shiRefObject = "";
		}
	}
	else
    {
	    string $selection[] = `ls -selection -dag -type "mesh"`;

		if( size($selection) > 0)
		{
			$shiRefObject = $selection[0];
			string $selected = "Source: " +  $shiRefObject;
			button -edit -label $selected -bgc 0.7 0.7 0.7 $butPdiSelectPath;

			if( $shiPreviewModeOn) updateShatteritPreview();
		}
		else
		{
			button -edit -label "Select Source Object" -bgc 0.4 0.4 0.4 $butPdiSelectPath;
			warning -noContext "No polygonal object selected";
			if( $shiPreviewModeOn == 1)
			{
				if( `objExists $shiRefObject`)
				{
					$refTransfom=`listRelatives -p $shiRefObject`;
					$refObjUIState=`toggle -template -q $refTransfom[0]`;
					if( $refObjUIState==1)toggle -template $refTransfom[0];
				}

				//disable preview mode
				string $shatterLocator[] = `ls  -dag -type "ShatterLocator"`;
				if( size($shatterLocator) > 0)
				{
					hide $shatterLocator[0];
				}	
				disableShatteritPreviewMode();
			}
			$shiRefObject = "";
		}
	}

}

global proc deletePdiLocators()
{
	// remove shatter locator if exist
	string $shatterLocator[] = `ls  -dag -type "ShatterLocator"`;
	if( size($shatterLocator) > 0)
	{
	    undoInfo -swf off;
//		setToolTo selectSuperContext;
		if( `window -ex winPdiBasicFractures`)
		{
			//disconect locator attributes from UI
			connectControl pdiShatterWidth "";
			connectControl pdiNumberOfRings "";
			connectControl pdiRingsNoise "";
			connectControl pdiNumShards "";
			connectControl pdiShardsSeed "";
			connectControl pdiNumberOfCenters "";
		}
		delete $shatterLocator[0];//it can be at most one locator
	    undoInfo -swf on;
	}		
}
global proc updateShatterStyle()
{
    global string $pdiFracturesWindow;
    global string $butPdiSelectPath;
    global string $shiRefObject;
    global string $fieldPdiNumberOfRings;
    global string $fieldPdiNumberOfCenters;    
    global string $fieldPdiShatterItNumShards;
	global string $fieldPdiShardsSeed;
    global string $fieldPdiRingsNoise;
    global string $pdiRadialAxisFrame;
    global string $fieldPdiShatterWidth;
   	global string $pdiRAXIS[3];    
    global string $comboShatterStyle;   
    global string $chkShItUseVolumeShape;
	global string $butPdiPreviewPoints;
	global int $shiPreviewModeOn;	  	 
	     
	//disable all shatter param first
    button -edit -enable false $butPdiSelectPath;
    floatSliderGrp -edit -enable false $fieldPdiShatterWidth;
    intSliderGrp -edit -enable false $fieldPdiNumberOfCenters;
    intSliderGrp -edit -enable false $fieldPdiNumberOfRings;
    floatSliderGrp -edit -enable false $fieldPdiRingsNoise;
    frameLayout -edit -enable false $pdiRadialAxisFrame;

	if(!(`objExists $shiRefObject`)) $shiRefObject="";

	if( $shiRefObject=="")
	{
		button -edit -bgc 0.4 0.4 0.4 $butPdiSelectPath;
	}

	int $shatterStyle = `optionMenu -query -select $comboShatterStyle`;

	//update ref object buttom acording to current shatter style
	string $selected;
	if( $shatterStyle==5)
	{
		//path based
		$selected = "Select Path";
		if( $shiRefObject!="" && `nodeType $shiRefObject`=="nurbsCurve")
		{
			$selected = "Shatter Path: " +  $shiRefObject;
			button -edit  -bgc 0.7 0.7 0.7 $butPdiSelectPath;
		}
		else
		{
			button -edit -bgc 0.4 0.4 0.4 $butPdiSelectPath;
		}
	}
	else
	if( $shatterStyle==7)
	{
		//adquire
		$selected = "Select Source Object";
		if( $shiRefObject!="" && `nodeType $shiRefObject`=="pdiVoronoiNode")
		{
			string $transformNode[]=`listRelatives -p $shiRefObject`;
			string $shatterGroup[]=`listRelatives -p $transformNode[0]`;

			$selected = "Source: " +  $shatterGroup[0];
			button -edit  -bgc 0.7 0.7 0.7 $butPdiSelectPath;
		}
		else			
		{
			button -edit -bgc 0.4 0.4 0.4 $butPdiSelectPath;
		}
	}
	else
	{
		$selected = "Select Source Object";
		if( $shiRefObject!="" && `nodeType $shiRefObject`=="mesh")
		{
			$selected = "Source: " +  $shiRefObject;
			button -edit  -bgc 0.7 0.7 0.7 $butPdiSelectPath;
		}			
		else
		{
			button -edit -bgc 0.4 0.4 0.4 $butPdiSelectPath;
		}
	}

	button -edit -label $selected $butPdiSelectPath;

	$bUseVolumeShape = `checkBox -query -value $chkShItUseVolumeShape`;
	button -edit -enable $bUseVolumeShape $butPdiSelectPath;

	//set control state for the current shatter style
	if( $shatterStyle==7)
    {
	   //aqquire
		checkBox -edit -enable false $chkShItUseVolumeShape;
        button -edit -enable true $butPdiSelectPath;
		button -edit -enable false $butPdiPreviewPoints;
		intSliderGrp -edit -enable false $fieldPdiShatterItNumShards;
		intSliderGrp -edit -enable false $fieldPdiShardsSeed;

		//preview mode not allowed with adquire shatter
		if( $shiPreviewModeOn)
		{
			string $shatterLocator[] = `ls  -dag -type "ShatterLocator"`;
			if( size($shatterLocator) > 0)
			{
				hide $shatterLocator[0];
			}	
			disableShatteritPreviewMode();
		}
    }
    else
	{
		intSliderGrp -edit -enable true $fieldPdiShatterItNumShards;
		intSliderGrp -edit -enable true $fieldPdiShardsSeed;

		if( $shatterStyle==6)
		{
		   //vertex color
			checkBox -edit -enable true $chkShItUseVolumeShape;
			button -edit -enable true $butPdiPreviewPoints;
		}
		else
		if( $shatterStyle==5)
		{
		   //path based
			checkBox -edit -enable false $chkShItUseVolumeShape;
			button -edit -enable true $butPdiSelectPath;
			floatSliderGrp -edit -enable true $fieldPdiShatterWidth;
			floatSliderGrp -edit -value 0.2 $fieldPdiShatterWidth;                
			button -edit -enable true $butPdiPreviewPoints;
		}
		else
		if( $shatterStyle==4)
		{
			//wood splinters
			floatSliderGrp -edit -enable true $fieldPdiShatterWidth;	
			floatSliderGrp -edit -value 1.0 $fieldPdiShatterWidth;        
			intSliderGrp -edit -value 1 $fieldPdiNumberOfCenters;
			frameLayout -edit -enable true $pdiRadialAxisFrame;	
			radioButton -edit -select $pdiRAXIS[1];       
			checkBox -edit -enable true $chkShItUseVolumeShape;
			button -edit -enable true $butPdiPreviewPoints;
		} 
		else
		if( $shatterStyle==3)
		{
			//radial
			intSliderGrp -edit -enable true $fieldPdiNumberOfRings;
			floatSliderGrp -edit -enable true $fieldPdiRingsNoise;
			floatSliderGrp -edit -enable true $fieldPdiShatterWidth;
			floatSliderGrp -edit -value 1.0 $fieldPdiShatterWidth;                
			intSliderGrp -edit -value 1 $fieldPdiNumberOfCenters;

			frameLayout -edit -enable true $pdiRadialAxisFrame;	
			radioButton -edit -select $pdiRAXIS[0];       
			checkBox -edit -enable true $chkShItUseVolumeShape;
			button -edit -enable true $butPdiPreviewPoints;
		} 
		else
		if( $shatterStyle==2)
		{
			//local
			floatSliderGrp -edit -enable true $fieldPdiShatterWidth;
			floatSliderGrp -edit -value 0.2 $fieldPdiShatterWidth;                
			intSliderGrp -edit -enable true $fieldPdiNumberOfCenters;
			checkBox -edit -enable true $chkShItUseVolumeShape;
			button -edit -enable true $butPdiPreviewPoints;
		}
		else
		if( $shatterStyle==1)
		{
			intSliderGrp -edit -value 1 $fieldPdiNumberOfCenters;
			checkBox -edit -enable true $chkShItUseVolumeShape;
			button -edit -enable true $butPdiPreviewPoints;
		}
	}
	
	if( $shiPreviewModeOn) updateShatteritPreview();

    showWindow $pdiFracturesWindow;
}
global proc string getCurrentPdiCutMaterial()
{
	string $selection[] = `ls -selection -dag -type "mesh"`;
	if( size($selection) == 0)
	{
		//maybe selection is a voronoi node
		$selection = `ls -selection -dag -type "pdiVoronoiNode"`;
		if( size($selection) > 0)
		{
			string $transformNode[]=`listRelatives -p $selection[0]`;
			$ShatterGroup=`listRelatives -p $transformNode[0]`;
			$selection=`listRelatives -path -ni -ad -typ "mesh" $ShatterGroup[0]`;
		}
	}
	for($obj in $selection)
	{
		string $shaders[] = `listConnections -d false -type "shadingEngine" $obj`;
		for($shader in $shaders)
		{
			string $materials[] = `listConnections -type "lambert" $shader`;
			for($mat in $materials)
			{    
				int $result=`attributeQuery -node $mat -ex "cutmat"`;
				if( $result > 0)
				{
				   return $mat; 
				} 
			} 
		} 
	} 

	return (""); 
}
global proc updatePdiShatterPanel()
{
    global string $pdiFracturesWindow;
    global string $fieldPdiShatterItNumShards;
	global string $fieldPdiShardsSeed;
    global string $butPdiSelectPath;
    global string $chkShItAssignNewMat;
    global string $ShItCutMatName;    
    global string $shiRefObject;
    global string $fieldPdiNumberOfRings;
    global string $fieldPdiNumberOfCenters;    
    global string $fieldPdiRingsNoise;
    global string $pdiRadialAxisFrame;
    global string $fieldPdiShatterWidth;
    global string $comboShatterStyle;   
    global string $butPdiCustomMapping; 
	global string $butPdiUndoShatter;	 
	global string $butPdiResetShatter;
    global string $lblPdiCurrentShards;
    global string $chkShItUseVolumeShape;
	global string $shiPreviewObject;
	global int $shiPreviewModeOn;	  	 
	global int $pdimatcounter;
    global string $chkShItUseVolumeShape;
	global string $chkShItDetectMeshGroups;
    global int $pdiUpdate;

	if( $pdiUpdate == false)
	{
		return;	
	}	

    int $bWExist = `window -ex winPdiBasicFractures` ;
    if( $bWExist == false)
    {
//		print("pdiShatterWin iconified, abort\n");			
        return;
    }
	
//	print("updatePdiShatterPanel\n");			
	        
	//disable any previous Shatter it drawing
	string $voronoiNodes[]= `ls -dag -type "pdiVoronoiNode"`;
	for($obj in $voronoiNodes)
	{
		setAttr ($obj + ".draw" ) 0;
		//force update
		getAttr -sl ($obj + ".cadraw" );                               
	}
    clear($voronoiNodes);

	string $shatterLocator[] = `ls  -dag -type "ShatterLocator"`;
    string $selection[] = `ls -selection -dag -type "mesh"`;
	if( size($selection) == 0)
	{
		//maybe selection is a voronoi node
		$selection = `ls -selection -dag -type "pdiVoronoiNode"`;
		$voronoiNodes = $selection;
	}
	else
	{
		$transformNode=`listRelatives -p  $selection[0]`;
		$ShatterGroup=`listRelatives -p $transformNode[0]`;
		if( size($ShatterGroup) > 0)
			$voronoiNodes=`listRelatives -ad -typ pdiVoronoiNode $ShatterGroup[0]`;
		if( size($voronoiNodes) > 0)
		{
			//prevent from draw voronode in isolated view
			$vorotransform=`listRelatives -p  $voronoiNodes[0]`;
			select -d $vorotransform;
		}
	}
	if( size($voronoiNodes) > 0 )
	{
		//Enable Shatter it drawing
		setAttr ($voronoiNodes[0]+ ".draw" ) 1;
		//force update
		getAttr -sl ($voronoiNodes[0] + ".cadraw" );           

		int $detectMeshGroups = `getAttr ($voronoiNodes[0]+ ".dmg" )`;
		checkBox -edit -value $detectMeshGroups $chkShItDetectMeshGroups;
	}

	if( $shiPreviewModeOn)
	{
		if( size($selection) > 0 && $shiPreviewObject!=$selection[0])
		{
//			print( $shiPreviewObject + "diferent " +$selection[0] + "\n");
		    undoInfo -swf off;						
			if( $shiPreviewModeOn == 1)
			{				
				text -edit -label " " $lblPdiCurrentShards;										
					
//				if( size($shatterLocator) > 0)
//				{
//					hide $shatterLocator[0];
//				}	
				deletePdiLocators();
				disableShatteritPreviewMode();
			}
		    undoInfo -swf on;						
		}			
		else
		{
			int $shatterStyle = `optionMenu -query -select $comboShatterStyle`;
			if( $shatterStyle==1 || $shatterStyle==2 || $shatterStyle==3 || $shatterStyle==4)
			{
				if( size($shatterLocator) > 0)
				{			    
					select $shatterLocator[0];
					setToolTo ShowManips;
				}
			}
		}
	}
	else
	{
		text -edit -label " " $lblPdiCurrentShards;										
	}
	
    if( size($selection) > 0 && $shiPreviewModeOn==0)
    {
	    button -edit -enable true $butPdiResetShatter;		
		button -edit -enable true $butPdiUndoShatter;		
    }
    else
    {
	    button -edit -enable false $butPdiResetShatter;	
		button -edit -enable false $butPdiUndoShatter;					
    }

    clear($selection);

	//disable all shatter param first
    button -edit -enable false $butPdiSelectPath;
    floatSliderGrp -edit -enable false $fieldPdiShatterWidth;
    intSliderGrp -edit -enable false $fieldPdiNumberOfCenters;
    intSliderGrp -edit -enable false $fieldPdiNumberOfRings;
    floatSliderGrp -edit -enable false $fieldPdiRingsNoise;
    frameLayout -edit -enable false $pdiRadialAxisFrame;
	checkBox -edit -enable false $chkShItUseVolumeShape;

	$bUseVolumeShape = `checkBox -query -value $chkShItUseVolumeShape`;

	if(!(`objExists $shiRefObject`)) $shiRefObject="";

	if( $shiRefObject=="" || $bUseVolumeShape==0)
	{
		button -edit -bgc 0.4 0.4 0.4 $butPdiSelectPath;
	}
	
	int $shatterStyle = `optionMenu -query -select $comboShatterStyle`;

	string $selected;
	if( $shatterStyle==5)
	{
		//path based
		$selected = "Select Path";
		if( $shiRefObject!="" && `nodeType $shiRefObject`=="nurbsCurve")
		{
			$selected = "Shatter Path: " +  $shiRefObject;
			button -edit -bgc 0.7 0.7 0.7 $butPdiSelectPath;
		}
	}
	else
	if( $shatterStyle==7)
	{
		//adquire
		$selected = "Select Source Object";
		if( $shiRefObject!="" && `nodeType $shiRefObject`=="pdiVoronoiNode")
		{
			string $transformNode[]=`listRelatives -p $shiRefObject`;
			string $shatterGroup[]=`listRelatives -p $transformNode[0]`;

			//override detect mesh group with source value 
			int $detectMeshGroups = `getAttr ($shiRefObject+ ".dmg" )`;
			checkBox -edit -value $detectMeshGroups $chkShItDetectMeshGroups;

			$selected = "Source: " +  $shatterGroup[0];
			button -edit -bgc 0.7 0.7 0.7 $butPdiSelectPath;
		}			
	}
	else
	{
		$selected = "Select Source Object";
		if( $shiRefObject!="" && `nodeType $shiRefObject`=="mesh")
		{
			$selected = "Source: " +  $shiRefObject;
			if( $bUseVolumeShape>0)
				button -edit -bgc 0.7 0.7 0.7 $butPdiSelectPath;
		}			
	}
	button -edit -label $selected $butPdiSelectPath;

	button -edit -enable $bUseVolumeShape $butPdiSelectPath;
	intSliderGrp -edit -enable true $fieldPdiShatterItNumShards;	
	intSliderGrp -edit -enable true $fieldPdiShardsSeed;
	
	//set control state for the current shatter style               	
	if( $shatterStyle==7)
    {
		//adqurire shatter
        button -edit -enable true $butPdiSelectPath;
		checkBox -edit -enable false $chkShItUseVolumeShape;
		intSliderGrp -edit -enable false $fieldPdiShatterItNumShards;	
		intSliderGrp -edit -enable false $fieldPdiShardsSeed;
    }
	else
	if( $shatterStyle==6)
    {
		//vertex color shatter
        button -edit -enable true $butPdiSelectPath;
		checkBox -edit -enable true $chkShItUseVolumeShape;
    }
    else
	if( $shatterStyle==5)
    {
		//path based
		checkBox -edit -enable false $chkShItUseVolumeShape;
        button -edit -enable true $butPdiSelectPath;
        floatSliderGrp -edit -enable true $fieldPdiShatterWidth;
    }
    else
	if( $shatterStyle==4)
	{
		//wood splinters shatter
        frameLayout -edit -enable true $pdiRadialAxisFrame;	
        floatSliderGrp -edit -enable true $fieldPdiShatterWidth;        
		checkBox -edit -enable true $chkShItUseVolumeShape;
	} 
	else
	if( $shatterStyle==3)
    {
		//redial shatter
        floatSliderGrp -edit -enable true $fieldPdiShatterWidth;        
        intSliderGrp -edit -enable true $fieldPdiNumberOfRings;
        floatSliderGrp -edit -enable true $fieldPdiRingsNoise;
        frameLayout -edit -enable true $pdiRadialAxisFrame;
		checkBox -edit -enable true $chkShItUseVolumeShape;
    }
	else
	if( $shatterStyle==2)
    {
		//local shatter
        floatSliderGrp -edit -enable true $fieldPdiShatterWidth;
        intSliderGrp -edit -enable true $fieldPdiNumberOfCenters;
		checkBox -edit -enable true $chkShItUseVolumeShape;
    }
    else
	if( $shatterStyle==1)
	{
		checkBox -edit -enable true $chkShItUseVolumeShape;
	}

	string $pdicutmat=getCurrentPdiCutMaterial();
	if( $pdicutmat!="")
    {
        checkBox -edit -value 1 $chkShItAssignNewMat;
	    textField -edit -tx $pdicutmat $ShItCutMatName;                
    }

//    showWindow $pdiFracturesWindow;    
//	evalDeferred -lp "setFocus MayaWindow";
}
global proc pdiInputNoiseRings()
{
    global string $fieldPdiRingsNoise;
	global int $shiPreviewModeOn;	  	 

    float $noiseRingsValue = `floatSliderGrp -query -value  $fieldPdiRingsNoise`;

	if( $shiPreviewModeOn) updateShatteritPreview();
}

global proc pdiInputNumRings()
{
    global string $fieldPdiNumberOfRings;
	global int $shiPreviewModeOn;	  	 

    int $numShards = `intSliderGrp -query -value  $fieldPdiNumberOfRings`;

	if( $shiPreviewModeOn) updateShatteritPreview();
}
global proc pdiInputNumShards()
{
    global string $fieldPdiShatterItNumShards;
	global string $fieldPdiShardsSeed;
    global string $comboShatterStyle; 
	global string $shiPreviewObject;	  	
	global int $shiPreviewModeOn;	  	 
	   
    int $numShards = `intSliderGrp -query -value $fieldPdiShatterItNumShards`;

	if( $shiPreviewModeOn) updateShatteritPreview();
}

global proc updateShatterLocatorParams()
{
	string $shatterLocator[] = `ls  -dag -type "ShatterLocator"`;
	if( size($shatterLocator) > 0)
	{
	    getAttr($shatterLocator[0]+".caup");

    //  refresh -force;
	}
}
global proc updateShatteritPreview()
{
    global string $fieldPdiShatterItNumShards;
	global string $fieldPdiShardsSeed;	
    global string $comboShatterStyle;
    global string $fieldPdiNumberOfCenters;	 
    global string $fieldPdiShatterWidth;
	global string $fieldPdiNumberOfRings;
	global string $fieldPdiRingsNoise;
   	global string $pdiRAXIS[3];
    global string $shiRefObject;
    global string $chkShItUseVolumeShape;
	global float $selectionbbox[];  
	global string $shiPreviewObject;		 
	global int $shiPreviewModeOn;	  	 

	if( !(`objExists $shiPreviewObject`))return;
	if( $shiPreviewModeOn == 0)setShatteritPreviewMode();

//	print("updateShatteritPreview\n");

	int $numShards = `intSliderGrp -query -value $fieldPdiShatterItNumShards`;
	int $seed = `intSliderGrp -query -value $fieldPdiShardsSeed`;
	int $shatterStyle = `optionMenu -query -select $comboShatterStyle`;
	int $numCenters = `intSliderGrp -query -value $fieldPdiNumberOfCenters`;
	float $width = `floatSliderGrp -query -value $fieldPdiShatterWidth`;
    int $numRings = `intSliderGrp -query -value $fieldPdiNumberOfRings`;
    float $noiseRings = `floatSliderGrp -query -value $fieldPdiRingsNoise`;
	int $radialAxis;
    if( `radioButton -query -select $pdiRAXIS[0]`)
    {
        $radialAxis=0;
    }
    else
    if( `radioButton -query -select $pdiRAXIS[1]`)
    {
        $radialAxis=1;
    }
    else
    {
        $radialAxis=2;
    }

	int $bUseVolumeShape=0;
	if( $shatterStyle==5)
	{
		//path-based needs always a reference curve for shattering
		$bUseVolumeShape = 1;
	}
	else
	{		
		$bUseVolumeShape = `checkBox -query -value $chkShItUseVolumeShape`;
	}

	string $shatterLocator[] = `ls  -dag -type "ShatterLocator"`;
	if( size($shatterLocator)== 0)
	{
		//create locator
		$transform = `listRelatives -parent $shiPreviewObject`;
		$shatterLocator[0] = `createNode -p $transform ShatterLocator`;	
	}
	else
	{
		//just in case locator is hidden
		showHidden $shatterLocator[0];
	}

	if( $bUseVolumeShape && `objExists $shiRefObject`)
	{
		if(  $shiRefObject==$shiPreviewObject)
		{
			warning  -noContext "volume shape and selected mesh are the same object";						
		}
	  // use reference object for shattering
		pdiShatterPreview -dp -st $shatterStyle -ns $numShards -seed $seed
						-wd $width -noc $numCenters 
						-ra $radialAxis -nr $numRings -no $noiseRings
						-reo $shiRefObject
						-xmin $selectionbbox[0] -ymin $selectionbbox[1] -zmin $selectionbbox[2]
						-xmax $selectionbbox[3] -ymax $selectionbbox[4] -zmax $selectionbbox[5]
						$shiPreviewObject;
	}
	else
	{
		 $result1 = `pdiShatterPreview -dp -st $shatterStyle -ns $numShards -seed $seed
						-wd $width -noc $numCenters 
						-ra $radialAxis -nr $numRings -no $noiseRings
						-xmin $selectionbbox[0] -ymin $selectionbbox[1] -zmin $selectionbbox[2]
						-xmax $selectionbbox[3] -ymax $selectionbbox[4] -zmax $selectionbbox[5]
						$shiPreviewObject`;
	}

	if( $shatterStyle==1 || $shatterStyle==2 || $shatterStyle==3 || $shatterStyle==4 || $shatterStyle==6)
	{
		select $shatterLocator[0];
		setToolTo ShowManips;
	}
	else
	{
		select $shiRefObject;
	}
}
global proc disableShatteritPreviewMode()
{
	global int  $vertexColorState[];
	global string $butPdiPreviewPoints;
	global string $shiPreviewObject;	  
	global string $shiRefObject;
	global int $shiPreviewModeOn;	  	 

	if( `objExists $shiPreviewObject`)
	{
		string $ShatterGroup[];
		$previewNode=`listRelatives -p $shiPreviewObject`;			
		$objUIState=`toggle -template -q $previewNode[0]`;
		if( $objUIState==1)toggle -template $previewNode[0];
		if( `objExists $shiRefObject`)
		{
			$refTransfom=`listRelatives -p $shiRefObject`;
			$refObjUIState=`toggle -template -q $refTransfom[0]`;
			if( $refObjUIState==1)toggle -template $refTransfom[0];
		}

//		if($vertexColorState[0] > 0) polyOptions -cs true  $shiPreviewObject;

		string $voronoiTransformNode;
		string $connect[]=`listConnections -s false -d true -sh true ($shiPreviewObject + ".worldMesh[0]")`;
		if( size( $connect) > 0 && `nodeType $connect[0]`=="pdiVoronoiNode")
		{
			$voronoiNode=$connect[0];
			//force update
			$TransformNode=`listRelatives -p $voronoiNode`;
			$voronoiTransformNode = $TransformNode[0];
			$ShatterGroup=`listRelatives -p $voronoiTransformNode`;
			if( size($ShatterGroup)>0)
			{
				$fragments=`listRelatives -c $ShatterGroup[0]`;//includes voronode
				$transformNode=`listRelatives -p $ShatterGroup[0]`;
				showHidden $fragments;		
				if( size( $transformNode) > 0 && $transformNode[0]==$previewNode[0])
				{	
					//preview object is child of previewNode
					hide $shiPreviewObject;
				}			     
				else
				{
					//hide node if shatter group has fragments
					if( size( $fragments) > 1)hide $previewNode;
				}
			}		   
		}
		int $visible = `getAttr ( $previewNode[0] + ".visibility" )`;
		if( $visible)
			select  $previewNode[0];//select the original object by user if visible
		else
	    if( size($ShatterGroup)>0)
		{
			if( `objExists $voronoiTransformNode`)
			{
				select $voronoiTransformNode;
			}
			else
			{				
				select $ShatterGroup[0];
			}					
		}
	}
	$shiPreviewObject="";
	$shiPreviewModeOn=0;

    int $buttonExist  = `button -ex $butPdiPreviewPoints`;
    if( $buttonExist)
    {
		button -edit -label "Preview" $butPdiPreviewPoints;
	}
}
global proc resetShatteritPreviewMode()
{
	global string $shiPreviewObject;	
	global int  $vertexColorState[];
    global string $shiRefObject;

//	print("resetShatteritPreview\n");

//	$vertexColorState = `polyOptions -q -cs $shiPreviewObject`;
//	print  ($shiPreviewObject + " vc state = " + $vertexColorState[0]);
//	if($vertexColorState[0] > 0) polyOptions -cs false $shiPreviewObject;

	$transfom=`listRelatives -p $shiPreviewObject`;
	evalDeferred -lp ("toggle -template "  + $transfom[0]);
	if( `objExists $shiRefObject`)
	{
		if($shiRefObject!=$shiPreviewObject)
		{
			$transfom=`listRelatives -p $shiRefObject`;
			evalDeferred -lp ("toggle -template "  +  $transfom[0]);
		}
	}
	  
	deletePdiLocators();
	updateShatteritPreview();
}
global proc setShatteritPreviewMode()
{
	global string $fieldPdiShardsSeed;
    global string $fieldPdiShatterItNumShards;
	global string $fieldPdiNumberOfCenters;
	global string $fieldPdiShatterWidth;
	global string $fieldPdiNumberOfRings;
	global string $fieldPdiRingsNoise;
	global string $butPdiPreviewPoints;
    global string $lblPdiCurrentShards;
	global string $shiPreviewObject;	  
    global string $shiRefObject;
	global float $selectionbbox[];  
	global int  $vertexColorState[];
	global int $shiPreviewModeOn;	

	if( $shiPreviewModeOn == 1)
	{
		undoInfo -swf off;

		//disable preview mode
	
		deletePdiLocators();
		disableShatteritPreviewMode();

		undoInfo -swf on;
	}
	else
	{
		undoInfo -swf off;

		string  $PDIObjects[];
		$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;

		for ( $obj in $PDIObjects )
		{
    		string  $connectedFbodies[];
    		string  $connectedClusters[];
			$connectedFbodies = `listConnections -type pdiFbodyNode $obj`;
			if( size($connectedFbodies) == 0)
			{
				$connectedClusters = `listConnections -type ClusterPdiNode $obj`;
				if( size($connectedClusters) > 0)
				{
					$connectedFbodies = `listConnections -type pdiFbodyNode $connectedClusters[0]`;
				}
			}
			if( size($connectedFbodies) > 0 || size($connectedClusters) > 0)
			{		    
				$transform = `listRelatives -p $obj`;  
				string $msg = ($transform[0] + " belong to a fracture body." + " Delete fracture body " + $connectedFbodies[0] + " for reshattering");
				confirmDialog
				-title "Pdi Info"
				-message $msg
				-button "OK" 
				-defaultButton "OK" ;
			
				return;			 	
			}
			break;//checking the first riid body found is enough?
		}

		string $PDICrackers[] = `ls -selection -dag -leaf -type pdiCracker`;
		if( size($PDICrackers) > 0)
		{
			warning -noContext "PDI Info: crackers objects cannot be shattered\n";
			return;
		}

		$shiPreviewModeOn=0;

		string $selection[] = `ls -selection -dag -type "mesh"`;
		if( size($selection) == 0)
		{
			//maybe selection is a voronoi node
			$selection = `ls -selection -dag -type "pdiVoronoiNode"`;
			if( size($selection) > 0)
			{
				string $transformNode[]=`listRelatives -p $selection[0]`;
				$ShatterGroup=`listRelatives -p $transformNode[0]`;
				$selection=`listRelatives -path -ni -ad -typ "mesh" $ShatterGroup[0]`;
			}
		}

		if( size( $selection) > 0)
		{
			string $sourceTRS[]=`listRelatives -ap $selection[0]`;      
			
			if( size($sourceTRS) > 1)  
			{
				$selection = `ls -selection `;

                string $msg1 = ("Object " + $selection[0] + " is an instance, convert it to object( Modify->convert->instance to object)");
                error -noContext $msg1;
				return;
			}

			int $shatterShardAlone=0;
			if( hasVoroNode( $selection[0]))
			{
				if(`keyframe -query -keyframeCount $sourceTRS[0]` != 0)
				{
					//string $msg = "selected shatter group has transform keys, delete all fragments keys to reshatter the object";
					//confirmDialog -title "Pdi Info"-message $msg -button "OK" -defaultButton "OK" ;

				    string $msg ="selected shard is animated and belong to a PDI shatter group, reshatter this single fragment?";
					string $result = `confirmDialog -title "Pdi Info"-message $msg -button "Yes" -button "No" -defaultButton "Yes" 
					-cancelButton "No" -dismissString "No"`;

					if( $result == "No")
					{
						return;
					}			    					

					$shatterShardAlone=1;
				}
			}

			$selectionbbox = `exactWorldBoundingBox $selection`;
			$selectionbbox[0] = UIToCm($selectionbbox[0]);
			$selectionbbox[1] = UIToCm($selectionbbox[1]);
			$selectionbbox[2] = UIToCm($selectionbbox[2]);
			$selectionbbox[3] = UIToCm($selectionbbox[3]);
			$selectionbbox[4] = UIToCm($selectionbbox[4]);
			$selectionbbox[5] = UIToCm($selectionbbox[5]);

			if( $shiPreviewObject!=$selection[0])
			{
				string $transformNode[];
				string $newPreviewObject = $selection[0];
				if( hasVoroNode($newPreviewObject) && !$shatterShardAlone)
				{
					$transformNode=`listRelatives -p $newPreviewObject`;
					$ShatterGroup=`listRelatives -p $transformNode`;
					$voronoiNode=`listRelatives -ad -typ "pdiVoronoiNode" $ShatterGroup[0]`;

					//select the original node
					string $connect[]=`listConnections -type "mesh" -sh true ($voronoiNode[0]+ ".inShape")`;
					if( size($connect)>0)
					{
	//					print("select original node");
						$newPreviewObject = $connect[0];
						$transformNode=`listRelatives -p $newPreviewObject`;
						showHidden $transformNode[0];
						//force update
						$fragments=`listRelatives -c $ShatterGroup`;
						hide $fragments;
						//display number of history points
						int $historyPoints[] = `getAttr  -mi ($voronoiNode[0] +".voroPoints")`;
						string $strHistoryPoints=( "added to " + size($historyPoints) +" current points");
						text -edit -label $strHistoryPoints $lblPdiCurrentShards;										
					}
				}
				$shiPreviewModeOn=1;

				if( $shiPreviewObject!=$newPreviewObject)
				{
					$shiPreviewObject=$newPreviewObject;
					resetShatteritPreviewMode();
				}
				else
				{			
//					$vertexColorState = `polyOptions -q -cs $shiPreviewObject`;
//					print  ($shiPreviewObject + " vc state = " + $vertexColorState[0]);
//					if($vertexColorState[0] > 0) polyOptions -cs false $shiPreviewObject;

					$transfom=`listRelatives -p $shiPreviewObject`;
					evalDeferred -lp ("toggle -template "  + $transfom[0]);
					if( `objExists $shiRefObject`)
					{
						$transfom=`listRelatives -p $shiRefObject`;
						evalDeferred -lp ("toggle -template "  +  $transfom[0]);
					}
					updateShatteritPreview();
				}
			}
			else
			{
				$shiPreviewModeOn=1;
//				$vertexColorState = `polyOptions -q -cs $shiPreviewObject`;
//				print  ($shiPreviewObject + " vc state = " + $vertexColorState[0]);
//				if($vertexColorState[0] > 0) polyOptions -cs false $shiPreviewObject;

				$transfom=`listRelatives -p $shiPreviewObject`;
				evalDeferred -lp ("toggle -template "  + $transfom[0]);
				if( `objExists $shiRefObject`)
				{
					$transfom=`listRelatives -p $shiRefObject`;
					evalDeferred -lp ("toggle -template "  +  $transfom[0]);
				}

				updateShatteritPreview();
			}
			button -edit -label "End Preview" $butPdiPreviewPoints;
			
			//connect locator attributes to UI
			string $shatterLocator[] = `ls  -dag -type "ShatterLocator"`;
			if( size($shatterLocator) > 0)
			{
			   //update attributes before coonecting them
				float $width = `floatSliderGrp -query -value $fieldPdiShatterWidth`;
		    	setAttr ($shatterLocator[0]+".width" )  $width;
				int $rings = `intSliderGrp -query -value $fieldPdiNumberOfRings`;
		    	setAttr ($shatterLocator[0]+".rings" )  $rings;
				float $noise = `floatSliderGrp -query -value $fieldPdiRingsNoise`;
		    	setAttr ($shatterLocator[0]+".noise" )  $noise;
				int $np = `intSliderGrp -query -value $fieldPdiShatterItNumShards`;
		    	setAttr ($shatterLocator[0]+".numPoints" )  $np;
				int $seed = `intSliderGrp -query -value $fieldPdiShardsSeed`;
		    	setAttr ($shatterLocator[0]+".seed" )  $seed;
				int $numLoc = `intSliderGrp -query -value $fieldPdiNumberOfCenters`;
		    	setAttr ($shatterLocator[0]+".numLoc" )  $numLoc;

				//conect locator attributes to UI
				connectControl pdiShatterWidth ($shatterLocator[0]+".width");
				connectControl pdiNumberOfRings ($shatterLocator[0]+".rings");
				connectControl pdiRingsNoise ($shatterLocator[0]+".noise");
				connectControl pdiNumShards ($shatterLocator[0]+".numPoints");
				connectControl pdiShardsSeed ($shatterLocator[0]+".seed");
				connectControl pdiNumberOfCenters ($shatterLocator[0]+".numLoc");

				//update node
				getAttr($shatterLocator[0]+".caup");
			}

			//setLayerTo all".visibility";
			string $currentLayer= `editDisplayLayerGlobals -q -cdl`;
			//string $Layer=`objectLayer ShatterLocator1`;
			int $layerVisible= getAttr ($currentLayer + ".visibility" );
			if( $layerVisible==false)
			{
				warning -noContext "active display layer is hidden"; 
			}
			undoInfo -swf on;
		}
		else
		{
			print("PDI Info: no poly object selected\n");
		}
	}
}
global proc pdiNewMaterialName()
{
	global int $pdimatcounter=0;
    global string $ShItCutMatName;
    
	$pdimatcounter++;
    string $newName="pdiCutMat";
    $newName+=$pdimatcounter;
    
    textField -edit -tx $newName $ShItCutMatName;
    string $selection[] = `ls -selection -dag -type "mesh"`;

    if( size($selection) > 0)
	{
		if(  hasVoroNode($selection[0]))
		{
			string $result = `confirmDialog -title "Confirm" -message "update material in the current shatter group?"
			-button "Yes" -button "No" -defaultButton "Yes"
			-cancelButton "No" -dismissString "No"`;

			if( $result == "No")
			{
				return;
			}			    		

			pdiAdqShatter -rmt $newName $selection[0];
		}
	}	
}
global proc setUseVolumeShape()
{
    global string $chkShItUseVolumeShape;
	global string $shiRefObject;
    global string $butPdiSelectPath;
	global int $shiPreviewModeOn;	  	 

	$bUseVolumeShape = `checkBox -query -value $chkShItUseVolumeShape`;
	
    //update window
	if( $bUseVolumeShape > 0)
	{
		if( $shiRefObject=="")
		{
			button -edit  -bgc 0.4 0.4 0.4 $butPdiSelectPath;
		}
		else
		{
			button -edit  -bgc 0.7 0.7 0.7 $butPdiSelectPath;
		}

		button -edit -enable true $butPdiSelectPath;
	}
	else
	{
		button -edit  -bgc 0.4 0.4 0.4 $butPdiSelectPath;
		button -edit -enable false $butPdiSelectPath;
	}           

	if( $shiPreviewModeOn) updateShatteritPreview();

}

///////////////////////////////////////////////////////////////
//
// JAGGINESS PANEL
//
///////////////////////////////////////////////////////////////
global proc pdiAddJagginessExecute()
{
    global string $gMainProgressBar;  // This is defined on maya startup
    global string $butPdiAddJagginess;
	global string $butPdiRemoveJagginess;    
	global string $butPdiSoftenEdges;
    global string $fielShitJagResolution;
    global string $fieldShitJagStrenght;
	global string $SelectJaggyFragment;
	global string $fieldJaggiSoftenEdges;
   	global string $pdijaggyAffect[3];		
	
	
    if( $SelectJaggyFragment=="")
	{
		error -noContext "no fragment selected for adding jagginess";        

		return;
	}
    
    $transformNode=`listRelatives -p  $SelectJaggyFragment`;    
    $ShatterGroup=`listRelatives -p $transformNode`;    
    $rigidBodies=`listRelatives -ad -typ pdiRigidBody $ShatterGroup`;    
	if( size( $rigidBodies) > 0)	    
	{
		string $result = `confirmDialog -title "PDI Info" 
		-message "PDi bodies for current selection must be deleted before adding jagginess, proceed?"
		-button "Yes" -button "No" -defaultButton "No"
		-cancelButton "No" -dismissString "No"`;

		if( $result == "No")
		{
			return;
		}			    		
		else
	    {
	        $fracturebody = `listConnections -type pdiFbodyNode  $rigidBodies[0]`;
            if( size($fracturebody) > 0 )
            {
                deletePdiFBody -deleteBodies $fracturebody[0];
            }	
            else
            {
                undoInfo -swf off;
                for( $obj in $rigidBodies)
                {
    				deleteUserNode $obj;                    
                } 
                undoInfo -swf on;                
            }      
	    } 
	    	
	}

	int $startTime = `playbackOptions -query -minTime`;
	int $currentTime =`currentTime -query`;	
	
	if( $currentTime > $startTime)
	{
//	    warning -noContext "time set to start frame for adding jagginess";			
	
		currentTime -edit $startTime;				
	}	

    int $resolution = `intSliderGrp -query -value $fielShitJagResolution`;
    float $strength = `floatSliderGrp -query -value $fieldShitJagStrenght`;
    float $softenAngle = `floatSliderGrp -query -value $fieldJaggiSoftenEdges`;
	float $softenValue = (90.0 - $softenAngle)/90.0;

    int $affect_type;
    if( `radioButton -query -select $pdijaggyAffect[2]`)
	{
        $affect_type = 2;
	}
	else
    if( `radioButton -query -select $pdijaggyAffect[1]`)
    {
        $affect_type = 1;
    }
    else
    {
        $affect_type = 0;
    }

    waitCursor -state on;

    $result = `pdiJagginess -com -res $resolution -st $strength -sn $softenValue -affect $affect_type $SelectJaggyFragment`;

	select $SelectJaggyFragment;//trick for returning to object mode
	
//        progressBar -edit -endProgress $gMainProgressBar;

	button -edit -enable false $butPdiAddJagginess;		
	intSliderGrp -edit -enable false $fielShitJagResolution;										
	button -edit -enable true $butPdiRemoveJagginess;					
	button -edit -enable true $butPdiSoftenEdges;					

	if( `window -ex winPdiBasicFractures`)
	{
		updatePdiFracturesPanel();
	}

	if ( `window -ex winCreatePdiBodies` )
	{                
		updatePdiManagePanel();
	}


    waitCursor -state off;
}
global proc pdiRemovejagginessExecute()
{
	global string $SelectJaggyFragment;
	global string $butPdiAddJagginess;
	global string $butPdiRemoveJagginess;   
    global string $fielShitJagResolution;	
	global string $fieldJaggiSoftenEdges;	 
	global string $butPdiSoftenEdges;
   	global string $pdijaggyAffect[3];		

	float $softenAngle = `floatSliderGrp -query -value $fieldJaggiSoftenEdges`;
	float $softenValue = (90.0 - $softenAngle)/90.0;

    int $affect_type;
    if( `radioButton -query -select $pdijaggyAffect[2]`)
    {
        $affect_type = 2;
    }
    else
    if( `radioButton -query -select $pdijaggyAffect[1]`)
    {
        $affect_type = 1;
    }
    else
    {
        $affect_type = 0;
    }
	
	if( $affect_type != 0)
	{
	
		string $result = `confirmDialog -title "Confirm" -message "This action will delete jaggyness for the whole shatter-group, are you sure?"
		-button "Yes" -button "No" -defaultButton "Yes"
		-cancelButton "No" -dismissString "No"`;

		if( $result == "No")
		{
			return;
		}

	    undoInfo -swf off;    
        waitCursor -state on;

		if( $softenValue > 0.0)
		{
			//remove soften edges
			$result = `pdiJagginess -del -sn $softenValue -affect $affect_type $SelectJaggyFragment`;        	
		}
		
		//make faces planar( otherwise sometimes materials are missed)
		$result = `pdiJagginess -st 0.0 -affect $affect_type $SelectJaggyFragment`;

		//delete jaggyness for sub-shatter group
		$Parent=`listRelatives -p $SelectJaggyFragment`;
		$grandParent=`listRelatives -p $Parent`;
		$transformNodes=`listRelatives -c $grandParent`;
		for($obj in $transformNodes)
		{
			$PdiShapes=`listRelatives -path -ni -s $obj`;

			if( !nodeIsVisible( $PdiShapes[0]))
			{
				$transform2 = `listRelatives -type "transform" $obj`;
				if( size($transform2) > 0)
					$PdiShapes=`listRelatives -path -ni -s $transform2[0]`;
			}
			
			if( size( $PdiShapes) > 0)
			{	
				if( `attributeQuery -node $PdiShapes[0] -exists "inMesh"`)
				{				
					string $connect[]=`listConnections -d off -s on ($PdiShapes[0]+ ".inMesh")`;
					while(size($connect)>0)
					{	
						string $type=`nodeType $connect[0]`;

						if($type=="pdiMeshOpNode")
						{
							setAttr ($connect[0] + ".operationType" ) 0;
							//force update
							getAttr -sl ($connect[0] + ".outMesh" );                               
						}
						$connect=`listConnections -d off -s on ($connect[0])`;
					}
					delete -ch $PdiShapes[0];		
				}	
			}
		}	
        waitCursor -state off;	
	    undoInfo -swf on;								
	}		
	else
	{	
		if( $softenValue > 0.0)
		{
			//remove soften edges
			$result = `pdiJagginess -del -sn $softenValue -affect $affect_type $SelectJaggyFragment`;        	
		}

		//make faces planar
		$result = `pdiJagginess -st 0.0 -affect $affect_type $SelectJaggyFragment`;

		if( `attributeQuery -node $SelectJaggyFragment -exists "inMesh"`)
		{
		    undoInfo -swf off;    
						
			string $connect[]=`listConnections -d off -s on ($SelectJaggyFragment+ ".inMesh")`;
			while(size($connect)>0)
			{	
				string $type=`nodeType $connect[0]`;

				if($type=="pdiMeshOpNode")
				{
					setAttr ($connect[0] + ".operationType" ) 0;
					//force update
					getAttr -sl ($connect[0] + ".outMesh" );                               
				}
				$connect=`listConnections -d off -s on ($connect[0])`;
			}
			delete -ch $SelectJaggyFragment;		
//			$result = `pdiJagginess -del -affect $affect_type $SelectJaggyFragment`;

		    undoInfo -swf on;				
		}
	}
	button -edit -enable true $butPdiAddJagginess;		
	button -edit -enable false $butPdiRemoveJagginess;	
	button -edit -enable false $butPdiSoftenEdges;					
		
	intSliderGrp -edit -enable true $fielShitJagResolution;										
		
}
global proc setPdiJaggySoftEdges()
{
	global string $SelectJaggyFragment;
	global string $fieldJaggiSoftenEdges;
   	global string $pdijaggyAffect[3];		

	if( $SelectJaggyFragment=="")
	{
		return;//no fragmetn selected
	}
	
	float $softenAngle = `floatSliderGrp -query -value $fieldJaggiSoftenEdges`;
	float $softenValue = (90.0 - $softenAngle)/90.0;

    int $affect_type;
    if( `radioButton -query -select $pdijaggyAffect[2]`)
    {
        $affect_type = 2;
    }
	else
    if( `radioButton -query -select $pdijaggyAffect[1]`)
    {
        $affect_type = 1;
    }
    else
    {
        $affect_type = 0;
    }

	//add soften edges		
	$result = `pdiJagginess -sn $softenValue -affect $affect_type $SelectJaggyFragment`;			

}
global proc setPdiJaggyStrenght()
{
	global string $SelectJaggyFragment;
    global string $fieldShitJagStrenght;
   	global string $pdijaggyAffect[3];		
	
	int $startTime = `playbackOptions -query -minTime`;
	int $currentTime =`currentTime -query`;	
	
//	if( $currentTime > $startTime)
//	{			
//		string $msg="Warning: modifying jagginess in a frame diferent than start frame" +
//		"\ncan cause fragments edges doenst match each other, proceed anyway?";
//		string $result = `confirmDialog -title "Confirm" -message $msg
//			-button "Yes" -button "No" -defaultButton "No"
//			-cancelButton "No" -dismissString "No"`;

//		if( $result == "No")
//		{
//			return;
//		}	
//	}	

    int $affect_type;
    if( `radioButton -query -select $pdijaggyAffect[2]`)
    {
        $affect_type = 2;
    }
	else
    if( `radioButton -query -select $pdijaggyAffect[1]`)
    {
        $affect_type = 1;
    }
    else
    {
        $affect_type = 0;
    }
	
	if( $SelectJaggyFragment!="")
	{	
		string $connect[]=`listConnections -scn true -d off -s on ($SelectJaggyFragment+ ".inMesh")`;

		if( size($connect) > 0)//is it  a clean fragment?
		{
			//its a jaggy fragment, apply deformation
		float $strength = `floatSliderGrp -query -value $fieldShitJagStrenght`;

		$result = `pdiJagginess -st $strength -affect $affect_type $SelectJaggyFragment`;
	}
	}			
//	else
//	{
//       warning -noContext "PDi info: Only one fragment selection allowed";  	
//	}			
}
global proc pdiCheckFragmentForJaggy()
{	
	$PDIFragments =`ls -selection -dag -type "transform"`;
    if( size($PDIFragments) == 1)
    {
		string $Parent[];
		string $voronoiNodes[];
		$Parent=`listRelatives -p $PDIFragments[0]`;
		if( size($Parent) > 0)
		{
			$voronoiNodes =`listRelatives -ad -typ "pdiVoronoiNode" $Parent[0]`;
	
			if( size($voronoiNodes) == 0)
			{
	 			//may be a duplicated fragment
				$Parent2=`listRelatives -p $Parent[0]`;
				if( size($Parent2) > 0)
				{
					$voronoiNodes=`listRelatives -ad -typ "pdiVoronoiNode" $Parent2[0]`;	
					$Parent[0] =  $Parent2[0];
				}
			}
		}
		if( size($voronoiNodes) == 0)
		{
			error -noContext "PDI info: This object isnt generated with  Shatter it tool or PDI data has been removed";        
		}
		else
		{
			string $selectedVoroNode="";
			for ( $voronode in $voronoiNodes )
			{
				$voroTransform=`listRelatives -p $voronode`;
				$shatterGroup = `listRelatives -p $voroTransform[0]`;
				if( $shatterGroup[0]==$Parent[0])
				{
				  $selectedVoroNode =  $voronode;
				  break;
				}
			}
			if( $selectedVoroNode=="")
			{
				// select object is grouped with fragments but not a fragment
				print( "PDI info: This object looks like not valid to add jagginess to it, try selecting another one in the group");	
			}
			else
				print( "PDI info: This object looks like a valid PDI shard");	
		}
	}		
}

global proc pdiSelectFragmentForJaggy()
{
	global string $butPdiSelectJaggyFragment;    
    global string $butPdiAddJagginess;
	global string $butPdiRemoveJagginess;
	global string $butPdiSoftenEdges;
    global string $fieldShitJagStrenght;
    global string $fielShitJagResolution;    
	global string $fieldJaggiSoftenEdges;
    global string $pdiJaggyAfectcollection;
   	global string $pdijaggyAffect[3];			 	
	global string $SelectJaggyFragment;	
			
	string $lastSelectJaggyFragment=$SelectJaggyFragment;
	string $PDIFragments[];
	
	$PDIFragments =`ls -selection -dag -type "transform"`;
		
    if( size($PDIFragments) == 0)
    {
		$PDIShapes =`ls -selection -dag -type "mesh"`;
		if( size($PDIShapes)==0)		
		{
			button -edit -label "Select PDI Fragment" $butPdiSelectJaggyFragment;	
			button -edit -enable false $butPdiAddJagginess;		
			button -edit -enable false $butPdiRemoveJagginess;		
			button -edit -enable false $butPdiSoftenEdges;					
		
			$SelectJaggyFragment="";	
			
			return;	             		   	             
		}
		else
		{
			$PDIFragments=`listRelatives -p $PDIShapes[0]`;		
		}			
	}

	string $Parent[];
	string $voronoiNodes[];
	$Parent=`listRelatives -p $PDIFragments[0]`;
	if( size($Parent) > 0)
	{
		$voronoiNodes =`listRelatives -ad -typ "pdiVoronoiNode" $Parent[0]`;
	
		if( size($voronoiNodes) == 0)
		{
	 		//may be a duplicated fragment
			$Parent2=`listRelatives -p $Parent[0]`;
			if( size($Parent2) > 0)
			{
				$voronoiNodes=`listRelatives -ad -typ "pdiVoronoiNode" $Parent2[0]`;	
				$Parent[0] =  $Parent2[0];
			}
		}
	}

	if( size($voronoiNodes) == 0)
	{
//		   error -noContext "This fragment isnt generated with  Shatter it tool";        
  		button -edit -label "Select PDI Fragment" $butPdiSelectJaggyFragment;
  		   
  		$SelectJaggyFragment="";		             		   
	}
	else
	{	
//		print "find the correct voronode\n";

		string $selectedVoroNode="";
		for ( $voronode in $voronoiNodes )
		{
			$voroTransform=`listRelatives -p $voronode`;
		$shatterGroup = `listRelatives -p $voroTransform[0]`;
			if( $shatterGroup[0]==$Parent[0])
			{
			  $selectedVoroNode =  $voronode;
			  break;
			}
		}
		if( $selectedVoroNode=="")
		{
			// select object is grouped with fragments but not a fragment
  			button -edit -label "Select PDI Fragment" $butPdiSelectJaggyFragment;
  		   
  			$SelectJaggyFragment="";		             		   
			return;
		}
			
		$PdiShapes=`listRelatives -path -s $PDIFragments[0]`;
			
		if( $SelectJaggyFragment!=$PdiShapes[0])
		{			
			$SelectJaggyFragment=$PdiShapes[0];
			string $selected = " fragment: " +  $SelectJaggyFragment;
			button -edit -label $selected $butPdiSelectJaggyFragment;	
					
			if( size($PdiShapes) == 1)
			{
				//it is a clean fragment
//				print( "it is a clean fragment\n");

				button -edit -enable true $butPdiAddJagginess;		
			    intSliderGrp -edit -enable true $fielShitJagResolution;										
				button -edit -enable false $butPdiRemoveJagginess;	
				button -edit -enable false $butPdiSoftenEdges;					
			}		
			else
			{
				//check if it is really a jaggy fragment
				int $mode=0;
				string $type0="";
				string $type="";
				string $connect[]=`listConnections -scn true -d off -s on ($PdiShapes[0]+ ".inMesh")`;
				if(size($connect)>0)$type0=`nodeType $connect[0]`;
				while(size($connect)>0)
				{	
					$type=`nodeType $connect[0]`;
					if( $type== "polyNormalPerVertex")$mode=1;
					if($type=="pdiMeshOpNode")break;

					string $node = $connect[0];
					$connect=`listConnections -scn true -d off -s on ($connect[0])`;
				    string $nxnode = $connect[0];
					if( $node == $nxnode)break;// cycle loop, abort		
				}
				if( $type=="pdiMeshOpNode")
				{	
				    // jaggy fragment found
//					print( "it is a jaggy fragment\n");

					button -edit -enable false $butPdiAddJagginess;		
					intSliderGrp -edit -enable false $fielShitJagResolution;										
					button -edit -enable true $butPdiRemoveJagginess;	
					button -edit -enable true $butPdiSoftenEdges;					


					//update softedges control
					float $UIsoften=`floatSliderGrp -query -value $fieldJaggiSoftenEdges`;					        	
					float $softenAngle = getAttr ($selectedVoroNode + ".jaggySoften" );
					$softenAngle = 90.0*(1 -$softenAngle);//convert (1,0) range  to (0,90) angle
					if( $UIsoften != $softenAngle)
					{ 
						floatSliderGrp -edit -value $softenAngle $fieldJaggiSoftenEdges;					        	
					}	

					//update strenght to group value
					float $UIstrength=`floatSliderGrp -query -value $fieldShitJagStrenght`;					        	
					float $strength = getAttr ($selectedVoroNode + ".jaggyStrenght" );
//					print( "strength: " + $strength);
					if( $UIstrength != $strength)
					{ 
						floatSliderGrp -edit -value $strength $fieldShitJagStrenght;					        	
//								setPdiJaggyStrenght();// update params( causes great slow down)				
					}	
				}
				else
				{
					//check if it is  a pdi rigid body 
//					print $PdiShapes[1];
				    if( `nodeType $PdiShapes[1]`== "pdiRigidBody")
					{
						print ("it is a pdi body\n");
						button -edit -enable true $butPdiAddJagginess;		
						intSliderGrp -edit -enable true $fielShitJagResolution;			
						button -edit -enable false $butPdiRemoveJagginess;	
						button -edit -enable false $butPdiSoftenEdges;					
																			
					}	 
					else
					{
					   // seems it is a pdi fragment with some kind of uv mapping or modifier applied 
					   print( "it is a jaggy fragment with uv mapping \n");

					   //allow to add jagginess
						button -edit -enable true $butPdiAddJagginess;		
						intSliderGrp -edit -enable true $fielShitJagResolution;	
						button -edit -enable false $butPdiRemoveJagginess;	
						button -edit -enable false $butPdiSoftenEdges;					

						return;															
						
						//removed becouse some uv mapped fragments skip this test
						//check it is a clean fragment with uv mapping
						if( $type0=="polyAutoProj" || $type0=="polyPlanarProj"
							|| $type0=="polyCylProj" || $type0=="polySphProj") 						
						{

							button -edit -enable true $butPdiAddJagginess;		
							intSliderGrp -edit -enable true $fielShitJagResolution;		
							button -edit -enable false $butPdiRemoveJagginess;	
							button -edit -enable false $butPdiSoftenEdges;					
																					
						}																												
						else
						{
							error -noContext "cannot add jagginess to this shape";					    			
							button -edit -enable false $butPdiAddJagginess;		
							button -edit -enable false $butPdiRemoveJagginess;	
							button -edit -enable false $butPdiSoftenEdges;					
						}
					}	
				}							
			}	
		}
	}	
}
global proc pdiUpdateJagginessPanel()
{
   	global string $pdijaggyAffect[3];	
	global string $butPdiSelectJaggyFragment;    

    if( `radioButton -query -select $pdijaggyAffect[0]`)
    {
       button -edit -bgc 0.7 0.7 0.7 $butPdiSelectJaggyFragment;
	}
	else
    if( `radioButton -query -select $pdijaggyAffect[2]`)
    {
       button -edit -bgc 0.0 0.6 0.0 $butPdiSelectJaggyFragment;
	}
	else
    {
       button -edit -bgc 0.9 0.6 0.0 $butPdiSelectJaggyFragment;
	}
}

global proc pdiSelectParticleFromShape()
{
	$selection = `ls -selection -dag -type "transform"`;

    if( size($selection) == 0)
    {
		error -noContext "no transform node found in selection";
	}
	else
	{
	    int $particleShapeFound=0;
		for($obj in $selection)
		{
			$shapes =`listRelatives -path -ni -typ mesh $obj`;
			if( size($shapes) > 0)
			{
				string $connect[]=`listConnections -s false -d true -sh true ($shapes[0] + ".worldMesh[0]")`;
				if( size( $connect) > 0 && `nodeType $connect[0]`=="nParticle")
				{
					$particleTransform =`listRelatives -p $connect[0]`;
					select $particleTransform;
					$particleShapeFound=1;
				}
			}
		}
		if( $particleShapeFound==0)
		{
			error -noContext "no particle node found on selection";
		}
	}
}

global proc pdiSelectShapeFromParticle()
{
	$selection = `ls -selection -dag -type "transform"`;
    if( size($selection) == 0)
    {
		error -noContext "no transform node found in selection";
	}
	else
	{
	    int $operationDone=0;

		$nParticles =`listRelatives -typ nParticle $selection[0]`;		
		if( size($nParticles) > 0)
		{
			string $connect[]=`listConnections -s true -d false -sh true ($nParticles[0] + ".goalGeometry[0]")`;
			if( size( $connect) > 0 && `nodeType $connect[0]`=="mesh")
			{
				$nodeTransform =`listRelatives -p $connect[0]`;
				select -add $nodeTransform;
				$operationDone=1;
			}					
		}
		else
		{
			$shapes =`listRelatives -path -ni -typ mesh  $selection[0]`;
			if( size($shapes) > 0)
			{
				string $connect[]=`listConnections -s false -d true -sh true ($shapes[0] + ".worldMesh[0]")`;
				if( size( $connect) > 0 && `nodeType $connect[0]`=="nParticle")
				{
					$particleTransform =`listRelatives -p $connect[0]`;
					select -add $particleTransform;
					$operationDone=1;
				}
			}
		}
			
		if( $operationDone==0)
		{
			error -noContext "cannot find particle node on selection";
		}
	}
}


global proc pdiRemoveParticlesExecute()
{
	$selection = `ls -selection -dag -type "transform"`;

    if( size($selection) == 0)
    {
		error -noContext "no transform node found in selection";
	}
	else
	{
	    int $particleShapeFound=0;
		for($obj in $selection)
		{
			$shapes =`listRelatives -path -ni -typ mesh $obj`;
			if( size($shapes) > 0)
			{
				string $connect[]=`listConnections -s false -d true -sh true ($shapes[0] + ".worldMesh[0]")`;
				if( size( $connect) > 0 )
				{
					for($obj in $connect)
					{			
						if( `nodeType $obj`=="nParticle")
						{
							//delete previous nParticle object
							$particleTransform =`listRelatives -p $obj`;
							delete $particleTransform;
							$particleShapeFound=1;
							break;
						}
					}
				}
				string $connect2[]=`listConnections -s false -d true ($shapes[0] + ".outMesh")`;		
				if( size( $connect2) > 0 )
				{	
					for($obj in $connect2)
					{			
						if( `nodeType $obj`=="closestPointOnMesh")
						{
							//delete previous CP object
							delete $obj;
							break;
						}
					}
				}

			}
			else
			{
				$nParticles =`listRelatives -typ nParticle $obj`;		
				if( size($nParticles) > 0)
				{
					string $connect[]=`listConnections -s true -d false -sh true ($nParticles[0] + ".goalGeometry[0]")`;
					if( size( $connect) > 0 && `nodeType $connect[0]`=="mesh")
					{
						delete $nParticles[0];
						$particleShapeFound=1;
					}					
				}	
			}
		}
		if( $particleShapeFound==0)
		{
			error -noContext "no particle node found on selection";
		}
	}
}

global proc pdiAddParticlesExecute()
{
	global string $fielPdiNumParticles;
	global string $pdiSelMaterialsList;
	global int $sceneMinTime;
	global int $sceneMinSimTime;

    $sceneMinTime = `playbackOptions -query -minTime`;
    $sceneMinSimTime = `playbackOptions -query -ast`;

	$selection = `ls -selection -dag -type "transform"`;

    if( size($selection) == 0)
    {
		error -noContext "no transform node found in selection";
	}
	else
    if( size($selection) > 1)
    {
		error -noContext "only one single node allowed for adding particles, hint: combine fragments to emmit from";
	}
	else
	{

		$rigidBodies=`listRelatives -ad -typ pdiRigidBody $selection[0]`;    
		if( size($rigidBodies) > 0)
		{
			error -noContext "fragment has rigid body attached, delete pdi bodies from selection before adding particles";
			return;
		}

		string $node = $selection[0];
		int $lenght = size($node);
	    $nodeName = `substring $node 2 $lenght`;			
		$nodePath =`ls  -ap $nodeName`;
		if( size($nodePath) > 1)
		{
			string $msg = ("several scene nodes are named " + $nodeName);
			error -noContext $msg;
			return;
		}

		$shapes =`listRelatives -typ mesh $selection[0]`;

		if( size($shapes) == 0)
		{
			error -noContext "no shape node found in selection";
			return;
		}
		string $connect[]=`listConnections -s false -d true -sh true ($shapes[0] + ".worldMesh[0]")`;
		if( size( $connect) > 0 )
		{	
			for($obj in $connect)
			{			
				if( `nodeType $obj`=="nParticle")
				{
					//delete previous nParticle object
					$particleTransform =`listRelatives -p $obj`;
					delete $particleTransform;
					break;
				}
			}
		}
		string $connect2[]=`listConnections -s false -d true ($shapes[0] + ".outMesh")`;		
		if( size( $connect2) > 0 )
		{	
			for($obj in $connect2)
			{			
				if( `nodeType $obj`=="closestPointOnMesh")
				{
					//delete previous CP object
					delete $obj;
					break;
				}
			}
		}

		playbackOptions -minTime 1 -ast 1;

	    int $num = `intSliderGrp -q -value $fielPdiNumParticles`;	

		string $selmat[] = `textScrollList -query -selectItem $pdiSelMaterialsList`;

		string $particleShapePdi = `pdiAttachParticles -np $num -emt $selmat[0] $shapes[0]`;

//		print ("particle name = " + $particleShape +"\n");

		if( size( $particleShapePdi) > 0)
		{
			$targetShape = $shapes[0];
			string $CPOMNode = `createNode closestPointOnMesh`;
			connectAttr -f( $targetShape + ".outMesh") ($CPOMNode + ".inMesh");

			string $expressionPDi = " string $CPOMNode = " + "\"" + $CPOMNode + "\";" + 									
									"\nvector $targetPos = " +  $particleShapePdi + ".position" + ";" +
									"\nsetAttr ($CPOMNode + \".inPositionX\") ($targetPos.x);" +
									"\nsetAttr ($CPOMNode + \".inPositionY\") ($targetPos.y);" +
									"\nsetAttr ($CPOMNode + \".inPositionZ\") ($targetPos.z);" +
									"\n$tu =`getAttr( $CPOMNode + \".parameterU\")`;" +
									"\n$tv =`getAttr( $CPOMNode + \".parameterV\")`;"+
									"\n" + $particleShapePdi +".goalU = $tu" + ";" +
									"\n" + $particleShapePdi +".goalV = $tv" + ";" +
									"\n";//delete $CPOMNode;";
		   //print $expression;

		    dynExpression - s $expressionPDi -c $particleShapePdi; 

			evalDeferred -lp "playbackOptions -minTime $sceneMinTime -ast $sceneMinSimTime;";

			select $particleShapePdi;		   
		}
		else
		{
			playbackOptions -minTime $sceneMinTime -ast $sceneMinSimTime;
		}
	}
}
global proc updatePdiAddParticlesSelMat()
{
	global string $pdiSelMaterialsList;
	global string $pdiSwatchSelMat;
	global string $pdiLblAddParticlesSelMat;

	string $selmat[] = `textScrollList -query -selectItem $pdiSelMaterialsList`;
	swatchDisplayPort -edit -sn $selmat[0] $pdiSwatchSelMat;
	text -edit -l $selmat[0] $pdiLblAddParticlesSelMat;
}

global proc updatePdiAddParticlesPanel()
{
    global string $pdiAddParticlesWindow;
	global string $pdiSelMaterialsList;
	global string $pdiSwatchSelMat;
	global string $pdiLblAddParticlesSelMat;

	$selection = `ls -selection -dag -leaf -type "mesh"`;

	string $shaders[] = getPrimeConnectedShaders($selection);
	if(size( $shaders)>0)
	{
		string $lastSelectedItem[] = `textScrollList -q -si $pdiSelMaterialsList`;

//		string $listItems[] = `textScrollList -q -ai $pdiSelMaterialsList`;

		textScrollList -edit -removeAll $pdiSelMaterialsList;
		for($obj in $shaders)
		{
			textScrollList -edit -append $obj $pdiSelMaterialsList;
		}
		for($obj in $shaders)
		{
			if( $lastSelectedItem[0] == $obj)
			{
				textScrollList -e -si  $lastSelectedItem[0] $pdiSelMaterialsList;        
				break;
			}
		}

		$lastSelectedItem = `textScrollList -q -si $pdiSelMaterialsList`;

		if( size($lastSelectedItem)==0)
			textScrollList -edit -sii 1 $pdiSelMaterialsList;


		string $selmat[] = `textScrollList -query -selectItem $pdiSelMaterialsList`;
		swatchDisplayPort -edit -sn $selmat[0] $pdiSwatchSelMat;
		text -edit -l $selmat[0] $pdiLblAddParticlesSelMat;
    }

//	showWindow $pdiAddParticlesWindow;
//	setFocus MayaWindow;    

}

global proc  pdiAddParticlesPanel()
{
    global string $pdiAddParticlesWindow;
	global string $butPdiAddParticles;    
	global string $pdiSelMaterialsList;
	global string $pdiSwatchSelMat;
	global string $pdiLblAddParticlesSelMat;
	global string $fielPdiNumParticles;
	global int $UpdatePdiAddParticlesPanelJobId;

    //check if the window exists
    if ( `window -ex pdiAddParticlesWin` )
    {                        
		updatePdiAddParticlesPanel();

    	showWindow $pdiAddParticlesWindow;
        
        return;
    }

	$pdiAddParticlesWindow = `window -rtf true -t " Attach Particles to Faces" -width 300 -height 300 pdiAddParticlesWin`;

	columnLayout -adjustableColumn true;  	
    $butPdiSelectParticles = `button  -w 300 -h 30 -label "Select Particle Node binded to selected"  -enable true
    -ann " select particles attached to selected shape"
     -command "pdiSelectParticleFromShape"`; 

    $butPdiSelectShape = `button  -w 300 -h 30 -label "Select Particle and Shape Nodes"  -enable true
    -ann " select both particle and shape node"
     -command "pdiSelectShapeFromParticle"`; 

    $butPdiRemoveParticles = `button  -w 300 -h 30 -label "Remove All Particles on selected"  -enable true
    -ann "remove particles from selected shape"
     -command "pdiRemoveParticlesExecute"`; 

    frameLayout -width 300 -height 200 -label "Attach Maya nParticles to shape material ";
	columnLayout -adjustableColumn true;   
	string $pdiLabelSelMatList = `text -w 120 -font "smallBoldLabelFont" -align "left" -label "Selected Node Shape Materials "`;	
    $pdiSelMaterialsList = `textScrollList -w 300 -numberOfRows 3 -allowMultiSelection false -selectCommand "updatePdiAddParticlesSelMat"` ;	
	rowLayout -nc 2 -adj 2;
			$pdiSwatchSelMat = `swatchDisplayPort -wh 64 64`;
			$pdiLblAddParticlesSelMat = `text -l ""`;
	setParent ..;    
	            
    $fielPdiNumParticles = `intSliderGrp -label "Num particles aprox " -field true
	        -minValue 10 -maxValue 1000 -fieldMaxValue 1000 -value 10`;
    $butPdiAddParticles = `button  -w 300 -h 30 -label "Update Particles on selected"  -enable true
    -ann " HINT: adding particles to emmit fluids or extta debris from selected fragment"
     -command "pdiAddParticlesExecute"`; 
		setParent..;
	setParent..;

    $UpdatePdiAddParticlesPanelJobId = `scriptJob -event SelectionChanged updatePdiAddParticlesPanel`;

    scriptJob -uiDeleted $pdiAddParticlesWindow killUpdatePdiAddParticlesPanelJob;

	updatePdiAddParticlesPanel();	

	showWindow $pdiAddParticlesWindow;
}

global proc  pdiAddJagginessPanel()
{ 
    global string $pdiShatterItJaginessWindow;
	global string $butPdiSelectJaggyFragment;    
    global string $fielShitJagResolution;
    global string $fieldShitJagStrenght;
	global string $fieldJaggiSoftenEdges;
    global string $butPdiAddJagginess;
	global string $butPdiRemoveJagginess;
	global string $butPdiSoftenEdges;
	global string $pdiJaggyAfectcollection;
   	global string $pdijaggyAffect[3];	
	global string $SelectJaggyFragment;	   	
    global int $UpdateJaggyWindowJobId;	

    //check if the window exists
    if ( `window -ex pdiShatterJagginessWin` )
    {                
//        updatePdiAddJagginessWindow();
        
	    showWindow pdiShatterJagginessWin;
        
        return;
    }

	$pdiShatterItJaginessWindow = `window -rtf true -t " Add Jagginess Deformer" -width 400 -height 300 pdiShatterJagginessWin`;
	columnLayout -adjustableColumn true -rs 5;               
    $butPdiSelectJaggyFragment = `button  -w 400 -h 30 -label "Select PDI Fragment"
	-bgc 0.9 0.6 0.0 -command "pdiCheckFragmentForJaggy"`;
    $butPdiAddJagginess = `button  -w 400 -h 20 -label "Add Jagginess" -bgc 0.25 0.25 0.25 -aop true -enable false
    -ann " HINT: adding jagginess after baking keys for faster computing"
     -command "pdiAddJagginessExecute"`; 
    $butPdiRemoveJagginess = `button  -w 400 -h 20 -label "Remove Jagginess" -bgc 0.25 0.25 0.25 -aop true -enable false 
	-command "pdiRemovejagginessExecute"`; 
	
    frameLayout -width 400 -height 50 -label "Affect";
        rowLayout -columnWidth3 125 125 125 -numberOfColumns 3;
        $pdiJaggyAfectcollection=`radioCollection`;
            $pdijaggyAffect[0]=`radioButton -label "single fragment" -cc "pdiUpdateJagginessPanel"`;
            $pdijaggyAffect[1]=`radioButton -label "shatter group" -select`;// -onCommand "setPdiJaggyStrenght"`;
            $pdijaggyAffect[2]=`radioButton -label "broken fragments only" -cc "pdiUpdateJagginessPanel"`;
			setParent..;
		setParent..;
	
    frameLayout -width 400 -height 100 -label "Strength";
    	columnLayout -adjustableColumn true; 
        $fieldShitJagStrenght = `floatSliderGrp -label "Amplitude" -field true
	        -minValue 0.0 -maxValue 4.0 -value 1.0 -cc "setPdiJaggyStrenght"`; 
        $fielShitJagResolution = `intSliderGrp -label "Resolution" -field true
	        -minValue 1 -maxValue 4 -value 3`;
		setParent..;
	setParent..;

    frameLayout -width 400 -height 100 -label "Soften Edges";
    	columnLayout -adjustableColumn true; 
        $fieldJaggiSoftenEdges = `floatSliderGrp -label "Min Angle" -field true
	        -minValue 0.0 -maxValue 90.0 -value 0.0 -pre 2 -ss 0.05`; 
	    $butPdiSoftenEdges = `button  -w 75 -h 30 -label "Update Edges" -aop true -enable true
		-ann " HINT: soften jaggy edges according to soften angle" -command "setPdiJaggySoftEdges"`; 
//		$chkShitSoftEdges = `checkBox -label "soften edges" -align "left" -enable 1 -changeCommand "setPdiJaggySoftEdges"`;	        
        setParent..;
    setParent..;

    $UpdateJaggyWindowJobId = `scriptJob -event SelectionChanged pdiSelectFragmentForJaggy`;
    scriptJob -uiDeleted $pdiShatterItJaginessWindow killUpdateJaggyWindowJob;

	if( $SelectJaggyFragment!="")
	{	
		$SelectJaggyFragment="";
		pdiSelectFragmentForJaggy();
	}	

    showWindow $pdiShatterItJaginessWindow;
}
global proc killUpdateJaggyWindowJob()
{
    global int $UpdateJaggyWindowJobId;

    scriptJob -kill $UpdateJaggyWindowJobId;
}
//////////////////////////////////////////////////////////////////////////
global proc setCrackerMultiplier()
{
	global string $pdiCrackersList;
	global string $fieldCrackMultiplier;
	global string $fieldCrackRand;

	$selected = `textScrollList -query -selectItem $pdiCrackersList`;
    if( size( $selected) > 0)
    {    
	    float $multiplier = `floatSliderGrp -q -value $fieldCrackMultiplier`;	
	    float $multrand = `floatSliderGrp -q -value $fieldCrackRand`;	

    	setAttr ($selected[0] + ".multiplier" ) $multiplier;
    	setAttr ($selected[0] + ".multrand" ) $multrand;
        //force update
        getAttr ($selected[0] + ".ca_crackerParam" );                               
    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a cracker from the list"
        -button "OK" 
        -defaultButton "OK" ;
    }

}
global proc setPptyCrackerDir()
{
	global string $pdiCrackersList;
	global string $fieldPdiCrackerImpulse;
    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiCrackersList`;

    if( size( $selected) > 0)
    {
	    float $vx = `floatFieldGrp -query -value1 $fieldPdiCrackerImpulse`;
		float $vy = `floatFieldGrp -query -value2 $fieldPdiCrackerImpulse`;
		float $vz = `floatFieldGrp -query -value3 $fieldPdiCrackerImpulse`;

        setAttr ($selected[0] + ".impulseDir" ) -type "float3" $vx $vy $vz;

        //force update
        getAttr ($selected[0] + ".ca_crackerParam" );
    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a cracker from the list"
        -button "OK" 
        -defaultButton "OK" ;
    }
}
global proc updatePdiCrackerStyle()
{
	global string $pdiCrackersList;
	global string $pdiImpulseCollection;
   	global string $pdiImpulseStyle[3];
	global string $fieldPdiCrackerImpulse;

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiCrackersList`;

    if( size( $selected) > 0)
    {
        if( `radioButton -query -select $pdiImpulseStyle[1]`)
        {
            setAttr ($selected[0] + ".type" ) 1;
			floatFieldGrp  -edit -enable 0 $fieldPdiCrackerImpulse;
        }
        else
        if( `radioButton -query -select $pdiImpulseStyle[0]`)
        {
            setAttr ($selected[0] + ".type" ) 0;
			floatFieldGrp  -edit -enable 0 $fieldPdiCrackerImpulse;
        }
		else
        {
            setAttr ($selected[0] + ".type" ) 2;
			floatFieldGrp  -edit -enable 1 $fieldPdiCrackerImpulse;
        }

        //force update
        getAttr ($selected[0] + ".ca_crackerParam" );
    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a cracker from the list"
        -button "OK" 
        -defaultButton "OK" ;
    }

}
global proc createNewCracker()
{
    global string $pdiCrackerCurvePath;
	global string $txtPdiCrackerName;
	global int $pdiCrackerCounter;

	if( $pdiCrackerCurvePath=="")
	{
        error -noContext "no path assigned";
		return;
	}

    int $startTime = `playbackOptions -query -minTime`;
    int $endTime = `playbackOptions -query -maxTime`;

    // create an object, e.g. a sphere
	float $radius = 1.0;

	//currently useless as spline hant any parent
//	$parent1=`listRelatives -p $pdiCrackerCurvePath`;
//	$parent =`listRelatives -p $parent1[0]`;
//	if( size($parent) > 0)
//	{
//		float $bbox[]= `polyEvaluate -b -ae $parent1[0]`;
//		float $x = $bbox[1] - $bbox[0];
//		float $y = $bbox[3] - $bbox[2];
//		float $z = $bbox[5] - $bbox[4];
//		vector $v = <<$x,$y,$z>>;
//		$radius = mag($v)/200;
//	}
                     
//    string $crackerName = ($pdiCrackerName +"Node");
//    string $cracker[] = `ls $crackerName`;
//    if( size($cracker) > 0)
//    {
//        delete $cracker;
//    }           

    $crackername = `textField -query -text $txtPdiCrackerName`;

    $cracker = `polySphere -n $crackername -sx 12 -sy 12 -axis 0 1 0 -radius $radius`;
    pathAnimation  -stu $startTime -etu $endTime  -c $pdiCrackerCurvePath $cracker[0];

    //create pdiSolver node if necessary
    pdiSolver;
    string $crackerShapes[] = `listRelatives -path -ni -s $cracker[0]`;

	//prevent visibility in render(arnold only)
    for ( $obj in $crackerShapes )
	{
		setAttr ($obj + ".primaryVisibility" ) 0;
		setAttr ($obj + ".castsShadows" ) 0;
	}

    string $newPdiCracker = `pdiCracker $crackerShapes[0]`;

	$pdiCrackerCounter++;

	$pdiCrackerCurvePath="";

	updatePdiCrackersPanel();
}

global proc assignCrackePath()
{
    global string $pdiCrackerCurvePath;
	global string $btPdiAssignCrakerPath;

    string $selection[] = `ls -selection -dag -type "nurbsCurve"`;

    if( size($selection) > 0)
    {
        $pdiCrackerCurvePath = $selection[0];
        string $selected = "Path: " +  $pdiCrackerCurvePath;
        button -edit -label $selected $btPdiAssignCrakerPath;
    }
    else
    {
        button -edit -label "Assign Path" $btPdiAssignCrakerPath;
        warning -noContext "Pdi Info: No curve object selected";
    }
}

global proc setPdiCrackerSize()
{
	global string $pdiCrackersList;
	global string $fieldPdiCrackerSize;

	$selected = `textScrollList -query -selectItem $pdiCrackersList`;
    if( size( $selected) > 0)
    {    
		$node = `listRelatives - p $selected[0]`;
		$shape =`listRelatives -path -ni -typ mesh $node[0]`;
		$sphere = `listConnections -type polySphere $shape[0]`;        
		$radius =  getAttr ($sphere[0] + ".radius" ); 
    	setAttr ($selected[0] + ".size" ) $radius;
        //force update
        getAttr ($selected[0] + ".ca_size" );                
    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a cracker from the list"
        -button "OK" 
        -defaultButton "OK" ;
    }
}
global proc setStatePdiCracker()
{
	global string $pdiCrackersList;
	global string $chkEnablePdiCracker;

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiCrackersList`;
    if( size( $selected) > 0)
    {
	    int $bDisabled = `checkBox -q -value $chkEnablePdiCracker`;	

        if( $bDisabled > 0)
        {
    	    setAttr ($selected[0] + ".enabled" ) false;
        }
        else
        {
    	    setAttr ($selected[0] + ".enabled" ) true;
        }
         //force update
	     getAttr ($selected[0] + ".ca_enabled" );

		updatePdiCrackersPanel();
    }
    else
    {
        confirmDialog
        -title "Pdi Info"
        -message "Select a cracker from the list"
        -button "OK" 
        -defaultButton "OK" ;

        checkBox -edit -value 0 $chkEnablePdiCracker;
    }

}
global proc SelectCrackerPath()
{
	global string $pdiCrackersList;

    $selected = `textScrollList -query -selectItem $pdiCrackersList`;
    if( size( $selected) > 0)
    {    
        $node = `listRelatives - p $selected[0]`;
    	$intermediate = `listConnections -type motionPath  $node`;
	    if( size( $intermediate) > 0)
	    {
		    $pathShape = `listConnections -type nurbsCurve $intermediate`;
    		select $pathShape[0];
			setToolTo moveSuperContext;
    	}   
    }	
}
global proc deleteAllPdiCrackers()
{
	global string $pdiCrackersList;

	string  $PDICrackers[];
	$PDICrackers = `ls -dag -leaf -type pdiCracker`;

	if( size($PDICrackers) > 0)
	{
		string $result = `confirmDialog -title "Confirm" -message "this action will destroy all crackers in scene,are you sure?"
		-button "Yes" -button "No" -defaultButton "Yes"
		-cancelButton "No" -dismissString "No"`;
	
		if( $result == "Yes")
		{
			for ( $obj in $PDICrackers )
			{
				$parent =`listRelatives -p $obj`;
				deleteUserNode $obj;
				delete $parent;
			}
			textScrollList -edit -removeAll $pdiCrackersList;
		}
	}

}
global proc deletePdiCracker()
{
	global string $pdiCrackersList;
    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiCrackersList`;

    if( size( $selected) > 0)
    {
        textScrollList -edit -removeItem $selected[0] $pdiCrackersList;
		$parent =`listRelatives -p $selected[0]`;
		deleteUserNode $selected[0];
		delete $parent;
	}
}
global proc updatePdiCrackerParams()
{
	global string $pdiCrackersList;
	global string $chkEnablePdiCracker;
	global string $fieldPdiCrackerSize;
	global string $fieldCrackMultiplier;
	global string $fieldCrackRand;
	global string $pdiImpulseCollection;
   	global string $pdiImpulseStyle[3];
	global string $fieldPdiCrackerImpulse;

    string $selected[];
    $selected = `textScrollList -query -selectItem $pdiCrackersList`;

    if( size( $selected) > 0)
    {
//        $pdiUpdate = 0;//enable update			
	    int $bEnabled = getAttr ($selected[0] + ".enabled" );
	    float $multiplier = getAttr ($selected[0] + ".multiplier" );
	    float $multrand = getAttr ($selected[0] + ".multrand" );
	    int $crackerType = getAttr ($selected[0] + ".type" );
        vector $impulse = getAttr ($selected[0] + ".impulseDir" );

        floatSliderGrp -edit -value $multiplier $fieldCrackMultiplier;
        floatSliderGrp -edit -value $multrand $fieldCrackRand;
		radioCollection -edit -select $pdiImpulseStyle[$crackerType] $pdiImpulseCollection;
        floatFieldGrp  -edit
            -value1 ($impulse.x)
            -value2 ($impulse.y)
            -value3 ($impulse.z)
            $fieldPdiCrackerImpulse;


        if( $bEnabled > 0)
        {
	        checkBox -edit -value false $chkEnablePdiCracker;	
        }
        else
        {
	        checkBox -edit -value true $chkEnablePdiCracker;	
        }

		//update attrFieldSliderGrp
		$node = `listRelatives - p $selected[0]`;
		$shape =`listRelatives -path -ni -typ mesh $node[0]`;
		$sphere = `listConnections -type polySphere $shape[0]`;        
		attrFieldSliderGrp -edit -at ($sphere[0]+".radius") $fieldPdiCrackerSize;

		floatSliderGrp -edit -enable $bEnabled $fieldCrackMultiplier;
        floatSliderGrp -edit -enable $bEnabled $fieldCrackRand;
		radioButton -edit -enable $bEnabled $pdiImpulseStyle[0];
		radioButton -edit -enable $bEnabled $pdiImpulseStyle[1];
		radioButton -edit -enable $bEnabled $pdiImpulseStyle[2];
		attrFieldSliderGrp -edit -enable $bEnabled $fieldPdiCrackerSize;

		string $crackerTransformNode[]=`listRelatives -p $selected[0]`;
		select $crackerTransformNode[0];
	}

}
global proc updatePdiCrackersPanel()
{
    global string $pdiCrackersWindow;
	global string $pdiCrackersList;
	global int $pdiCrackerCounter;
	global string $pdiCrackerName;	
	global string $txtPdiCrackerName;
	global string $btPdiAssignCrakerPath;
    global string $pdiCrackerCurvePath;

    int $bWExist = `window -ex pdiCrakersWin`;
    if( $bWExist == false )
    {
        return;
    }

    textScrollList -edit -removeAll $pdiCrackersList;
	string  $AllPDICrackers[];
	$AllPDICrackers = `ls -exactType pdiCracker`;
	if(size($AllPDICrackers) != 0)
	{
		$pdiUpdate = 0;//disable update		

    	for ( $obj in $AllPDICrackers )
	    {
            textScrollList -edit -append $obj $pdiCrackersList;
        }

		string  $selectedPDICrackers[];
		$selectedPDICrackers = `ls -selection -dag -leaf -type pdiCracker`;

        if( size($selectedPDICrackers) == 0)
		{
			textScrollList -edit -deselectAll $pdiCrackersList;		
		}			     
		else
		{				
			textScrollList -edit -selectItem $selectedPDICrackers[0] $pdiCrackersList;				     
		}
	}

	string $baseName="cracker";
	$pdiCrackerName=$baseName+$pdiCrackerCounter;    
	textField -edit -tx $pdiCrackerName $txtPdiCrackerName;                

	if( $pdiCrackerCurvePath=="")
	{
		button -edit -label "Assign Path" $btPdiAssignCrakerPath;
	}
	else
	{
		button -edit -label $pdiCrackerCurvePath $btPdiAssignCrakerPath;
	}

	updatePdiCrackerParams();              

    showWindow $pdiCrackersWindow;
}

global proc updateSelectedPdiCrackersPanel()
{
	global string $pdiCrackersList;
	string  $selectedPDICrackers[];
	$selectedPDICrackers = `ls -selection -dag -leaf -type pdiCracker`;

	if( size($selectedPDICrackers) >0)
	{
		updatePdiCrackersPanel();
	}
}

global proc createPDICrackersPanel()
{
    global string $pdiCrackersWindow;
	global string $btPdiAssignCrakerPath;
	global string $pdiCrackersList;
	global int $pdiCrackerCounter;
	global string $pdiCrackerName;	
	global string $txtPdiCrackerName;
	global string $chkEnablePdiCracker;
	global string $fieldPdiCrackerSize;
	global string $fieldCrackMultiplier;
	global string $fieldCrackRand;
	global string $pdiImpulseCollection;
   	global string $pdiImpulseStyle[3];
	global string $fieldPdiCrackerImpulse;
    global int $UpdatePdiCrackersPanelJobId;

    //check if the window exists
    if ( `window -ex pdiCrakersWin` )
    {                
		updatePdiCrackersPanel();
        
        return;
    }
    $pdiUpdate = 1;//enable update	
	
	string $baseName="cracker";
	$pdiCrackerName=$baseName+$pdiCrackerCounter;    
	while(1)
	{
		string $exist[]=`ls $pdiCrackerName`;
		if($exist[0]=="")break;
		
		$pdiCrackerCounter++;			
		$pdiCrackerName=$baseName+$pdiCrackerCounter;		
	}		

	$pdiCrackersWindow = `window -rtf true -t "Manage PDI Crackers" -width 100 -height 180 pdiCrakersWin`;
    string $form = `formLayout -numberOfDivisions 100`;
    $pdiLabelCrackers = `text -w 80 -font "boldLabelFont" -label "PDI Crackers"`;
    $pdiCrackersList = `textScrollList -w 120 -numberOfRows 5 -allowMultiSelection false -selectCommand "updatePdiCrackerParams"` ;
    string $butDelete =`button  -w 80 -label "Delete"
    -ann " Delete selected cracker"    
     -command "deletePdiCracker"`;
    string $butDeleteAll =`button  -w 80 -label "Delete All"
    -ann " Delete all crackers in scene"        
     -command "deleteAllPdiCrackers"`;
    string $butSelectPath =`button  -w 120 -label "Select Cracker Path"
    -ann " Select spline of current cracker"        
     -command "SelectCrackerPath"`;
    $chkEnablePdiCracker = `checkBox -label "Disabled"  -enable 1
    -ann " enable/disable selected cracker from computing"        
     -changeCommand "setStatePdiCracker"`;
    $fieldPdiCrackerSize = `attrFieldSliderGrp -cw 3 80 -label "Size" -min 0.1 -max 100.0 -fieldMaxValue 1000.0
	 -ann "set cracker object size" 
     -changeCommand "setPdiCrackerSize"`;
    string $frPdiCrackerCreate = `frameLayout -width 120 -height 110 -label "Create"
    			-ann "create a new cracker object" layOutCreateCracker`;
        columnLayout -adjustableColumn true; 
		$txtPdiCrackerName = `textField -w 100 -h 20 -tx $pdiCrackerName`;
	    $btPdiAssignCrakerPath = `button  -w 100 -h 30 -label "Assign Path"
		-ann " assign a spline for the new cracker object"            	        	        	        	        	            	                                
		-command "assignCrackePath"`;
	    string $bttPdiNewCraker = `button  -w 100 -h 30 -label "New Cracker"
		-ann " create a new cracker object"            	        	        	        	        	            	                                
		-command "createNewCracker"`;
		setParent..;
     setParent..;
    string $frPdiCrackerDir = `frameLayout -width 120 -height 120 -label "Impulse Direction"
    			-ann "set cracker impulse direction " layOutCrackerImpulse`;
        columnLayout -adjustableColumn true; 
		rowLayout -columnWidth3 90 110 90 -numberOfColumns 3;
		$pdiImpulseCollection=`radioCollection`;
		$pdiImpulseStyle[0]=`radioButton -label "Align to path" -select -ann "set impulse along path" -onc "updatePdiCrackerStyle"`;
		$pdiImpulseStyle[1]=`radioButton -label "Align to surface" -ann "set impulse normal to surface " -onc "updatePdiCrackerStyle"`;
		$pdiImpulseStyle[2]=`radioButton -label "Custom" -ann "set custom direction" -onc "updatePdiCrackerStyle"`;
		setParent..;
	        $fieldPdiCrackerImpulse = `floatFieldGrp -cw 1 0 -enable 0 -numberOfFields 3 -label ""
	            -value1 0.0 -value2 1.0 -value3 0.0 
				-ann " set custom direction"                    	             
                -changeCommand "setPptyCrackerDir"` ;
		$fieldCrackMultiplier = `floatSliderGrp -cw 3 80 -label "Multiplier" -field true
	        -minValue 0.1 -maxValue 10.0 -v 1.0
	        -ann "set impulse multiplier"
            -changeCommand "setCrackerMultiplier"` ;	
		$fieldCrackRand = `floatSliderGrp -cw 3 80 -label "Randomize" -field true
	        -minValue 0.0 -maxValue 0.5 -v 0.0
	        -ann "set multiplier randomness"
            -changeCommand "setCrackerMultiplier"` ;	
		setParent..;
     setParent..;

    formLayout -edit
        -attachForm     $pdiLabelCrackers     "top"     0
        -attachForm     $pdiLabelCrackers      "left"    0
        -attachControl     $pdiCrackersList    "top"    10 $pdiLabelCrackers
        -attachForm     $pdiCrackersList      "left"    5
        -attachForm     $pdiCrackersList      "right" 5
        -attachForm     $butSelectPath		 "left"   5
        -attachControl      $butSelectPath		"top"    0 $pdiCrackersList
        -attachControl     $butDelete		   "left"   0 $butSelectPath
        -attachControl      $butDelete		  "top"    0 $pdiCrackersList
        -attachControl     $butDeleteAll     "left" 0 $butDelete      
        -attachControl      $butDeleteAll      "top"    0 $pdiCrackersList
        -attachForm     $butDeleteAll			"right" 5
        -attachForm     $chkEnablePdiCracker	"left"   5
        -attachControl  $chkEnablePdiCracker	"top"    5 $butSelectPath
        -attachForm     $fieldPdiCrackerSize	"left"   5
        -attachControl  $fieldPdiCrackerSize	"top"    5 $chkEnablePdiCracker
        -attachForm		$frPdiCrackerCreate     "left" 5   
        -attachForm		$frPdiCrackerCreate     "right" 5   
        -attachControl  $frPdiCrackerCreate    "top" 10 $fieldPdiCrackerSize
        -attachForm		$frPdiCrackerDir     "left" 5   
        -attachForm		$frPdiCrackerDir     "right" 5   
        -attachControl  $frPdiCrackerDir    "top" 10 $frPdiCrackerCreate
		
	$form;

	$UpdatePdiCrackersPanelJobId = `scriptJob -event SelectionChanged updateSelectedPdiCrackersPanel`;
    scriptJob -uiDeleted $pdiCrackersWindow killUpdateCrackersPanelJob;


	updatePdiCrackersPanel();
}

global proc showPdiLicenseInfo()
{
    global string $pdiLicenseWindow;
    global string $PdiUserName;
	global string $pdiPluginInfo1;
	global string $pdiPluginInfo2;

    $PdiUserName="Demo version";
	string $numLicenses="0";

	if ( `window -ex pdiLicenseWin` )
	{                
			button -e -enable 0 pdiButtonNewLicense;
			button -e -enable 0  pdiButtonCheckLicense;

	    showWindow $pdiLicenseWindow;

		return;
	}

	$pdiLicenseWindow = `window -rtf true -t "License Info" -ret -width 200 -height 300 pdiLicenseWin`;
	columnLayout -adjustableColumn true -rs 20;               
    text -label "Pulldownit 4.7 licensed to: "   -align "center";
    string $PdiUserNamePrompt = `text -label $PdiUserName  -align "center"`;
//        text -label $numLicensestext   -align "center";
     string $butNewLicense = `button  -w 120 -h 30 -label "New License" -command "pdiInputNewLicenseCmd" pdiButtonNewLicense`;
     string $butCheckLicense = `button  -w 120 -h 40 -label "Check License" -command "pdiInputNewLicenseCmd -ch" pdiButtonCheckLicense`;
     text -label $pdiPluginInfo1  -align "center" pdiAuthoredText;
     text -label $pdiPluginInfo2 -align "center" pdiLicenseText;

	$pdiCommand="pdiInputNewLicenseCmd";
	if (!`exists $pdiCommand`) {
		button -e -enable 0 pdiButtonNewLicense;
		button -e -enable 0 pdiButtonCheckLicense;
	}

    showWindow $pdiLicenseWindow;
}
/////////////////////////////////////////////////
global proc pdiUI_createShelfButtons()
{
    // The shelf we want to add the button to.
    global string $gShelfTopLevel;
    global string $pdiShelf = "PulldownIt";
	global string $pdiPluginInfo1 =" Created by Carlos Pegar ";
	global string $pdiPluginInfo2 =" Copyright 2018/2019 Thinkinetic ";

    // The icon we want to use on the button.
    string $iconImage = "pdiCreateIcon.png";
    string $iconImage2 = "pdiSolverIcon.png";
    string $iconImage3 = "pdiManageIcon.png";
    string $iconImage4 = "pdiPropertiesIcon.png";
    string $iconImage5 = "pdiKeysIcon.png";
    string $iconImage6 = "pdiFracturesIcon.png";
    string $iconImage7 = "pdiAvFracturesIcon.png";
    string $iconImage8 = "shatteritIcon.png";
    string $iconImage9 = "thinkineticIcon.png";
    string $iconImage10 = "pdiAddJagginess.png";
    string $iconImage11 = "crackers.png";
    string $iconImage12 = "pdiAddParticles.png";
	
    // The button label.
    string $iconBtnLabel = "Create Pdi Body";
    string $iconBtnLabel2 = "PDI Solver Options";
    string $iconBtnLabel3 = "Manage Pdi World";
    string $iconBtnLabel4 = " Set Pdi Dynamic Properties";
    string $iconBtnLabel5 = " Bake Pdi simulation";
    string $iconBtnLabel6 = " Pdi Basic Fractures";
    string $iconBtnLabel7 = " Pdi Advanced Fractures";
    string $iconBtnLabel8 = " ShatterIt feature";
    string $iconBtnLabel9 = " License info";
    string $iconBtnLabel10 = "Add jagginess to fragments";
    string $iconBtnLabel11 = "Create Pdi crackers";
    string $iconBtnLabel12 = "Add particles to fragments";

    // Specify the shelf as the parent for our tool button.  If there
    // is no such shelf, we create it.
    //
    string $btnParent;
    if ( `shelfLayout -ex $pdiShelf` )
    {
//	    print "Deleting old shelf buttons";
    
        $btnParent = $pdiShelf;

        // delete existing buttons on the shelf.

        string $existingShelfButtons[] = `shelfLayout -q -ca $pdiShelf`;
        for ( $btn in $existingShelfButtons )
		{ 	        
//            string $btnName = `shelfButton -q -l $btn`;

            deleteUI $btn;                
        }        
    } else {
		print "Create new shelf ";

        // Create the shelf under the global shelf parent.
        $btnParent = `shelfLayout -p $gShelfTopLevel $pdiShelf`;
    }

    // Make (or remake) the tool button.
    shelfButton -annotation $iconBtnLabel -l $iconBtnLabel -image1 $iconImage
                -command "showPDiNewRBDTab" -p $btnParent;
    shelfButton -annotation $iconBtnLabel4 -l $iconBtnLabel4 -image1 $iconImage4
                -command "showPdiRBDPropertiesTab" -p $btnParent;
    shelfButton -annotation $iconBtnLabel2 -l $iconBtnLabel2 -image1 $iconImage2
                -command "createPdiSolverPanel" -p $btnParent;
    shelfButton -annotation $iconBtnLabel3 -l $iconBtnLabel3 -image1 $iconImage3
                -command "showPDiManageRBDTab" -p $btnParent;

    shelfButton -annotation $iconBtnLabel11 -l $iconBtnLabel11 -image1 $iconImage11
                -command "createPDICrackersPanel" -p $btnParent;

    shelfButton -annotation $iconBtnLabel8 -l $iconBtnLabel8 -image1 $iconImage8
                -command "showPdiShatteritTab" -p $btnParent;
    shelfButton -annotation $iconBtnLabel6 -l $iconBtnLabel6 -image1 $iconImage6
                -command "showPdiBasicFracturesTab" -p $btnParent;
    shelfButton -annotation $iconBtnLabel7 -l $iconBtnLabel7 -image1 $iconImage7
                -command "showPdiAdvancedFracturesTab" -p $btnParent;
    shelfButton -annotation $iconBtnLabel5 -l $iconBtnLabel5 -image1 $iconImage5
                -command "createPdiBakePanel" -p $btnParent;
    shelfButton -annotation $iconBtnLabel10 -l $iconBtnLabel10 -image1 $iconImage10
                -command "pdiAddJagginessPanel" -p $btnParent;

    shelfButton -annotation $iconBtnLabel12 -l $iconBtnLabel12 -image1 $iconImage12
                -command "pdiAddParticlesPanel" -p $btnParent;

    shelfButton -annotation $iconBtnLabel9 -l $iconBtnLabel9 -image1 $iconImage9
                -command "showPdiLicenseInfo" -p $btnParent pdiLicenseicon;


	//make it on top, removed because of autoload
//	shelfTabLayout -edit -selectTab $btnParent $gShelfTopLevel ;

	setDefaultsPdiFbodyParams("");
}

global proc pdiActivateSingleLicense()
{
}

global proc pdiStoreSingleLicenseInfo()
{
    global string $pdiSingleusername;
    global string $pdiSinglelicensenumber;

    global string $strPdiusername;
    global string $strPdilicensenumber;

    $strPdiusername = `textField -query -text $pdiSingleusername`;

    $strPdilicensenumber = `textField -query -text $pdiSinglelicensenumber`;

    layoutDialog -dismiss "OK";
}

global proc pdiInputLicensePromt()
{
    global string $pdiSingleusername;
    global string $pdiSinglelicensenumber;

    // Get the dialog's formLayout.
    //
    string $form = `setParent -q`;

    // layoutDialog's are not resizable, so hard code a size here,
    // to make sure all UI elements are visible.
    //
    string $RequestCode = `pdiGetComputerInfo`;
    print ("REQUEST CODE: " + $RequestCode + "\n");

    formLayout -e -width 400 $form;

	string $txt1= `text -label "REQUEST CODE:"`;
	string $requestcode = `textField -w 300 -ed false -tx $RequestCode`;
	string $txt2= `text -label "Username: "`;
	$pdiSingleusername = `textField -w 200`;  
	string $txt3 = `text -label "License number"`;
	$pdiSinglelicensenumber = `textField -w 200`;
    string $logo = `picture -image "logoMax.xpm"`;
	string $b1 = `button -w 50 -l "OK"    -c "pdiStoreSingleLicenseInfo"`;
	string $b2 = `button -w 300 -l "Get a license key" -c "pdiActivateSingleLicense"`;


    int $spacer = 15;
    int $top = 5;
    int $edge = 5;

    formLayout -edit
        -attachForm            $txt1  "left"   $edge
        -attachControl         $requestcode  "left" 5 $txt1
        -attachControl         $txt2 "top"    $spacer  $txt1
	-attachForm           $txt2 "left"   $edge
        -attachControl         $pdiSingleusername  "left" 30 $txt2
        -attachControl         $pdiSingleusername  "top"  $spacer $txt1
        -attachControl         $txt3 "top"    $spacer  $txt2
	-attachForm           $txt3 "left"   $edge
        -attachControl         $pdiSinglelicensenumber  "left" 5 $txt3
        -attachControl         $pdiSinglelicensenumber  "top" $spacer $txt2
        -attachControl         $logo "top"    40  $txt3
        -attachControl         $b1 "top"    $spacer  $txt3
	-attachForm           $b1 "right"   $edge
        -attachControl         $b2 "top"    $spacer  $txt3
	-attachForm           $b2 "left"   $edge
   $form;
}
global proc pdiUseProxy()
{
	global string $framePdiUseProxy;
	global string $chkPdiUseProxy;

    int $bUseProxy = `checkBox -q -value $chkPdiUseProxy`;	

    if( $bUseProxy > 0)
    {
		frameLayout -edit -enable true $framePdiUseProxy;
	}
	else
	{
		frameLayout -edit -enable false $framePdiUseProxy;
	}
}


global proc string pdiUiInputLicense()
{
	return "none";
}

global proc string pdiUiInputFloatingLicense()
{
	return "none";
}

global proc string pdiGetLicenseNumber()
{
    global string $strPdilicensenumber;

//    print $strPdilicensenumber;

    return $strPdilicensenumber;
}
global proc string pdiGetInputCompany()
{
    global string $strPdiusername;
    
    return $strPdiusername;
}
global proc string pdiGetProxyHost()
{
	global string $strPdiproxyHost;
    
    return $strPdiproxyHost;
}
global proc string pdiGetProxyPort()
{
	global string $strPdiproxyPort;
    
    return $strPdiproxyPort;
}
global proc string pdiGetProxyLog()
{
    global string $strPdiproxyLog;
    
    return $strPdiproxyLog;
}
global proc string pdiGetProxyKey()
{
    global string $strPdiproxyKey;

    return $strPdiproxyKey;
}

global proc int pdiFloatingLicenseUseProxy()
{
	global int $bPdiUseProxy;

	return $bPdiUseProxy;
}
global proc pdiStoreLicenseInfo()
{
    global string $PdiUserName;
    global string $pdilicensenumber;
    global string $chkPdiUseProxy;
    global string $pdiProxyHostName;
    global string $pdiProxyPort;
    global string $pdiProxyUser;
    global string $pdiProxyPassword;
    global string $strPdiusername;
    global string $strPdilicensenumber;
    global string $strPdiproxyHost;
    global string $strPdiproxyPort;
    global string $strPdiproxyLog;
    global string $strPdiproxyKey;    
	global int $bPdiUseProxy;

    $strPdiusername = `textField -query -text $PdiUserName`;
    $strPdilicensenumber = `textField -query -text $pdilicensenumber`;
    $bPdiUseProxy = `checkBox -q -value $chkPdiUseProxy`;	
    $strPdiproxyHost = `textField -query -text $pdiProxyHostName`;
    $strPdiproxyPort = `textField -query -text $pdiProxyPort`;
    $strPdiproxyLog = `textField -query -text $pdiProxyUser`;
    $strPdiproxyKey = `textField -query -text $pdiProxyPassword`;
    
    layoutDialog -dismiss "OK";
}


global proc pdiUI_initialize()
{
    pdiUI_createShelfButtons();
	            
//    pdiUiInputLicense();
}

global proc pdiSetGravityAxis()
{
    string $PDISolver[]=`ls -type pdiSolverNode`;
	if( size( $PDISolver) == 0)
	{
	  return;
	}

     string $axis=`upAxis -q -axis`; 
    
     if( $axis=="y")
     { 
//         setAttr($PDISolver[0] + ".gravity") -type "float3" 0.0 -10.0 0.0;
         setAttr($PDISolver[0] + ".gravityX") 0.0;
         setAttr($PDISolver[0] + ".gravityY") -10.0;
         setAttr($PDISolver[0] + ".gravityZ") 0.0;
//         print " Maya axys Y"; 
     }       
     else
     { 
//         setAttr($PDISolver[0] + ".gravity") -type "float3" 0.0 0.0 -10.0;
         setAttr($PDISolver[0] + ".gravityX") 0.0;
         setAttr($PDISolver[0] + ".gravityY") 0.0;
         setAttr($PDISolver[0] + ".gravityZ") -10.0;
//         print " Maya axys Z";
     }       
}
global proc string[] getPrimeConnectedShaders(string $from[])
  {
	string $materials[];
  	string $shapes[] = ls("-o", "-dag", "-s", $from);
	if(size($shapes)>0 )
	{
  		string $shadingEngines[] = listConnections("-type","shadingEngine", $shapes);
  		$materials = ls("-mat", listConnections($shadingEngines));
	}
  	return (stringArrayRemoveDuplicates($materials));
  }

global proc pdi_Getvelocity()
{
	string  $PDIObjects[];
	$PDIObjects = `ls -selection -dag -leaf -type pdiRigidBody`;
    vector $velocity = getAttr ($PDIObjects[0] + ".velocity" );
    vector $spin = getAttr ($PDIObjects[0] + ".welocity" );
    
	print ("velocity = " + ($velocity.x) +"," + ($velocity.y) +"," + ($velocity.z) +"\n");
	print ("spin = " + ($spin.x) +"," + ($spin.y) +"," + ($spin.z) +"\n");
}

global proc pdiDuplicateAnimNode( string $sourceNode)
{
 //duplicate an animated node and assign pdi rigid body to child
global int $pdisavedState;

 waitCursor -state on;

 int $BVolumeType = 1;//convex
 int $dynamic_type = 3;//kinematic

 string $sourceShape[] = `listRelatives -path -ni -typ "mesh" $sourceNode`;
 
 if( size($sourceShape)>0) hide $sourceShape[0];

 int $state=0;
 string $pdiobject[] =`listRelatives -type pdiRigidBody $sourceNode`;
 if( size($pdiobject)>0) 
 {
 	$PDIShapes = `listConnections -type pdiCollisionShape $pdiobject[0]`;
	$BVolumeType = getAttr ($PDIShapes[0] + ".type" );

	//$state = getAttr ($pdiobject[0] + ".firstHitActive" );//cause it may have changed?
	$state = $pdisavedState;

 	//print ("dup node state = "+ $state +"\n");

	delete $pdiobject[0];
 }

 $dup = `duplicate $sourceNode`;

 //print $dup;

 parent $dup[0] $sourceNode;

 string $duphape[] = `listRelatives -path -ni -typ "mesh"  $dup[0]`;
 
 showHidden $duphape[0];

 $result=`new_PDIBody -a ($dynamic_type-1) -st $BVolumeType $duphape[0]`;

 if( size($result)>0)
 {
	setAttr ($result[0] + ".firstHitActive" )  $state;
    //force update
    getAttr ($result[0] + ".ca_activeState" );
 }

 select $dup[0];

 waitCursor -state off;

}

proc vector translatePolyInfoNormal( string $pin )
{
  vector $normal;
  float $x;
  float $y;
  float $z;

  string $tokens[];
  int $numTokens = `tokenize $pin " " $tokens`;

  // Make sure we're looking at polyInfo data:
  if ( ( $numTokens > 3 ) && ( $tokens[0] == "FACE_NORMAL" ) )
  {
    $x = ($tokens[$numTokens-3]);
    $y = ($tokens[$numTokens-2]);
    $z = ($tokens[$numTokens-1]);
    $normal = << $x, $y, $z >>;
    $normal = `unit $normal`;
  }

  return $normal;
}






