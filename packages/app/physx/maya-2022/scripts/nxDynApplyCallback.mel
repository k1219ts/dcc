// Copyright (c) 2005 - 2011 NVIDIA Corporation. All rights reserved.
// NVIDIA Corporation and its licensors retain all intellectual property and proprietary 
// rights in and to this software and related documentation and any modifictions thereto.
// Any use, reproduction, disclosure or distribution of this software and related 
// documentation without an express license agreement from NVIDIA Corporation 
// is strictly prohibited.

/*
    Copyright (C) 2007 Feeling Software Inc. ("Feeling")    All rights reserved.
    
	These coded instructions, statements and computer programs (collectively
	the "Data") contain unpublished information proprietary to Feeling Software
	which is protected by Canadian and US federal copyright law and by
	international treaties. The data may not be disclosed to third parties
	or copied or duplicated, in whole or in part, without prior written consent
	of Feeling.
*/

// nxDynApplyCallback.mel
//
// Author: Christian Laforte, Feeling Software Inc. (http://www.feelingsoftware.com)
//
// Much of this code was adapted from Maya's dynApplyCallback.mel. This was
// necessary to reduce possible interroperability issues.
//

//
//  Description:
//      This script contains the callbacks for the Dynamics menus (if
//		no option box is requested) and the "Apply" (Create/Add)
//		buttons of the Dynamics option boxes.  Each callback sets
//		the option vars from the controls, then calls nxPerformDynamics()
//		to execute the command.
//
//  Input Arguments to nxDynApplyCallback():
//		string $theCmd  -- the command selected
//		int $parent --  the parent layout
//
//  IMPORTANT NOTE: nxDynApplyCallback forms command string for each
//  individual callback as "apply<Cmd Name>Callback( string $parent, int $executeCmd )"
//  where <Cmd Name> is the command name passed from nxPerformDynamics and
//  ultimately from the -c argument of the menuItem -optionBox command in
//  the menu script. Each separate callback must take the (string, int)
//  argument pair event if it does not use them.
//

global proc int nxDynCheckOverwriteCacheDirectory( string $path )
//
// Description:
//  if the user has never cached this particular scene before,
// but a directory called "path" already exists, post a confirm
// dialog asking if user wants to overwrite.  If the user aborts,
// return 0 and send a warning to the command line telling the 
// user he/she aborted the operation.  In any other event (either
// the user confirms or she/she had already cached the scene before)
// return 1.
{
	// If the user has not cached this scene before, we want to prevent him/her 
	// from overwriting a previously existing directory by mistake.
	// The nxDynGlobals cache path attribute will be empty if and only if the user
	// has not cached the scene before.  So, check that attribute.
	//
    string $theGlobal;
	string $dynGlobalsPath;
	if (!catch ($theGlobal = `nxDynGlobals -q -active`))
	{
		$dynGlobalsPath = `getAttr ($theGlobal + ".cacheDirectory")`;
	}

	if (size( $dynGlobalsPath ) == 0) 
	{
		int $dirExists = 0; 
		string $dirName;

		// if no workspace particle area defined yet, no cache directory exists.
		//
		string $particleDir =  `workspace -fre particles`;
		if (size($particleDir) > 0)
		{
			$dirName = `workspace -q -rd` + $particleDir + "/" + $path;
			$dirExists = `filetest -d $dirName`;
		}
		if ($dirExists)
		{
			// the directory already exists. Does the user wish to overwrite?
			//
			string $msgString = "A cache directory called " + $path + " already exists. Overwrite?";
			if ("No" ==` confirmDialog -title "Confirm" -message $msgString -button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`)
			{
				// User does not wish to overwrite, so abort
				//
				warning( "You aborted the caching operation. Use the Create Particle Disk Cache option box to enter a new cache name.");
				return 0;
			}
		}
	}

	return 1;
}
		
global proc int nxDynVerifyPath( string $path )
//
// Description:
//   Verifies that the user wants to use this path. Returns true if
// verified, false otherwise.
//
//   If the user has not confirmed this path for this scene, 
// posts a dialog box asking confirmation that the user wants to use $path. 
// Returns true if the user confirms, false otherwise.
// If the user confirms, sets the pathConfirmed attribute to true.
//
//   The effect of this is that each time the user does a Save As and
// attempts to cache the new scene, or else attempt to cache a scene under
// a new path that is not the same as the scene name, he/she will be prompted 
// to provide a new cache name instead of overwriting the old cache.
{
	// If scene agrees with pathname, ok.
	//
	string $scene = `file -q -rpr`;
	if ($path == $scene) return 1;
	
	// If scene does not agree with path name, 
	// check the pathConfirmed and confirmSceneName attributes
	// of nxDynGlobals. 
	//
	int $pathConfirmed = 1;
	string $confirmName;
	string $confirmedPath;

	string $theGlobal = `nxDynGlobals -q -active`;
	if (size($theGlobal) > 0)
	{
		$confirmedPath = `getAttr ($theGlobal+".confirmedPath")`;
		$confirmName   = `getAttr ($theGlobal+".confirmSceneName")`;
	}

	// Get confirmation if either the path has not been confirmed,
	// or the scene name is not the same as what it was confirmed under.
	//
	if (($path != $confirmedPath) || ($scene != $confirmName))
	{
		// Post dialog to ask the user to confirm
		//
		string $msgString = "Your cache directory \""+ $path + "\" is different from your scene name. Writing a cache to this directory may affect other scenes which use it. Use this directory?";

		if ("Yes" ==` confirmDialog -title "Confirm" -message $msgString -button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`)
		{
			// Yes, this is what the user wants.
			//
			$pathConfirmed = 1;

			// Record that the path has been confirmed.
			//
			setAttr -type "string" ($theGlobal+".confirmedPath") $path;

			// Store the scene name for which the path was confirmed.
			//
			setAttr -type "string" ($theGlobal+".confirmSceneName") $scene;
		}
		else
		{
			$pathConfirmed = 0;

			// User said No. Tell him/her how to give us a new path.
			//
			string $infoString = "Use the Create Particle Disk Cache option box to specify a new cache directory";
			confirmDialog -title "Information" -message $infoString -button "Ok" -defaultButton "Ok" -cancelButton "Ok" -dismissString "Ok";
		}
	}

	return $pathConfirmed;
}

global proc nxDynCleanCacheDirectory( string $dir ) 
//
// Description:
//   Delete any previously existing pdc files in the cache directory.
// $dir identifies the cache directory relative to the particle area.
// If particle directory or $dir have not been set up, does nothing 
// (there's nothing to delete).
{
	string $particleDir = `workspace -fre particles`;
	if (size($particleDir) == 0) return;

	string $fullPath = `workspace -q -rd` + $particleDir + "/" + $dir + "/";
	if (!`filetest -d $fullPath`) return;
	
	// See if the directory has anything in it.
	// We do not want to issue the delete command on a directory
	// that contains no pdc files. It gives a confusing message.
	//
	string $dirArr[];  
	$dirArr = `getFileList -fld $fullPath -fs "*.pdc"`;	

	// If there were files, delete them.
	//
	if (size( $dirArr ) > 0)
	{
           string $flName;
		for($flName in $dirArr)
		{
			string $fullFlName = $fullPath + $flName;
			sysFile -del $fullFlName;
		}
	}
}

global proc nxDynApplyCallback(string $theCmd, string $parent, int $executeCmd )
{
    string $procName = ("nxApply"+$theCmd+"Callback");
	string $cmd = $procName+" "+$parent + " " + $executeCmd;
    eval ( $cmd );
}

proc nxVolumeFieldCallback( string $field )
// Description:
//    Get volume field option values from controls.
{

	optionVar -intValue ($field+"VolumeFieldTypesOM") `optionMenuGrp -q -sl ($field+"VolumeFieldTypesOM")`;

	// Volume exclusion does not apply to the volume axis field.
	//
	if ($field != "volumeAxis")
	{
		optionVar -intValue ($field+"VolumeExclusion") `checkBoxGrp -q -v1 ($field+"VolumeExclusion")`;
	}

	optionVar -floatValue ($field+"VolumeOffsetX") `floatSliderGrp -q -v ($field+"VolumeOffsetX")`;
	optionVar -floatValue ($field+"VolumeOffsetY") `floatSliderGrp -q -v ($field+"VolumeOffsetY")`;
	optionVar -floatValue ($field+"VolumeOffsetZ") `floatSliderGrp -q -v ($field+"VolumeOffsetZ")`;

	optionVar -floatValue ($field+"VolumeSweep") `floatSliderGrp -q -v ($field+"VolumeSweep")`;
	optionVar -floatValue ($field+"TorusSectionRadius") `floatSliderGrp -q -v ($field+"TorusSectionRadius")`;

}
global proc nxApplyAirCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	global int $nxDynIsCreate;
    setParent $parent;

	optionVar -stringValue airName `textFieldGrp -q -text airName`;
	optionVar -floatValue airMagnitude `floatSliderGrp -q -v airMagnitude`;
	optionVar -floatValue airAttenuation `floatSliderGrp -q -v airAttenuation`;
	optionVar -floatValue airDirectionX `floatSliderGrp -q -v airDirectionX`;
	optionVar -floatValue airDirectionY `floatSliderGrp -q -v airDirectionY`;
	optionVar -floatValue airDirectionZ `floatSliderGrp -q -v airDirectionZ`;
	optionVar -floatValue airSpeed `floatSliderGrp -q -v airSpeed`;
	optionVar -floatValue airInheritVelocity `floatSliderGrp -q -v airInheritVelocity`;

	optionVar -intValue airInheritRotation `checkBoxGrp -q -v1 airInheritRotation`;
	optionVar -intValue airComponent `checkBoxGrp -q -v1 airComponent`;
	//optionVar -intValue airPerVertex `checkBoxGrp -q -v1 airPerVertex`;
	optionVar -intValue airEnableSpread `checkBoxGrp -q -v1 airEnableSpread`;
	optionVar -floatValue airSpread `floatSliderGrp -q -v airSpread`;
	optionVar -intValue airMaxDistCBox `checkBoxGrp -q -v1 airMaxDistCBox`;
	optionVar -floatValue airMaxDistance `floatSliderGrp -q -v airMaxDistance`;

	nxVolumeFieldCallback( "air" );
	
	if ($executeCmd) {
		nxPerformDynamics $nxDynIsCreate "Air" 0;
		string $tmpCmd = "nxPerformDynamics " + $nxDynIsCreate + " \"Air\" 0";
		addToRecentCommandQueue $tmpCmd "Air";
	}
}


global proc nxApplyDragCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	global int $nxDynIsCreate;
    setParent $parent;

	optionVar -stringValue dragName `textFieldGrp -q -text dragName`;
	optionVar -floatValue dragMagnitude `floatSliderGrp -q -v dragMagnitude`;
	optionVar -floatValue dragAttenuation `floatSliderGrp -q -v dragAttenuation`;
	optionVar -floatValue dragDirectionX `floatSliderGrp -q -v dragDirectionX`;
	optionVar -floatValue dragDirectionY `floatSliderGrp -q -v dragDirectionY`;
	optionVar -floatValue dragDirectionZ `floatSliderGrp -q -v dragDirectionZ`;
	optionVar -intValue   dragUseDirection `checkBoxGrp -q -v1 dragUseDirection`;
	//optionVar -intValue   dragPerVertex `checkBoxGrp -q -v1 dragPerVertex`;
	optionVar -floatValue dragMaxDistCBox `checkBoxGrp -q -v1 dragMaxDistCBox`;
	optionVar -floatValue dragMaxDistance `floatSliderGrp -q -v dragMaxDistance`;


	nxVolumeFieldCallback( "drag" );
	
	if ($executeCmd) {
		nxPerformDynamics $nxDynIsCreate "Drag" 0;
		string $tmpCmd = "nxPerformDynamics " + $nxDynIsCreate + " \"Drag\" 0";
		addToRecentCommandQueue $tmpCmd "Drag";
	}
}


global proc nxApplyGravityCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	global int $nxDynIsCreate;
    setParent $parent;

	optionVar -stringValue gravityName `textFieldGrp -q -text gravityName`;
	optionVar -floatValue gravityMagnitude `floatSliderGrp -q -v gravityMagnitude`;
	optionVar -floatValue gravityAttenuation `floatSliderGrp -q -v gravityAttenuation`;
	optionVar -floatValue gravityDirectionX `floatSliderGrp -q -v gravityDirectionX`;
	optionVar -floatValue gravityDirectionY `floatSliderGrp -q -v gravityDirectionY`;
	optionVar -floatValue gravityDirectionZ `floatSliderGrp -q -v gravityDirectionZ`;
	//optionVar -intValue   gravityPerVertex `checkBoxGrp -q -v1 gravityPerVertex`;
	optionVar -floatValue gravityMaxDistCBox `checkBoxGrp -q -v1 gravityMaxDistCBox`;
	optionVar -floatValue gravityMaxDistance `floatSliderGrp -q -v gravityMaxDistance`;

	nxVolumeFieldCallback( "gravity" );
	
	if ($executeCmd) {
		nxPerformDynamics  $nxDynIsCreate "Gravity" 0;
		string $tmpCmd = "nxPerformDynamics " + $nxDynIsCreate + " \"Gravity\" 0";
		addToRecentCommandQueue $tmpCmd "Gravity";
	}
}


global proc nxApplyNewtonCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	global int $nxDynIsCreate;

    setParent $parent;

	optionVar -stringValue newtonName `textFieldGrp -q -text newtonName`;
	optionVar -floatValue newtonMagnitude `floatSliderGrp -q -v newtonMagnitude`;
	optionVar -floatValue newtonAttenuation `floatSliderGrp -q -v newtonAttenuation`;
	optionVar -floatValue newtonMinDistance `floatSliderGrp -q -v newtonMinDistance`;
	//optionVar -intValue newtonPerVertex `checkBoxGrp -q -v1 newtonPerVertex`;
	optionVar -floatValue newtonMaxDistCBox `checkBoxGrp -q -v1 newtonMaxDistCBox`;
	optionVar -floatValue newtonMaxDistance `floatSliderGrp -q -v newtonMaxDistance`;

	nxVolumeFieldCallback( "newton" );
	
	if ($executeCmd) {
		nxPerformDynamics $nxDynIsCreate "Newton" 0;
		string $tmpCmd = "nxPerformDynamics " + $nxDynIsCreate + " \"Newton\" 0";
		addToRecentCommandQueue $tmpCmd "Newton";
	}
}


global proc nxApplyRadialCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	global int $nxDynIsCreate;

    setParent $parent;

	optionVar -stringValue radialName `textFieldGrp -q -text radialName`;
	optionVar -floatValue radialMagnitude `floatSliderGrp -q -v radialMagnitude`;
	optionVar -floatValue radialAttenuation `floatSliderGrp -q -v radialAttenuation`;
	optionVar -floatValue radialType `floatSliderGrp -q -v radialType`;
	//optionVar -intValue radialPerVertex `checkBoxGrp -q -v1 radialPerVertex`;
	optionVar -intValue radialMaxDistDBox `checkBoxGrp -q -v1 radialMaxDistCBox`;
	optionVar -floatValue radialMaxDistCBox `checkBoxGrp -q -v1 radialMaxDistCBox`;
	optionVar -floatValue radialMaxDistance `floatSliderGrp -q -v radialMaxDistance`;

	nxVolumeFieldCallback( "radial" );
	
	if ($executeCmd) {
		nxPerformDynamics $nxDynIsCreate "Radial" 0;
		string $tmpCmd = "nxPerformDynamics " + $nxDynIsCreate + " \"Radial\" 0";
		addToRecentCommandQueue $tmpCmd "Radial";
	}
}


global proc nxApplyTurbulenceCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	global int $nxDynIsCreate;

    setParent $parent;

	optionVar -stringValue turbulenceName `textFieldGrp -q -text turbulenceName`;
	optionVar -floatValue turbulenceMagnitude `floatSliderGrp -q -v turbulenceMagnitude`;
	optionVar -floatValue turbulenceAttenuation `floatSliderGrp -q -v turbulenceAttenuation`;
	optionVar -floatValue turbulenceFrequency `floatSliderGrp -q -v turbulenceFrequency`;
	optionVar -floatValue turbulencePhaseX `floatSliderGrp -q -v turbulencePhaseX`;
	optionVar -floatValue turbulencePhaseY `floatSliderGrp -q -v turbulencePhaseY`;
	optionVar -floatValue turbulencePhaseZ `floatSliderGrp -q -v turbulencePhaseZ`;
	optionVar -intValue turbulenceNoiseLevel `intSliderGrp -q -v turbulenceNoiseLevel`;
	optionVar -floatValue turbulenceNoiseRatio `floatSliderGrp -q -v turbulenceNoiseRatio`;
	optionVar -floatValue turbulenceMaxDistCBox `checkBoxGrp -q -v1 turbulenceMaxDistCBox`;
	optionVar -floatValue turbulenceMaxDistance `floatSliderGrp -q -v turbulenceMaxDistance`;

	nxVolumeFieldCallback( "turbulence" );
	
	if ($executeCmd) {
		nxPerformDynamics $nxDynIsCreate "Turbulence" 0;
		string $tmpCmd = "nxPerformDynamics " + $nxDynIsCreate + " \"Turbulence\" 0";
		addToRecentCommandQueue $tmpCmd "Turbulence";
	}
}


global proc nxApplyUniformCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	global int $nxDynIsCreate;

    setParent $parent;

	optionVar -stringValue uniformName `textFieldGrp -q -text uniformName`;
	optionVar -floatValue uniformMagnitude `floatSliderGrp -q -v uniformMagnitude`;
	optionVar -floatValue uniformAttenuation `floatSliderGrp -q -v uniformAttenuation`;
	optionVar -floatValue uniformDirectionX `floatSliderGrp -q -v uniformDirectionX`;
	optionVar -floatValue uniformDirectionY `floatSliderGrp -q -v uniformDirectionY`;
	optionVar -floatValue uniformDirectionZ `floatSliderGrp -q -v uniformDirectionZ`;
	//optionVar -intValue uniformPerVertex `checkBoxGrp -q -v1 uniformPerVertex`;
	optionVar -floatValue uniformMaxDistCBox `checkBoxGrp -q -v1 uniformMaxDistCBox`;
	optionVar -floatValue uniformMaxDistance `floatSliderGrp -q -v uniformMaxDistance`;

	nxVolumeFieldCallback( "uniform" );
	
	if ($executeCmd) {
		nxPerformDynamics $nxDynIsCreate "Uniform" 0;
		string $tmpCmd = "nxPerformDynamics " + $nxDynIsCreate + " \"Uniform\" 0";
		addToRecentCommandQueue $tmpCmd "Uniform";
	}
}


global proc nxApplyVortexCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	global int $nxDynIsCreate;

    setParent $parent;

	optionVar -stringValue vortexName `textFieldGrp -q -text vortexName`;
	optionVar -floatValue vortexMagnitude `floatSliderGrp -q -v vortexMagnitude`;
	optionVar -floatValue vortexAttenuation `floatSliderGrp -q -v vortexAttenuation`;
	optionVar -floatValue vortexAxisX `floatSliderGrp -q -v vortexAxisX`;
	optionVar -floatValue vortexAxisY `floatSliderGrp -q -v vortexAxisY`;
	optionVar -floatValue vortexAxisZ `floatSliderGrp -q -v vortexAxisZ`;
	//optionVar -intValue vortexPerVertex `checkBoxGrp -q -v1 vortexPerVertex`;
	optionVar -floatValue vortexMaxDistCBox `checkBoxGrp -q -v1 vortexMaxDistCBox`;
	optionVar -floatValue vortexMaxDistance `floatSliderGrp -q -v vortexMaxDistance`;

	nxVolumeFieldCallback( "vortex" );
	
	if ($executeCmd) {
		nxPerformDynamics $nxDynIsCreate "Vortex" 0;
		string $tmpCmd = "nxPerformDynamics " + $nxDynIsCreate + " \"Vortex\" 0";
		addToRecentCommandQueue $tmpCmd "Vortex";
	}
}


global proc nxApplyVolumeAxisCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	global int $nxDynIsCreate;

    setParent $parent;

	optionVar -stringValue volumeAxisName `textFieldGrp -q -text volumeAxisName`;
	optionVar -floatValue volumeAxisMagnitude `floatSliderGrp -q -v volumeAxisMagnitude`;
	optionVar -floatValue volumeAxisAttenuation `floatSliderGrp -q -v volumeAxisAttenuation`;
	optionVar -floatValue volumeAxisInvertAttenuation `checkBoxGrp -q -v1 volumeAxisInvertAttenuation`;
	optionVar -floatValue volumeAxisMaxDistCBox `checkBoxGrp -q -v1 volumeAxisMaxDistCBox`;
	optionVar -floatValue volumeAxisMaxDistance `floatSliderGrp -q -v volumeAxisMaxDistance`;
	optionVar -floatValue volumeAxisDirectionX `floatSliderGrp -q -v volumeAxisDirectionX`;
	optionVar -floatValue volumeAxisDirectionY `floatSliderGrp -q -v volumeAxisDirectionY`;
	optionVar -floatValue volumeAxisDirectionZ `floatSliderGrp -q -v volumeAxisDirectionZ`;
	optionVar -floatValue volumeAxisAwayFromCenter `floatSliderGrp -q -v volumeAxisAwayFromCenter`;
	optionVar -floatValue volumeAxisAwayFromAxis `floatSliderGrp -q -v volumeAxisAwayFromAxis`;
	optionVar -floatValue volumeAxisAlongAxis `floatSliderGrp -q -v volumeAxisAlongAxis`;
	optionVar -floatValue volumeAxisAroundAxis `floatSliderGrp -q -v volumeAxisAroundAxis`;
	//optionVar -floatValue volumeAxisRandomSpread `floatSliderGrp -q -v volumeAxisRandomSpread`;
	optionVar -floatValue volumeAxisDirectionalSpeed `floatSliderGrp -q -v volumeAxisDirectionalSpeed`;
	optionVar -floatValue volumeAxisTurbulence `floatSliderGrp -q -v volumeAxisTurbulence`;
	optionVar -floatValue volumeAxisTurbulenceSpeed `floatSliderGrp -q -v volumeAxisTurbulenceSpeed`;
	optionVar -floatValue volumeAxisTurbulenceFrequencyX `floatSliderGrp -q -v volumeAxisTurbulenceFrequencyX`;
	optionVar -floatValue volumeAxisTurbulenceFrequencyY `floatSliderGrp -q -v volumeAxisTurbulenceFrequencyY`;
	optionVar -floatValue volumeAxisTurbulenceFrequencyZ `floatSliderGrp -q -v volumeAxisTurbulenceFrequencyZ`;
	optionVar -floatValue volumeAxisTurbulenceOffsetX `floatSliderGrp -q -v volumeAxisTurbulenceOffsetX`;
	optionVar -floatValue volumeAxisTurbulenceOffsetY `floatSliderGrp -q -v volumeAxisTurbulenceOffsetY`;
	optionVar -floatValue volumeAxisTurbulenceOffsetZ `floatSliderGrp -q -v volumeAxisTurbulenceOffsetZ`;
	optionVar -floatValue volumeAxisDetailTurbulence `floatSliderGrp -q -v volumeAxisDetailTurbulence`;

	nxVolumeFieldCallback( "volumeAxis" );
	
	if ($executeCmd) {
		nxPerformDynamics $nxDynIsCreate "VolumeAxis" 0;
		string $tmpCmd = "nxPerformDynamics " + $nxDynIsCreate + " \"VolumeAxis\" 0";
		addToRecentCommandQueue $tmpCmd "VolumeAxis";
	}
}


global proc nxApplyEmitterCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	global int $nxDynIsCreate;

    setParent $parent;

	optionVar -stringValue emitterName `textFieldGrp -q -text emitterName`;

	// In create, emitter type 3 is volume, which we write to option var as 5.
	//
	int $emitterType =  `optionMenuGrp -q -sl emitterTypesOM`;
	if (($nxDynIsCreate) && ($emitterType == 3))
		$emitterType = 5;
	optionVar -intValue emitterTypesOM $emitterType;
	optionVar -floatValue emitterRate `floatSliderGrp -q -v emitterRate`;
	optionVar -intValue emitterScaleRateByObjectSize `checkBoxGrp -q -v1 emitterScaleRateByObjectSize`;
	optionVar -intValue emitterNeedParentUV `checkBoxGrp -q -v1 emitterNeedParentUV`;
	optionVar -intValue emitterCycleOM `optionMenuGrp -q -sl emitterCycleOM`;
	optionVar -intValue emitterCycleInterval `intSliderGrp -q -v emitterCycleInterval`;

	optionVar -floatValue emitterMaxDistance `floatSliderGrp -q -v emitterMaxDistance`;
	optionVar -floatValue emitterMinDistance `floatSliderGrp -q -v emitterMinDistance`;
	optionVar -floatValue emitterDirectionX `floatSliderGrp -q -v emitterDirectionX`;
	optionVar -floatValue emitterDirectionY `floatSliderGrp -q -v emitterDirectionY`;
	optionVar -floatValue emitterDirectionZ `floatSliderGrp -q -v emitterDirectionZ`;
	optionVar -floatValue emitterSpread `floatSliderGrp -q -v emitterSpread`;

	optionVar -floatValue emitterSpeed `floatSliderGrp -q -v emitterSpeed`;
	optionVar -floatValue emitterSpeedRandomRange `floatSliderGrp -q -v emitterSpeedRandomRange`;
	optionVar -floatValue emitterNormalSpeed `floatSliderGrp -q -v emitterNormalSpeed`;
	optionVar -floatValue emitterTangentSpeed `floatSliderGrp -q -v emitterTangentSpeed`;

	
	optionVar -intValue emitterVolumeShapeOM `optionMenuGrp -q -sl emitterVolumeShapeOM`;
	optionVar -floatValue emitterVolumeOffsetX `floatSliderGrp -q -v emitterVolumeOffsetX`;
	optionVar -floatValue emitterVolumeOffsetY `floatSliderGrp -q -v emitterVolumeOffsetY`;
	optionVar -floatValue emitterVolumeOffsetZ `floatSliderGrp -q -v emitterVolumeOffsetZ`;
	optionVar -floatValue emitterVolumeSweep `floatSliderGrp -q -v emitterVolumeSweep`;
	optionVar -floatValue emitterTorusSectionRadius `floatSliderGrp -q -v emitterTorusSectionRadius`;

	optionVar -floatValue emitterAwayFromCenter `floatSliderGrp -q -v emitterAwayFromCenter`;
	optionVar -floatValue emitterAwayFromAxis `floatSliderGrp -q -v emitterAwayFromAxis`;
	optionVar -floatValue emitterAlongAxis `floatSliderGrp -q -v emitterAlongAxis`;
	optionVar -floatValue emitterAroundAxis `floatSliderGrp -q -v emitterAroundAxis`;
	optionVar -floatValue emitterRandomSpread `floatSliderGrp -q -v emitterRandomSpread`;
	optionVar -floatValue emitterDirectionalSpeed `floatSliderGrp -q -v emitterDirectionalSpeed`;
	optionVar -intValue emitterScaleSpeedBySize `checkBoxGrp -q -v1 emitterScaleSpeedBySize`;
	optionVar -intValue emitterDieOnExit `checkBoxGrp -q -v1 emitterDieOnExit`;

	if ($executeCmd) {
		nxPerformDynamics $nxDynIsCreate "Emitter" 0;
		string $tmpCmd = "nxPerformDynamics " + $nxDynIsCreate + " \"Emitter\" 0";
		addToRecentCommandQueue $tmpCmd "Emitter";
	}
}


global proc nxApplyCollisionCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
    setParent $parent;

	optionVar -floatValue collisionResilience `floatSliderGrp -q -v collisionResilience`;
	optionVar -floatValue collisionFriction `floatSliderGrp -q -v collisionFriction`;
	
	if ($executeCmd) {
		nxPerformDynamics 0 "Collision" 0;
		string $tmpCmd = "nxPerformDynamics 0 \"Collision\" 0";
		addToRecentCommandQueue $tmpCmd "Collision";
	}
}


global proc nxApplyGoalCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
    setParent $parent;

	optionVar -floatValue goalWeight `floatSliderGrp -q -v goalWeight`;
	optionVar -floatValue goalUseTransform `checkBoxGrp -q -v1 goalUseTransform`;
	
	if ($executeCmd) {
		nxPerformDynamics 0 "Goal" 0;
		string $tmpCmd = "nxPerformDynamics 0 \"Goal\" 0";
		addToRecentCommandQueue $tmpCmd "Goal";
	}
}


global proc nxApplyRigidCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	print ("=======================in nxApplyRigidCallback, executeCmd = " + $executeCmd);

    setParent $parent;

	optionVar -stringValue rigidName `textFieldGrp -q -text rigidName`;

	optionVar -intValue rigidCollisionType `checkBoxGrp -q -v1 rigidActiveCollision`; 
	//optionVar -intValue rigidCollide `checkBoxGrp -q -v2 rigidActiveCollision`; 

	optionVar -intValue rigidOverrideMassOrDensity `optionMenuGrp -q -sl rigidOverrideMassOrDensity`;
	optionVar -floatValue rigidMass `floatSliderGrp -q -v rigidMass`;
	optionVar -floatValue rigidDensity `floatSliderGrp -q -v rigidDensity`;

	optionVar -intValue rigidComCBox `checkBoxGrp -q -v1 rigidComCBox`;
	optionVar -floatValue rigidComX `floatSliderGrp -q -v rigidComX`;
	optionVar -floatValue rigidComY `floatSliderGrp -q -v rigidComY`;
	optionVar -floatValue rigidComZ `floatSliderGrp -q -v rigidComZ`;

	optionVar -floatValue rigidBounciness `floatSliderGrp -q -v rigidBounciness`;
	optionVar -floatValue rigidStatFriction `floatSliderGrp -q -v rigidStatFriction`;
	optionVar -floatValue rigidDynFriction `floatSliderGrp -q -v rigidDynFriction`;
	optionVar -floatValue rigidDamping `floatSliderGrp -q -v rigidDamping`;
	optionVar -floatValue rigidAngularDamping `floatSliderGrp -q -v rigidAngularDamping`;
	
	//optionVar -floatValue rigidImpulseX `floatSliderGrp -q -v rigidImpulseX`;
	//optionVar -floatValue rigidImpulseY `floatSliderGrp -q -v rigidImpulseY`;
	//optionVar -floatValue rigidImpulseZ `floatSliderGrp -q -v rigidImpulseZ`;

	//optionVar -floatValue rigidImpulsePosX `floatSliderGrp -q -v rigidImpulsePosX`;
	//optionVar -floatValue rigidImpulsePosY `floatSliderGrp -q -v rigidImpulsePosY`;
	//optionVar -floatValue rigidImpulsePosZ `floatSliderGrp -q -v rigidImpulsePosZ`;

	//optionVar -floatValue rigidSpinImpulseX `floatSliderGrp -q -v rigidSpinImpulseX`;
	//optionVar -floatValue rigidSpinImpulseY `floatSliderGrp -q -v rigidSpinImpulseY`;
	//optionVar -floatValue rigidSpinImpulseZ `floatSliderGrp -q -v rigidSpinImpulseZ`;
	
	optionVar -intValue rigidPosCBox `checkBoxGrp -q -v1 rigidPosCBox`;
	optionVar -floatValue rigidPosX `floatSliderGrp -q -v rigidPosX`;
	optionVar -floatValue rigidPosY `floatSliderGrp -q -v rigidPosY`;
	optionVar -floatValue rigidPosZ `floatSliderGrp -q -v rigidPosZ`;

	optionVar -intValue rigidOrCBox `checkBoxGrp -q -v1 rigidOrCBox`;
	optionVar -floatValue rigidOrX `floatSliderGrp -q -v rigidOrX`;
	optionVar -floatValue rigidOrY `floatSliderGrp -q -v rigidOrY`;
	optionVar -floatValue rigidOrZ `floatSliderGrp -q -v rigidOrZ`;

	optionVar -floatValue rigidInitVelocityX `floatSliderGrp -q -v rigidInitVelocityX`;
	optionVar -floatValue rigidInitVelocityY `floatSliderGrp -q -v rigidInitVelocityY`;
	optionVar -floatValue rigidInitVelocityZ `floatSliderGrp -q -v rigidInitVelocityZ`;

	optionVar -floatValue rigidAngVelocityX `floatSliderGrp -q -v rigidAngVelocityX`;
	optionVar -floatValue rigidAngVelocityY `floatSliderGrp -q -v rigidAngVelocityY`;
	optionVar -floatValue rigidAngVelocityZ `floatSliderGrp -q -v rigidAngVelocityZ`;


	//optionVar -intValue rigidStandInType `optionMenuGrp -q -sl rigidStandInType`;

	//optionVar -intValue rigidTesselation `intFieldGrp -q -v1 rigidTesselation`;
	//optionVar -intValue rigidLayer `intFieldGrp -q -v1 rigidLayer`;
	//optionVar -intValue rigidCacheCBox `checkBoxGrp -q -v1 rigidCacheCBox`;

	if ($executeCmd)
	{
		string $rigidType;
		if (`optionVar -query  rigidCollisionType` == 1)
			$rigidType = "ActiveRigid";
		else
			$rigidType = "PassiveRigid";
		nxPerformDynamics 0 $rigidType 0;
		string $tmpCmd = "nxPerformDynamics 0 \"" + $rigidType + "\" 0";
		string $tmpLabel = $rigidType + "Body";
		addToRecentCommandQueue $tmpCmd $tmpLabel;
	}
}

global proc nxApplyRigidConstraintCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
    setParent $parent;

	optionVar -stringValue rigidConstraintName `textFieldGrp -q -text rigidConstraintName`;
	//optionVar -intValue rigidConstraintType `optionMenuGrp -q -sl rigidConstraintType`;
	optionVar -intValue rigidConstraintConstrainCBox `checkBoxGrp -q -v1 rigidConstraintConstrainCBox`;
	optionVar -intValue rigidConstraintInterCBox `checkBoxGrp -q -v1 rigidConstraintInterCBox`;
	//optionVar -intValue rigidConstraintShowAxisCBox `checkBoxGrp -q -v1 rigidConstraintShowAxisCBox`;
	optionVar -intValue rigidConstraintInWorldspace `checkBoxGrp -q -v1 rigidConstraintInWorldspace`;
	
	optionVar -intValue rigidConstraintTransformType `optionMenuGrp -q -sl rigidConstraintTransformType`;
	
	optionVar -floatValue rigidConstraintPos1X `floatFieldGrp -q -v1 rigidConstraintPos1`;
	optionVar -floatValue rigidConstraintPos1Y `floatFieldGrp -q -v2 rigidConstraintPos1`;
	optionVar -floatValue rigidConstraintPos1Z `floatFieldGrp -q -v3 rigidConstraintPos1`;

	optionVar -floatValue rigidConstraintOrient1X `floatFieldGrp -q -v1 rigidConstraintOrient1`;
	optionVar -floatValue rigidConstraintOrient1Y `floatFieldGrp -q -v2 rigidConstraintOrient1`;
	optionVar -floatValue rigidConstraintOrient1Z `floatFieldGrp -q -v3 rigidConstraintOrient1`;

	optionVar -intValue rigidConstraintSamePosCBox `checkBoxGrp -q -v1 rigidConstraintSamePosCBox`;
	
	optionVar -floatValue rigidConstraintPos2X `floatFieldGrp -q -v1 rigidConstraintPos2`;
	optionVar -floatValue rigidConstraintPos2Y `floatFieldGrp -q -v2 rigidConstraintPos2`;
	optionVar -floatValue rigidConstraintPos2Z `floatFieldGrp -q -v3 rigidConstraintPos2`;
	
	optionVar -intValue rigidConstraintSameOrientCBox `checkBoxGrp -q -v1 rigidConstraintSameOrientCBox`;
	
	optionVar -floatValue rigidConstraintOrient2X `floatFieldGrp -q -v1 rigidConstraintOrient2`;
	optionVar -floatValue rigidConstraintOrient2Y `floatFieldGrp -q -v2 rigidConstraintOrient2`;
	optionVar -floatValue rigidConstraintOrient2Z `floatFieldGrp -q -v3 rigidConstraintOrient2`;
	
	//optionVar -intValue rigidConstraintAffectsOtherFrame `optionMenuGrp -q -sl rigidConstraintAffectsOtherFrame`;	


	//optionVar -floatValue rigidConstraintForceX `floatFieldGrp -q -v1 rigidConstraintForce`;
	//optionVar -floatValue rigidConstraintForceY `floatFieldGrp -q -v2 rigidConstraintForce`;
	//optionVar -floatValue rigidConstraintForceZ `floatFieldGrp -q -v3 rigidConstraintForce`;
	
	optionVar -intValue rigidConstraintBreakableForceCBox `checkBoxGrp -q -v1 rigidConstraintBreakableForceCBox`;
	optionVar -floatValue rigidConstraintMaxForce `floatSliderGrp -q -v rigidConstraintMaxForce`;
	
	optionVar -intValue rigidConstraintBreakableTorqueCBox `checkBoxGrp -q -v1 rigidConstraintBreakableTorqueCBox`;
	optionVar -floatValue rigidConstraintMaxTorque `floatSliderGrp -q -v rigidConstraintMaxTorque`;
	
	
	optionVar -intValue rigidConstraintMotionX `optionMenuGrp -q -sl rigidConstraintMotionX`;	
	optionVar -intValue rigidConstraintMotionY `optionMenuGrp -q -sl rigidConstraintMotionY`;	
	optionVar -intValue rigidConstraintMotionZ `optionMenuGrp -q -sl rigidConstraintMotionZ`;	
	
	optionVar -floatValue rigidConstraintLinearLimitValue `floatSliderGrp -q -v rigidConstraintLinearLimitValue`;
	optionVar -floatValue rigidConstraintLinearLimitRestitution `floatSliderGrp -q -v rigidConstraintLinearLimitRestitution`;
	optionVar -floatValue rigidConstraintLinearLimitSprint `floatSliderGrp -q -v rigidConstraintLinearLimitSpring`;
	optionVar -floatValue rigidConstraintLinearLimitDamping `floatSliderGrp -q -v rigidConstraintLinearLimitDamping`;
	
	optionVar -intValue rigidConstraintMotionTwist `optionMenuGrp -q -sl rigidConstraintMotionTwist`;	
	optionVar -floatValue rigidConstraintTwistLowLimitValue `floatSliderGrp -q -v rigidConstraintTwistLowLimitValue`;
	optionVar -floatValue rigidConstraintTwistLowLimitRestitution `floatSliderGrp -q -v rigidConstraintTwistLowLimitRestitution`;
	optionVar -floatValue rigidConstraintTwistLowLimitSprint `floatSliderGrp -q -v rigidConstraintTwistLowLimitSpring`;
	optionVar -floatValue rigidConstraintTwistLowLimitDamping `floatSliderGrp -q -v rigidConstraintTwistLowLimitDamping`;
	optionVar -floatValue rigidConstraintTwistHighLimitValue `floatSliderGrp -q -v rigidConstraintTwistHighLimitValue`;
	optionVar -floatValue rigidConstraintTwistHighLimitRestitution `floatSliderGrp -q -v rigidConstraintTwistHighLimitRestitution`;
	optionVar -floatValue rigidConstraintTwistHighLimitSprint `floatSliderGrp -q -v rigidConstraintTwistHighLimitSpring`;
	optionVar -floatValue rigidConstraintTwistHighLimitDamping `floatSliderGrp -q -v rigidConstraintTwistHighLimitDamping`;

	optionVar -intValue rigidConstraintMotionSwing1 `optionMenuGrp -q -sl rigidConstraintMotionSwing1`;	
	optionVar -floatValue rigidConstraintSwing1LimitValue `floatSliderGrp -q -v rigidConstraintSwing1LimitValue`;
	optionVar -floatValue rigidConstraintSwing1LimitRestitution `floatSliderGrp -q -v rigidConstraintSwing1LimitRestitution`;
	optionVar -floatValue rigidConstraintSwing1LimitSprint `floatSliderGrp -q -v rigidConstraintSwing1LimitSpring`;
	optionVar -floatValue rigidConstraintSwing1LimitDamping `floatSliderGrp -q -v rigidConstraintSwing1LimitDamping`;

	optionVar -intValue rigidConstraintMotionSwing2 `optionMenuGrp -q -sl rigidConstraintMotionSwing2`;	
	optionVar -floatValue rigidConstraintSwing2LimitValue `floatSliderGrp -q -v rigidConstraintSwing2LimitValue`;
	optionVar -floatValue rigidConstraintSwing2LimitRestitution `floatSliderGrp -q -v rigidConstraintSwing2LimitRestitution`;
	optionVar -floatValue rigidConstraintSwing2LimitSprint `floatSliderGrp -q -v rigidConstraintSwing2LimitSpring`;
	optionVar -floatValue rigidConstraintSwing2LimitDamping `floatSliderGrp -q -v rigidConstraintSwing2LimitDamping`;
	
	if ($executeCmd) {
		nxPerformDynamics 0 "RigidConstraint" 0;
		string $tmpCmd = "nxPerformDynamics 0 \"RigidConstraint\" 0";
		addToRecentCommandQueue $tmpCmd "RigidConstraint";
	}
}

global proc nxApplySoftCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
    setParent $parent;

	optionVar -intValue softCreationOption `optionMenuGrp -q -sl softCreationOption`;
	optionVar -intValue softGoal `checkBoxGrp -q -v1 softGoal`;
	optionVar -intValue softHide `checkBoxGrp -q -v1 softHide`;
	optionVar -intValue softHistory `checkBoxGrp -q -v1 softHistory`;

	optionVar -floatValue softWeight `floatSliderGrp -q -v softWeight`;

	if ($executeCmd) {
		nxPerformDynamics 0 "Soft" 0;
		string $tmpCmd = "nxPerformDynamics 0 \"Soft\" 0";
		addToRecentCommandQueue $tmpCmd "Soft";
	}
}


global proc nxApplyConstrainCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
    setParent $parent;

	optionVar -stringValue constrainName `textFieldGrp -q -text constrainName`;
	optionVar -intValue constrainTypesOM `optionMenuGrp -q -sl constrainTypesOM`;
	optionVar -intValue constrainInterCB `checkBoxGrp -q -v1 constrainInterCB`;

	optionVar -intValue constrainPosCBox `checkBoxGrp -q -v1 constrainPosCBox`;
	optionVar -floatValue constrainPosX `floatSliderGrp -q -v constrainPosX`;
	optionVar -floatValue constrainPosY `floatSliderGrp -q -v constrainPosY`;
	optionVar -floatValue constrainPosZ `floatSliderGrp -q -v constrainPosZ`;

	optionVar -floatValue constrainOrientX
				`floatSliderGrp -q -v constrainOrientX`;
	optionVar -floatValue constrainOrientY
				`floatSliderGrp -q -v constrainOrientY`;
	optionVar -floatValue constrainOrientZ
				`floatSliderGrp -q -v constrainOrientZ`;

	optionVar -floatValue constrainSpringStiffness
				`floatSliderGrp -q -v constrainSpringStiffness`;
	optionVar -floatValue constrainSpringDamping 
				`floatSliderGrp -q -v constrainSpringDamping`;
	optionVar -intValue   constrainSpringRestLengthCBox
				`checkBoxGrp -q -v1 constrainSpringRestLengthCBox`;
	optionVar -floatValue constrainSpringRestLength
				`floatSliderGrp -q -v constrainSpringRestLength`;

	if ($executeCmd) {
		nxPerformDynamics 0 "Constrain" 0;
		string $tmpCmd = "nxPerformDynamics 0 \"Constrain\" 0";
		addToRecentCommandQueue $tmpCmd "Constrain";
	}
}


global proc nxApplySpringCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
    setParent $parent;

	optionVar -stringValue springName `textFieldGrp -q -text springName`;
	optionVar -intValue springAdd `checkBoxGrp -q -v1 springAdd`;
	optionVar -intValue springNoDuplicate `checkBoxGrp -q -v1 springNoDuplicate`;
	optionVar -intValue springExclusive `checkBoxGrp -q -v1 springExclusive`;
	optionVar -intValue springMethodsOM `optionMenuGrp -q -sl springMethodsOM`;

	optionVar -floatValue springMinDistance 
				`floatSliderGrp -q -v springMinDistance`;
	optionVar -floatValue springMaxDistance
				`floatSliderGrp -q -v springMaxDistance`;
	optionVar -intValue springWireWalkLength 
				`intFieldGrp -q -v1 springWireWalkLength`;

	optionVar -intValue springUseStiffnessPS
				`checkBoxGrp -q -v1 springUseStiffnessPS`;
	optionVar -intValue springUseDampingPS
				`checkBoxGrp -q -v1 springUseDampingPS`;
	optionVar -intValue springUseRestLengthPS
				`checkBoxGrp -q -v1 springUseRestLengthPS`;

	optionVar -floatValue springStiffness
				`floatSliderGrp -q -v springStiffness`;
	optionVar -floatValue springDamp `floatSliderGrp -q -v springDamp`;
	optionVar -floatValue springRestLength
				`floatSliderGrp -q -v springRestLength`;
	optionVar -floatValue springStartForceWeight
				`floatSliderGrp -q -v springStartForceWeight`;
	optionVar -floatValue springEndForceWeight
				`floatSliderGrp -q -v springEndForceWeight`;

	if ($executeCmd) {
		nxPerformDynamics 0 "Spring" 0;
		string $tmpCmd = "nxPerformDynamics 0 \"Spring\" 0";
		addToRecentCommandQueue $tmpCmd "Spring";
	}
}

global proc nxApplyParticleInstancerCallback (string $parent, int $executeCmd )
{
    setParent $parent;


	int $value = `optionMenuGrp -q -sl PIautoCycleOM`;
	optionVar -stringValue particleInstancerName  `textFieldGrp   -q -tx particleInstancerName`;
	optionVar -stringValue PIautoCycleOM          `optionMenuGrp  -q -v PIautoCycleOM`;
	optionVar -floatValue  PIautoCycleStepSize    `floatSliderGrp -q -v  PIautoCycleStepSize`;
	optionVar -stringValue PIautoCycleStepUnitsOM `optionMenuGrp  -q -v PIautoCycleStepUnitsOM`;
	optionVar -stringValue PIlevelOfDetailOM      `optionMenuGrp  -q -v PIlevelOfDetailOM`;
	optionVar -stringValue PIrotationUnitsOM      `optionMenuGrp  -q -v PIrotationUnitsOM`;
	optionVar -stringValue PIrotationOrderOM      `optionMenuGrp  -q -v PIrotationOrderOM`;

	updateAllDynamicAttributeOptionVar();

	if ( $executeCmd )
	{
		nxPerformDynamics 0 "ParticleInstancer" 0;
		string $tmpCmd = "nxPerformDynamics 0 \"ParticleInstancer\" 0";
		addToRecentCommandQueue $tmpCmd "ParticleInstancer";
	}
}


global proc nxApplyParticleRenderCacheCallback( string $parent, int $executeCmd )
//
//  Create the particle render cache for the given frame range.
//  Set the useParticleRenderCache variable to true.
//
//  VERY IMPORTANT NOTE:
//  If you make changes here, ALSO CHANGE nxSetParticleRenderCacheCmdString
//  in nxDynApplyCallback.mel.  That routine sets the string for dragging to the shelf.
{
	setParent $parent;

	// Get path control value.
	// (Note: In the case where that value is supposed to come from
	// nxDynGlobals, it is already set to the control by nxDynSetOptionControls.)
	// 
	string $path = `textFieldGrp -q -text particleRenderCacheDirectory`;

	// If path is empty, use scene name instead. We don't allow empty path.
	//
	if (size($path) == 0)
	{
		$path = `file -q -rpr`;
	}
	else
	{
		// If user did specify a path, but it is not the same
		// same as the scene name, make sure this is what the user
		// really wants to do.
		//
		if (!nxDynVerifyPath( $path ))
		{
				// user aborted operation. return.
				//
				return;
		}
	}

	if ($path == "untitled")
	{
			// Post dialog to ask the user to confirm
			//
			string $msgString = "We recommend you give your scene a name first (File | Save). The cache uses the scene name. Continue?";
			if ("No" ==` confirmDialog -title "Confirm" -message $msgString -button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`)
			{
				return;
			}
	}

	if (!nxDynCheckOverwriteCacheDirectory( $path )) return;

	// Check whether we have a particle data area.
	// If not, make one.
	//
	string $particleDir = `workspace -fre particles`;
	if (size($particleDir) == 0)
	{
		workspace -fr particles particles;
	}
	
	// Get and store the value of the useRenderGlobals control
	//
	optionVar -intValue cacheForRenderGlobalsRange `checkBoxGrp -q -v1 cacheForRenderGlobalsRange`;
	optionVar -intValue onlyUpdateParticles        `checkBoxGrp -q -v1 onlyUpdateParticles`;
	// radio buttons 1 = selected 2 = all
	optionVar -intValue cacheAllParticleSystems    (`radioButtonGrp -q -select cacheAllParticleSystems` - 1);

	if ($executeCmd)
	{
		int $useRenderGlobals = `optionVar -query cacheForRenderGlobalsRange`;
		int $onlyUpdateParticles = `optionVar -query onlyUpdateParticles`;
		int $cacheAllParticleSystems = `optionVar -query cacheAllParticleSystems`;
		int $minFrame;
		int $maxFrame;
		if (!$useRenderGlobals)
		{
			// Get current playback range for export.
			//
			$minFrame = `playbackOptions -query -min`;
			$maxFrame = `playbackOptions -query -max`;
		}
		else
		{
			// Get frame range from default render globals
			//
			$minFrame = `getAttr defaultRenderGlobals.startFrame`;
			$maxFrame = `getAttr defaultRenderGlobals.endFrame`;
		}

		nxDynCleanCacheDirectory( $path );

		// Issue the command.
		// The other callbacks go back through nxPerformDynamics,
		// we don't do this because that routine assumes a particular
		// structure and a particular way of using the selection list
		// which we are not doing here.
		//
		string $cmdString = "nxDynExport -path \""+ $path + 
							"\" -f cache -mnf " + $minFrame + 
							" -mxf "+$maxFrame + " -oup " + $onlyUpdateParticles +
							" -all " + $cacheAllParticleSystems;

		evalEcho $cmdString;
		addToRecentCommandQueue $cmdString "Create particle render cache";
	}

	// Save the path in nxDynGlobals.
	// Note: We also get here when $executeCmd is 0, 
	// which happens when the user hits the Save button.
	// So for this control, Save saves the value to nxDynGlobals.
	//
	// Get the nxDynGlobals node
	//
	string $theGlobal;
	if (!catch ($theGlobal = `nxDynGlobals -q -active`))
	{
		setAttr ($theGlobal + ".cacheDirectory") -type "string" $path;	
	}
}

global proc nxUpdateDynamicAttributeOptionVar( string $name )
{
	string $omName = $name + "OM";

    if ( `optionMenuGrp -q -exists $omName` == 1 )
	{
		optionVar -stringValue $omName `optionMenuGrp -q -v $omName`;
	}
}

global proc nxUpdateAllDynamicAttributeOptionVar()
{
    updateDynamicAttributeOptionVar( "Position" );
    updateDynamicAttributeOptionVar( "Rotation" );
    updateDynamicAttributeOptionVar( "Scale" );
    updateDynamicAttributeOptionVar( "Shear" );
    updateDynamicAttributeOptionVar( "AimDirection" );
    updateDynamicAttributeOptionVar( "AimPosition" );
    updateDynamicAttributeOptionVar( "AimAxis" );
    updateDynamicAttributeOptionVar( "AimWorldUp" );
    updateDynamicAttributeOptionVar( "RotationType" );
    updateDynamicAttributeOptionVar( "ObjectIndex" );
    updateDynamicAttributeOptionVar( "CycleStartObject" );
    updateDynamicAttributeOptionVar( "Age" );
    updateDynamicAttributeOptionVar( "Visibility" );
}



